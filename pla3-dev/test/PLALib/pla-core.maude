**** loadmaude loaded dish-occs.maude
fmod DISH-OPS is 
***    inc PROTEINOPS .
    inc THEOPS .    
***    inc STRING .

***(

For conversion of rules to net assume single cell and omit cell type/id
from location 

Loc is Out or LocName 

< thing,loc >  is an Occ (occurrence) --
  loc identifies occurrence of thing  as supernatant or compartment in cell


delOccDish(occ,dish) removes occ from dish -- all of the things at the location
Odiff(ox1:Occs,ox2:Occs) returns the elements of ox1 that are not in ox2
   if Odiff(occs1,occs1) = none then occs1 << occs2.

Osame(ox1:Occs,ox2:Occs) returns the elements that are in both ox1 and ox2
Odiff(ox1:Occs,ox2:Occs) returns the elements that are in ox1 and  not ox2

PL Dish structure 
  dish is PD(dsoup)
       dsoup is (thing + cell) *
       cell is [celltype | lsoup]
       lsoup is [locname | tsoup]*
       tsoup is thing*

Further more celltype is unique in dish
             locname is unique in cell
)

  sort Loc .
  op Out : -> Loc [ctor] .
  op Any : -> Loc [ctor] .  **** for common rules
  subsort LocName < Loc .

***(
ops CLo CLm CLi CLc : -> LocName .  *** Cell - out,mem,in,cytosol
ops NUo NUm NUi NUc : -> LocName .  *** Nucleus - out,mem,in,cytosol
ops MOo MOm MOi MOc : -> LocName .  *** Mitochondria Outer membrane
ops MIo MIm MIi MIc : -> LocName .  *** Mitochondria Inner membrane
ops ERo ERm ERi ERc : -> LocName .  *** EndoplasmicReticulum
ops PXo PXm PXi PXc : -> LocName .  *** PeroXisome
ops GAo GAm GAi GAc : -> LocName .  *** Golgi Apparatus
ops LEo LEm LEi LEc : -> LocName .  *** Late Endosomes
ops LYo LYm LYi LYc : -> LocName .  *** Lysosome
ops CPo CPm CPi CPc : -> LocName .  *** Clathrin Coated Pits
*** op LR : -> LocName .  *** Lipid Rafts in the CM
*** op CC : -> LocName .  *** Clathrin Coated Pits in the CM

)

  sorts Occ Occs .
  subsort Occ < Occs .

  op <_,_> : Thing Loc -> Occ .
  op occThing : Occ -> Thing .
  op occLoc : Occ -> Loc .
  eq occThing(< th:Thing,l:Loc >) = th:Thing .
  eq occLoc(< th:Thing,l:Loc >) = l:Loc .

  op none : -> Occs .
  op __ : Occs Occs -> Occs  [assoc comm id: none] .
  
  op size : Occs -> Nat .
  eq size(none) = 0 .
  eq size(o:Occ os:Occs) = s(size(os:Occs)) .



**** converting dishes, cells, locations to occs
**** drop anything out of place
****08sep13 clt allow rules in occs form
  op pl2occs : Occs -> Occs .
  op pl2occs : Dish -> Occs .
  op pl2occs : Soup -> Occs .  *** don't know what kind of soup

  op dish2occs : Dish -> Occs .
  op dsoup2occs : Soup -> Occs .
  op tsoup2occs : Soup -> Occs .  **** 09july19 
  op csoup2occs : Soup -> Occs .
  op lsoup2occs : Soup Loc -> Occs .

****08sep13 clt allow rules in occs form
  eq pl2occs(occs:Occs) = occs:Occs .
  eq pl2occs(PD(s:Soup)) = dsoup2occs(s:Soup) .
  eq pl2occs(s:Soup c:Cell) = dsoup2occs(s:Soup c:Cell) .
  eq pl2occs(s:Soup l:Location) = csoup2occs(s:Soup l:Location) .
**** 09jul19 clt -- for thing soups of common rules
****  eq pl2occs(s:Soup) = dsoup2occs(s:Soup) .
  eq pl2occs(s:Soup) = tsoup2occs(s:Soup) .

  eq dish2occs(PD(s:Soup)) = dsoup2occs(s:Soup) .

****  eq dsoup2occs(empty) = none .  subsumed by owise

**** 09jul19 clt -- for thing soups of common rules
**** a soup with only things -- no locations or cells
  eq tsoup2occs(th:Thing s:Soup) =  < th:Thing, Any > tsoup2occs(s:Soup) .
  eq tsoup2occs(s:Soup) = none [owise] .
  
  eq dsoup2occs(th:Thing s:Soup) =  < th:Thing, Out > dsoup2occs(s:Soup) .
  eq dsoup2occs([ct:CellType | cs:Soup] s:Soup) = 
         csoup2occs(cs:Soup) dsoup2occs(s:Soup) .
  eq dsoup2occs(s:Soup) = none [owise] .
       
  eq csoup2occs({ln:LocName | ls:Soup } cs:Soup)
        = lsoup2occs(ls:Soup, ln:LocName)
          csoup2occs( cs:Soup) .
  eq csoup2occs(cs:Soup) = none [owise] .

  eq lsoup2occs(th:Thing ls:Soup, l:Loc) =
          < th:Thing, l:Loc > lsoup2occs(ls:Soup, l:Loc) .
  eq lsoup2occs(ls:Soup, l:Loc) = none [owise] .
       

********* Computing with Occs
  op member : Occ Occs -> Occs . *** none or occ

***(
  eq member(o:Occ,none) = none .
  eq member(o:Occ, o1:Occ ox:Occs) = 
       if (o:Occ == o1:Occ) then o:Occ else member(o:Occ, ox:Occs) fi .
)

**** clt 06aug30
  eq member(o:Occ, o:Occ ox:Occs) = o:Occ .
  eq member(o:Occ, ox:Occs) = none [owise] .


  op reduceOccs : Occs -> Occs .
  eq reduceOccs(o:Occ o:Occ ox:Occs) =  reduceOccs(o:Occ ox:Occs) .
  eq reduceOccs(ox:Occs) = ox:Occs [owise] .

   op Odiff : Occs Occs -> Occs .
  eq Odiff(none, ox2:Occs)  = none .
  eq Odiff(o:Occ ox1:Occs, ox2:Occs) =
     (if (member(o:Occ, ox2:Occs) == none) then o:Occ else none fi)
     Odiff(ox1:Occs, ox2:Occs) .
    
  op Osame : Occs Occs -> Occs .
  eq Osame(none, ox2:Occs)  = none .
  eq Osame(o:Occ ox1:Occs, ox2:Occs) =
     member(o:Occ, ox2:Occs)  Osame(ox1:Occs, ox2:Occs) .

  op addOccs : Occs Occs -> Occs . *** add avoiding duplicates
  eq addOccs(accum:Occs,ooccs:Occs) = Odiff(accum:Occs,ooccs:Occs) ooccs:Occs .


*** assuming a dish contains one cell and some outside things
  op delOccDish : Occ Dish -> Dish .
  op delOccCSoup : Thing LocName Soup  -> Soup .
  op delThingSoup : Thing Soup  -> Soup .

**** fixed bug that dropped cell wrapper
  eq delOccDish(< th:Thing, Out >, PD(th:Thing ds:Soup))  =  PD(ds:Soup) .
  eq delOccDish(< th:Thing, ln:LocName >, PD([ct:CellType | cs:Soup] ds:Soup))
      =
     PD([ct:CellType | delOccCSoup(th:Thing,ln:LocName,cs:Soup)] ds:Soup ) .
  eq delOccDish(occ:Occ, d:Dish) = d:Dish [owise] .

  eq delOccCSoup(th:Thing, ln:LocName, {ln:LocName | ls:Soup} cs:Soup) = 
       {ln:LocName | delThingSoup(th:Thing,ls:Soup)} cs:Soup . 
  eq delOccCSoup(th:Thing, ln:LocName, cs:Soup) = cs:Soup [owise] .

  eq delThingSoup(th:Thing, th:Thing ls:Soup) = ls:Soup .
  eq delThingSoup(th:Thing, ls:Soup) = ls:Soup [owise] .

endfm

***(
Drops soup vars keeps other vars

Maude> red lsoup2occs(Src Alk2,CLc) .
reduce in DISH-OPS : lsoup2occs(Alk2 Src, CLc) .
rewrites: 3 in 0ms cpu (0ms real) (~ rewrites/second)
result Occs: < Alk2,CLc > < Src,CLc >
Maude> red lsoup2occs(?ActR2:ActR2 Alk2,CLc) .
reduce in DISH-OPS : lsoup2occs(Alk2 ?ActR2:ActR2, CLc) .
rewrites: 3 in 0ms cpu (0ms real) (~ rewrites/second)
result Occs: < Alk2,CLc > < ?ActR2:ActR2,CLc >
Maude> red lsoup2occs(?ActR2:ActR2 Alk2 ls:Soup,CLc) .
reduce in DISH-OPS : lsoup2occs(?ActR2:ActR2 Alk2 ls:Soup, CLc) .
rewrites: 3 in 0ms cpu (0ms real) (~ rewrites/second)
result Occs: < Alk2,CLc > < ?ActR2:ActR2,CLc >

Maude> red csoup2occs({CLc | ?ActR2:ActR2 Alk2 ls:Soup}) .
reduce in DISH-OPS : csoup2occs(
{CLc |  ?ActR2:ActR2 Alk2 ls:Soup}) .
rewrites: 5 in 0ms cpu (0ms real) (~ rewrites/second)
result Occs: < Alk2,CLc > < ?ActR2:ActR2,CLc >

Maude> red csoup2occs({CLc | ?ActR2:ActR2 Alk2 ls:Soup} cm:Soup) .
reduce in QQQ : csoup2occs(cm:Soup 
{CLc |  ?ActR2:ActR2 Alk2 ls:Soup}) .
rewrites: 5 in 0ms cpu (0ms real) (~ rewrites/second)
result Occs: < Alk2,CLc > < ?ActR2:ActR2,CLc >

Maude> red dsoup2occs(Bmp6 [CellType:CellType | ct:Soup {CLo | clo:Soup} {CLm | clm:Soup ?ActR2:ActR2 Alk2}]) .
reduce in QQQ : dsoup2occs(Bmp6 [CellType:CellType | ct:Soup 
{CLo |  clo:Soup} 
{CLm |  clm:Soup Alk2 ?ActR2:ActR2}]) .
rewrites: 10 in 0ms cpu (0ms real) (~ rewrites/second)
result Occs: < Alk2,CLm > < Bmp6,Out > < ?ActR2:ActR2,CLm >

Maude> red dish2occs(PD(Bmp6 [CellType:CellType | ct:Soup {CLo | clo:Soup} {CLm | clm:Soup ?ActR2:ActR2 Alk2}])) .
reduce in QQQ : dish2occs(PD(Bmp6 [CellType:CellType | ct:Soup 
{CLo |  clo:Soup} 
{CLm |  clm:Soup Alk2 ?ActR2:ActR2}])) .
rewrites: 11 in 0ms cpu (0ms real) (~ rewrites/second)
result Occs: < Alk2,CLm > < Bmp6,Out > < ?ActR2:ActR2,CLm >
)
**** loadmaude loaded petri.maude
**** defined pnets and basic operations there on
fmod PETRI is
  inc QID-LIST .
  inc DISH-OPS .
  inc SIMPLE .    **** for rulenamelists

  sort PNTrans .
****           rid in   out  both
  op pnTrans : Qid Occs Occs Occs -> PNTrans [ctor] .

  sorts PNet PNTransList .
  subsort  PNTrans < PNTransList .

  op nil : -> PNTransList [ctor] .
  op  __ : PNTransList PNTransList -> PNTransList [ctor assoc id: nil] .
  op pnet : PNTransList Occs -> PNet [ctor] .

  var occ : Occ .  vars occs ioccs ooccs boccs preOccs postOccs : Occs .
  vars pntl pntl' pntl0 pntl1 : PNTransList .
  vars pnt pnt' : PNTrans .
  var rid : Qid .
  vars rnl rnl0 : RuleNameList .
  var n : Nat .

  vars kbtl kbtl' : PNTransList .
  vars xoccs newoccs same seenu seend openu opend 
       xoccs' seenu' seend' openu' opend' : Occs .

  op pnt2rid : PNTrans -> Qid .
  ops pnt2pre pnt2post pnt2i pnt2o pnt2b : PNTrans -> Occs .

  eq pnt2rid(pnTrans(rid,ioccs,ooccs,boccs)) = rid .
  eq pnt2pre(pnTrans(rid,ioccs,ooccs,boccs)) = addOccs(ioccs,boccs) .
  eq pnt2post(pnTrans(rid,ioccs,ooccs,boccs)) = addOccs(ooccs,boccs) .
  eq pnt2i(pnTrans(rid,ioccs,ooccs,boccs)) = ioccs .
  eq pnt2o(pnTrans(rid,ioccs,ooccs,boccs)) = ooccs .
  eq pnt2b(pnTrans(rid,ioccs,ooccs,boccs)) = boccs .

  op mkPNTrans : Qid Occs Occs -> PNTrans .
  ceq mkPNTrans(rid,preOccs,postOccs) = pnTrans(rid,ioccs,ooccs,boccs)
  if ioccs := Odiff(preOccs,postOccs)
  /\ ooccs := Odiff(postOccs,preOccs)
  /\ boccs := Osame(postOccs,preOccs) .

  op pntl2rids : PNTransList -> QidList .
  eq pntl2rids(pnt pntl) = pnt2rid(pnt) pntl2rids(pntl) .
  eq pntl2rids(nil) = nil .

  op pnetInit : PNet -> Occs .
  op pnetTrans : PNet -> PNTransList .

  eq pnetInit(pnet(pntl,occs)) = occs .
  eq pnetTrans(pnet(pntl,occs)) = pntl .

  op len : PNTransList -> Nat .
  op lenX : PNTransList Nat -> Nat .
  eq len(pntl) = lenX(pntl,0) .
  eq lenX(nil,n) = n .
  eq lenX(pnt pntl,n) = lenX(pntl,s n) .

  ops getPre getPost : Nat PNTransList -> PNTransList .
  **** getPre(n,L) is prefix of L of length min(n, len(L))
  eq getPre(0, pntl) = nil .
  eq getPre(s n,  nil) = nil .
  eq getPre(s n, pnt pntl) = (pnt getPre(n,pntl) ) .

  **** getPost(n,L) is L' such that L = getPre(n,L) L'
  eq getPost(0, pntl) = pntl .
  eq getPost(s n, nil) = nil .
  eq getPost(s n,  pnt pntl) = getPost(n, pntl) .

  op onlyUsed : PNet -> Occs .
  op onlyUsed : PNTransList Occs  -> Occs .

**** Those init occs that appear as inputs to transitions
  op Used : PNTransList Occ  -> Occs .    **** 0 or 1

  eq onlyUsed(pnet(pntl,occs)) = onlyUsed(pntl,occs) .
  eq onlyUsed(pntl,none) = none .
  eq onlyUsed(pntl, occ occs) = (Used(pntl,occ) onlyUsed(pntl,occs)) .

  eq  Used(nil,occ) = none .
  eq  Used(pnt pntl, occ)
       = ( if (member(occ, pnt2pre(pnt)) =/= none)
           then occ
           else Used(pntl,occ)
           fi ) .

**** all occs occurring in in/out places
  op allOccs : PNTransList -> Occs .
  op allOccsX : PNTransList Occs -> Occs .

  eq allOccs(pntl) = allOccsX(pntl,none) .
  eq allOccsX(nil,occs) = occs .
  eq allOccsX(pnTrans(rid, ioccs,ooccs,boccs) pntl,occs) =
        allOccsX(pntl, addOccs(addOccs(addOccs(occs,ioccs),ooccs),boccs)) .

**** all occs occurring in in/both places
  op allIn : PNTransList -> Occs .
  op allInX : PNTransList Occs -> Occs .

  eq allIn(pntl) = allInX(pntl,none) .
  eq allInX(nil,occs) = occs .
  eq allInX(pnTrans(rid, ioccs,ooccs,boccs) pntl,occs) =
        allInX(pntl, addOccs(ioccs boccs,occs)) .

**** all occs occurring in out places  
  op allOut : PNTransList -> Occs .
  op allOutX : PNTransList Occs -> Occs .

  eq allOut(pntl) = allOutX(pntl,none) .
  eq allOutX(nil,occs) = occs .
  eq allOutX(pnTrans(rid, ioccs,ooccs,boccs) pntl,occs) =
        allOutX(pntl, addOccs(ooccs,occs)) .
  

  op notUsed : PNet -> Occs .
  op notUsed : PNTransList Occs -> Occs .

  eq notUsed(pnet(pntl,occs)) = notUsed(pntl,occs) .
  eq notUsed(pntl,none) = none .
  eq notUsed(pntl, occ occs) =
     ((if (Used(pntl,occ) == occ) then none else occ fi)
      notUsed(pntl,occs)) .

**** rnamelist is shorter -- cdr through it
  op getTrans : PNTransList RuleNameList -> PNTransList .

  eq getTrans(pntl' pnTrans(rid,ioccs,ooccs,boccs) pntl, rid rnl) =
       pnTrans(rid,ioccs,ooccs,boccs)  getTrans(pntl' pntl, rnl)  .

  eq getTrans(pntl,nil) = nil .
  eq getTrans(pntl, rid rnl) =  getTrans(pntl, rnl) [owise] .

**** 07may06
**** add elements of second to first if not already there
  op unionTrans : PNTransList PNTransList -> PNTransList .
  eq unionTrans(pntl, pnTrans(rid,ioccs,ooccs,boccs) pntl') =
      unionTrans(pntl (if getTrans(pntl,rid) == nil 
                       then pnTrans(rid,ioccs,ooccs,boccs)
                       else nil fi),
                 pntl') .

  eq unionTrans(pntl, nil) = pntl .

**** assumes uniform pnt representation      
  op intersectTrans : PNTransList PNTransList -> PNTransList .
  eq intersectTrans( nil, pntl) = nil .
  eq intersectTrans( pnt pntl, pntl0 pnt pntl1) =
       pnt intersectTrans(pntl, pntl0 pntl1) .
  eq intersectTrans( pnt pntl, pntl0 pntl1) =
        intersectTrans(pntl, pntl0 pntl1) [owise] .

**** pntl - pntl'
  op intersectTransC : PNTransList PNTransList -> PNTransList .
  eq intersectTransC( nil, pntl') = nil .
  eq intersectTransC( pnt pntl, pntl0 pnt pntl1) =
        intersectTransC(pntl, pntl0  pntl1) .
  eq intersectTransC( pnt pntl, pntl0 pntl1) =
       pnt intersectTransC(pntl, pntl0 pntl1) [owise] .
    

****************************************************************************
**** for incremental pnet exploration
****************************************************************************
****  XState ~ PNTransList PNTransList PNTransList PNTransList 
****           Occs Occs Occs Occs
  sort XState . 
  op xstate : PNTransList PNTransList PNTransList PNTransList
               Occs Occs Occs Occs -> XState [ctor] .
  sort PNTLPair .
  op `{_,_`} : PNTransList PNTransList -> PNTLPair [ctor] .

  sort Occs4Tuple .
  op `{_,_,_,_`} :  Occs Occs Occs Occs -> Occs4Tuple [ctor] .

  vars scope xnet scope' xnet' new new'  hidden hidden' : PNTransList .
  vars scope1 scope2 scope3 new1 new2 new3 new4 : PNTransList .
  vars sOccs uOccs dOccs bOccs sOccs' uOccs' dOccs' bOccs' : Occs .
  vars inOccs outOccs : Occs .
  vars rids : QidList .
  var xst : XState .

 ops xscope xhidden xnet xnew : XState -> PNTransList .
 ops xseen xup xdn xboth : XState -> Occs .

 eq xscope(xstate(scope,hidden,xnet,new,sOccs,uOccs,dOccs,bOccs)) = scope .
 eq xnet(xstate(scope,hidden,xnet,new,sOccs,uOccs,dOccs,bOccs)) = xnet .
 eq xnew(xstate(scope,hidden,xnet,new,sOccs,uOccs,dOccs,bOccs)) = new .

 eq xhidden(xstate(scope,hidden,xnet,new,sOccs,uOccs,dOccs,bOccs)) = hidden .
 eq xseen(xstate(scope,hidden,xnet,new,sOccs,uOccs,dOccs,bOccs)) = sOccs .
 eq xup(xstate(scope,hidden,xnet,new,sOccs,uOccs,dOccs,bOccs)) = uOccs .
 eq xdn(xstate(scope,hidden,xnet,new,sOccs,uOccs,dOccs,bOccs)) = dOccs .
 eq xboth(xstate(scope,hidden,xnet,new,sOccs,uOccs,dOccs,bOccs)) = bOccs .



**** partition occs of xnet: uOccs -- open for up,   dOccs open for down
****         bOccs open for both  sOccs the rest
  op xSplit : PNTransList PNTransList -> Occs4Tuple .
  ceq xSplit(scope,xnet) = {sOccs,uOccs,dOccs,bOccs}   
    if inOccs := Osame(allOccs(xnet),allIn(scope))
    /\ outOccs :=  Osame(allOccs(xnet),allOut(scope))
    /\ bOccs := Osame(outOccs,inOccs)
    /\ dOccs := Odiff(inOccs,bOccs)
    /\ uOccs := Odiff(outOccs,bOccs)
    /\ sOccs := Odiff(allOccs(xnet),bOccs uOccs dOccs) .

  ops xnetU xnetD xnetB : PNTransList Occs -> PNTLPair .
  ops xnetU1 xnetD1 xnetB1 : PNTransList Occs PNTransList -> PNTLPair .

  eq xnetU(scope,uOccs) = xnetU1(scope,uOccs,nil) .
  eq xnetD(scope,uOccs) = xnetD1(scope,uOccs,nil) .
  eq xnetB(scope,uOccs) = xnetB1(scope,uOccs,nil) .

  eq xnetU1(scope pnTrans(rid,ioccs,occ ooccs,boccs) scope',(occ uOccs),new) =
      xnetU1(scope scope',(occ uOccs),new pnTrans(rid,ioccs,occ ooccs,boccs)) .
  eq xnetU1(scope,(occ uOccs),new) = xnetU1(scope, uOccs,new) [owise] .
  eq xnetU1(scope,none,new) = {scope,new} .

  ceq xnetD1(scope pnTrans(rid,ioccs,ooccs,boccs) scope',(occ uOccs),new) =
       xnetD1(scope scope',(occ uOccs),new pnTrans(rid,ioccs,ooccs,boccs)) 
    if member(occ, ioccs boccs)  == occ .

  eq xnetD1(scope,(occ uOccs),new) = xnetD1(scope, uOccs,new) [owise] .
  eq xnetD1(scope,none,new) = {scope,new} .

  ceq xnetB1(scope pnTrans(rid,ioccs,ooccs,boccs) scope',(occ uOccs),new) =
       xnetB1(scope scope',(occ uOccs),new pnTrans(rid,ioccs,ooccs,boccs)) 
    if member(occ, ioccs ooccs boccs) == occ .

  eq xnetB1(scope,(occ uOccs),new) = xnetB1(scope, uOccs,new) [owise] .
  eq xnetB1(scope,none,new) = {scope,new} .

**** add split trans with id in rids from scope
  op splitTrans : PNTransList QidList PNTransList -> PNTLPair .

**** assumes at most one transition with given rid
  eq splitTrans(scope,nil,new) = {scope,new} .
  eq splitTrans(scope pnTrans(rid,ioccs,ooccs,boccs) scope',rid rids,new) = 
       splitTrans(scope scope',rids,new pnTrans(rid,ioccs,ooccs,boccs)) .
  eq splitTrans(scope,rid rids,new) = splitTrans(scope,rids,new) [owise] .


  op xsAddRules : PNTransList PNTransList PNTransList QidList -> XState .
  op xsHideRules : PNTransList PNTransList PNTransList QidList -> XState .
  op xsUnHideRules : PNTransList PNTransList PNTransList QidList -> XState .
  op exploreFps : PNTransList PNTransList PNTransList Occs Occs Occs -> XState .
  ops exploreUp1 exploreDn1 : XState -> XState .
  ops exploreUp  exploreDn : XState Nat -> XState .

  ceq xsAddRules(scope,hidden,xnet,rids) =
        xstate(scope1,hidden,xnet new,new,sOccs,uOccs,dOccs,bOccs)
    if {scope1,new} := splitTrans(scope,rids,nil) 
    /\ {sOccs,uOccs,dOccs,bOccs} := xSplit(scope1, xnet new) .

  ceq exploreUp1(xstate(scope,hidden,xnet,new,sOccs,uOccs,dOccs,bOccs)) =
       xstate(scope',hidden,xnet new',new',sOccs',uOccs',dOccs',bOccs')
  if {scope',new'} := xnetU(scope,uOccs bOccs)
  /\ {sOccs',uOccs',dOccs',bOccs'} := xSplit(scope', xnet new') .

  eq exploreUp(xst,0) = xst .
  eq exploreUp(xst,s n) = exploreUp(exploreUp1(xst),n)  .

  ceq exploreDn1(xstate(scope,hidden,xnet,new,sOccs,uOccs,dOccs,bOccs)) = 
     xstate(scope',hidden,xnet new',new',sOccs',uOccs',dOccs',bOccs')
  if {scope',new'} := xnetD(scope,dOccs bOccs)
  /\ {sOccs',uOccs',dOccs',bOccs'} := xSplit(scope', xnet new') .

  eq exploreDn(xst,0) = xst .
  eq exploreDn(xst,s n) = exploreDn(exploreDn1(xst),n)  .

**** Note this works whether or not the occs are in the xnet
  ceq exploreFps(scope,hidden,xnet,uOccs,dOccs,bOccs) =
    xstate(scope3,hidden,xnet new4,new4,sOccs',uOccs',dOccs',bOccs')
  if {scope1,new1} := xnetU(scope,uOccs)
  /\ {scope2,new2} := xnetD(scope1,dOccs)
  /\ {scope3,new3} := xnetB(scope2,bOccs)
  /\ new4 := new1 new2 new3
  /\ {sOccs',uOccs',dOccs',bOccs'} := xSplit(scope3, xnet new4) .

  ceq xsHideRules(scope,hidden,xnet,rids) =
        xstate(scope,hidden new,xnet',new,sOccs,uOccs,dOccs,bOccs)
    if {xnet',new} := splitTrans(xnet,rids,nil) 
    /\ {sOccs,uOccs,dOccs,bOccs} := xSplit(scope, xnet') .

  ceq xsUnHideRules(scope,hidden,xnet,rids) =
        xstate(scope new,hidden',xnet,nil,sOccs,uOccs,dOccs,bOccs)
    if {hidden',new} := splitTrans(hidden,rids,nil) 
    /\ {sOccs,uOccs,dOccs,bOccs} := xSplit(scope new, xnet) .


  op compareXnet : PNTransList PNTransList -> XState .
  ceq compareXnet(pntl0,pntl1) =
      xstate(nil,nil,pntl,nil,allOccs(pntl),none,none,none)
  if pntl := unionTrans(pntl0,pntl1) .

endfm

**** loadmaude loaded relevant.maude

mod RELEVANT-SUBNET is
  inc PETRI .
***  inc NAT-QID .

***  op pnTrans : Qid Occs Occs Occs -> PNTrans .
***  op nil : -> PNTransList .
***  op  __ : PNTransList PNTransList -> PNTransList [assoc id: nil] .

  vars pntl pntl' fpntl bpntl : PNTransList .
  var pnt : PNTrans .
  vars ioccs ioccs' ooccs accum unused used goals ngoals ogoals
       omits avoids boccs occs occs' : Occs .
  var rid : Qid .
  var b : Bool .
  var rids rids' : QidList .

  sorts  PNTL3 . **** Transitionlist plus 3 Occ sets
  
  op `{_,_,_,_`} : PNTransList Occs Occs Occs -> PNTL3 [ctor] .

  op pntls-0 : PNTL3 -> PNTransList .
  ops pntls-1 pntls-2 pntls-3 : PNTL3 -> Occs .

  eq pntls-0({pntl,ioccs,unused,used}) = pntl .
  eq pntls-1({pntl,ioccs,unused,used}) = ioccs .
  eq pntls-2({pntl,ioccs,unused,used}) = unused .
  eq pntls-3({pntl,ioccs,unused,used}) = used .

**************************  Ops ***************************************
  op omitRules : PNTransList QidList -> PNTransList .
  op omitRulesX : PNTransList QidList  -> PNTransList .

  op avoidOccs : PNTransList Occs -> PNTransList .
  op avoidOccsX : PNTransList Occs PNTransList -> PNTransList .

****                          Init   
  op fwdCollect : PNTransList Occs -> PNTL3 .
****                    I^Rch I-Rch Rch    *** I-Rch = unused
****       {PNTransList Occs Occs Occs}

****                checking    waiting     collected  accum used more?
  op fwdCollectX : PNTransList PNTransList PNTransList Occs Occs Bool 
                     -> PNTL3 .  **** {fpntl,none,none,used}

****                          Goal                      
  op bwdCollect : PNTransList Occs -> PNTransList .
****                checking    waiting     collected  accum used more?
  op bwdCollectX : PNTransList PNTransList PNTransList Occs Occs Bool 
                     -> PNTransList .

****                         Init Omits
  op prunePNTL : PNTransList Occs Occs ->  PNTL3 .
****                        ioccs goals avoids hides
  op relSubnet : PNTransList Occs Occs Occs QidList -> PNTL3 .
  op relSubnet : PNet Occs Occs QidList -> PNTL3 .
****    {PNTransList Rch I-Rch Rch }

************************** End Ops ***************************************

****  op omitRules : PNTransList QidList  -> PNTransList .
****  op omitRulesX : PNTransList QidList -> PNTransList .
  eq omitRules(pntl,rids) = 
       (if rids == nil
        then pntl
        else omitRulesX(pntl,rids)
        fi) . 

*** cdr through omits
  eq omitRulesX(pntl' pnTrans(rid,ioccs,ooccs,boccs) pntl, rid rids) =
          omitRulesX(pntl' pntl, rids)  .
  eq omitRulesX(pntl, rid rids) = omitRulesX(pntl, rids) [owise] .
  eq omitRulesX(pntl,nil) = pntl .

****  op avoidOccs : PNTransList Occs -> PNTransList .
****  op avoidOccsX : PNTransList Occs PNTransList -> PNTransList .

  eq avoidOccs(pntl,avoids) =
       (if avoids == none
        then pntl
        else avoidOccsX(pntl,avoids,nil) 
        fi) .

  eq avoidOccsX(nil,avoids,pntl) = pntl .
  eq avoidOccsX(pnTrans(rid,ioccs,ooccs,boccs) pntl, avoids, pntl') =
       avoidOccsX(pntl, avoids, pntl'
                 (if Osame(ioccs ooccs boccs,avoids) == none
                  then pnTrans(rid,ioccs,ooccs,boccs)
                  else nil fi)) .

****                              Init   
****  op fwdCollect : PNTransList Occs -> PNTL3 .
****                    Rch  I^Rch I-Rch
****       {PNTransList Occs Occs Occs}

****                   checking    waiting     collected  accum used more?
****  op fwdCollectX : PNTransList PNTransList PNTransList Occs Occs Bool 
****                     -> PNTL3 .  **** {fpntl,accum,used}

  eq fwdCollect(pntl,ioccs) = fwdCol(pntl,ioccs) .

****Alternative for incremental testing

  sort FwdTuple .
  var ft : FwdTuple .
  var n : Nat .
****                    checking   waiting     collected  accum used more?
  op `{_,_,_,_,_,_`} : PNTransList PNTransList PNTransList Occs Occs Bool
         -> FwdTuple .
  ops toCk cked found : FwdTuple -> PNTransList .
  ops accum used : FwdTuple -> Occs .
  op more?  : FwdTuple -> Bool .
  eq toCk({pntl,pntl',fpntl,accum,used,b}) = pntl .
  eq cked({pntl,pntl',fpntl,accum,used,b}) = pntl' .
  eq found({pntl,pntl',fpntl,accum,used,b}) = fpntl .
  eq accum({pntl,pntl',fpntl,accum,used,b}) = accum .
  eq used({pntl,pntl',fpntl,accum,used,b}) = used .
  eq more?({pntl,pntl',fpntl,accum,used,b}) = b .

  op  fwdPass : FwdTuple -> FwdTuple .
 
  op fwdCol : PNTransList Occs -> PNTL3 .
  ceq fwdCol(pntl,ioccs) = 
        {fpntl,Osame(ioccs,used),Odiff(ioccs,used),used} 
      if {nil,pntl',fpntl,accum,used,b} := 
                fwdColX({pntl,nil,nil,ioccs,none,false})  .

  op fwdColX : FwdTuple -> FwdTuple .
  eq fwdColX({nil,pntl',fpntl,accum,used,false}) =
               {nil,pntl',fpntl,accum,used,false} .
      
  eq fwdColX({nil,pntl',fpntl,accum,used,true}) =
       fwdColX({pntl',nil,fpntl,accum,used,false}) .
  
  eq fwdColX({pnt pntl,pntl',fpntl,accum,used,b}) =
       fwdColX(fwdPass({pnt pntl,pntl',fpntl,accum,used,b})) .

****!!!! assume ioccs disjoint boccs
  ceq fwdPass({pnTrans(rid,ioccs,ooccs,boccs) pntl,pntl',fpntl,accum,used,b}) =
       fwdPass({pntl,pntl',fpntl pnTrans(rid,ioccs,ooccs,boccs),
             addOccs(accum,ooccs boccs),
             addOccs(used,ioccs ooccs boccs),
              true})
   if ioccs boccs occs := accum .

   eq fwdPass({pnt pntl,pntl',fpntl,accum,used,b}) =
         fwdPass({pntl,pntl' pnt,fpntl,accum,used,b}) [owise] .

  eq fwdPass({nil,pntl',fpntl,accum,used,b}) = {nil,pntl',fpntl,accum,used,b} .

  op fwdPassX : FwdTuple Nat -> FwdTuple .
  eq fwdPassX(ft,0) = ft .
  ceq fwdPassX(ft,s n) = 
       (if b 
        then fwdPassX({pntl',nil,fpntl,accum,used,b},n)
        else {nil,pntl',fpntl,accum,used,b}
        fi)
     if {nil,pntl',fpntl,accum,used,b} := fwdPass(ft) .


****                            Init Omits
****  op prunePNTL : PNTransList Occs Occs ->  PNTL3 .
  eq prunePNTL(pntl,ioccs,omits) = fwdCollect(pntl,Odiff(ioccs,omits)) .


****                             Goal                      
****  op bwdCollect : PNTransList Occs -> PNTransList .
  
****                  checking    waiting     collected  ngoals ogoals more?
****  op bwdCollectX : PNTransList PNTransList PNTransList Occs Occs Bool 
****                  -> PNTransList .

  eq bwdCollect(pntl,goals) = bwdCollectX(pntl,nil,nil,none,goals,false) .

  eq bwdCollectX(nil,pntl',bpntl,ngoals,ogoals,false) = bpntl .
  eq bwdCollectX(nil,pntl,bpntl,ngoals,ogoals,true) = 
        bwdCollectX(pntl,nil,bpntl,none,ngoals,false) .

  eq bwdCollectX(pnt pntl,pntl',bpntl,ngoals,ogoals,b) =
      (if Osame(pnt2o(pnt),ogoals) =/= none
       then bwdCollectX(pntl,pntl',bpntl pnt,
                        addOccs(ngoals,pnt2pre(pnt)),
                        ogoals,
                        true)
       else bwdCollectX(pntl,pntl' pnt,bpntl,ngoals,ogoals,b) 
       fi) .


****                            ioccs rids  goals avoids
****  op relSubnet : PNTransList Occs Occs Occs QidList-> PNTL3 .
****  op relSubnet : PNet Occs Occs QidList -> PNTL3 .
****!!  omit bwd collect if there are no goals!
  eq relSubnet(pnet(pntl,ioccs),goals,avoids,rids) =
          relSubnet(pntl,ioccs,goals,avoids,rids) .
  ceq relSubnet(pntl,ioccs,goals,avoids,rids) =
              {fpntl,ioccs',unused,used}
  if  pntl' := avoidOccs(omitRules(pntl,rids),avoids)
  /\  bpntl := (if goals == none then pntl' else bwdCollect(pntl',goals) fi)
  /\ {fpntl,ioccs',unused,used} := 
               fwdCollect(bpntl,Odiff(ioccs, avoids)) .

endm



mod QQQ is
  inc QQ .
  inc SIMPLE .
  inc  DISH-OPS .
  inc PETRI .
  inc RELEVANT-SUBNET .
endm

**** loadmaude loaded meta-petri.maude
***(
in pl-print -- thT,locT extracted from occT by reflection

)

fmod META-PETRI is
  inc MY-META-ALL .

*** meta syntax for petri nets, pntrans, occs

  var  occT : Term .       **** '<_`,_>[thT,locT]
  var  occTL : TermList .  **** list of occTs
  var  neOccTL : NeTermList .
  var  occsT : Term .      ****  'none.Occs, occT or '__[occT0, occT1, occTL]

  var  pntT : Term .       **** 'pnTrans[....]
  var  pntTL : TermList .  **** list of pntTs
  var  nePntTL : NeTermList .
  var  pntlT : Term .      ****  'nil.PNTransList, pntT or '__[pntT0, pntT1, pntTL]
 
  vars thT locT : Term .                  **** thing and location terms
  vars ridT ioccsT ooccsT boccsT : Term . **** pntrans args

*** generic
  var b : Bool .
  var term  t t' : Term .
  var tl : TermList .
  var mod : Module .
  var res?? : [ResultPair?] .
  var qid : Qid .
  var qidl : QidList .

**** can we assume the qidlT is normalized?
**** converting metarep of a term of sort QidList to a termlist
**** with elements that metarepresent a term of sort Qid
**** metareduce first to flatten,  also ensures t is meaningful in mod
  op qidlT2tl : Module Term -> TermList .
  ceq qidlT2tl(mod, t) =
       (if hasSort(mod,t','QidList) 
           then (if hasSort(mod,t','Qid) 
                 then t'
                 else getArgs(t')
                 fi)
           else empty fi)
  if res?? := metaReduce(mod,t) 
  /\ t' := (if res?? :: ResultPair then getTerm(res??) else 'nil.QidList fi) .


**** converting a qidlist to a termlist 
  op qidl2tl : QidList -> TermList .
  eq qidl2tl(nil) = empty .
  eq qidl2tl(qid qidl) = (mkQidConst(qid), qidl2tl(qidl)) .

**** a qidTerm list to a term
  op qidTL2qidlT : TermList -> Term .
  eq qidTL2qidlT(empty) = 'nil.QidList .
  eq qidTL2qidlT(t) =  t .
  eq qidTL2qidlT((t,tl)) = '__[t,tl] .

  op qidl2qidlT : QidList -> Term .
  eq qidl2qidlT(qidl) = qidTL2qidlT(qidl2tl(qidl)) .



**** occ terms
  op mkOccT : Term Term -> Term .
  op isOccT : Term -> Bool .
  ops occT2thT occT2locT : Term -> TermList .   *** empty if arg not an occT
  op occTL2occTL : TermList -> TermList . **** flattens
  eq mkOccT(thT,locT) = '<_`,_>[thT,locT] .
  eq isOccT('<_`,_>[thT,locT]) = true .
  eq isOccT(term) = false [owise] .
  eq occT2thT('<_`,_>[thT,locT]) = thT .
  eq occT2thT(term) = empty [owise] .
  eq occT2locT('<_`,_>[thT,locT]) = locT .        
  eq occT2locT(term) = empty [owise] .

  op occTL2occsT : TermList -> Term .
  op occsT2occTL : Term -> TermList .
  op normalizeOccTL : TermList TermList Bool -> TermList .  **** flatten

**** assumes terms are Occ terms
  eq occTL2occsT(empty) = 'none.Occs .
  eq occTL2occsT(occT) = occT .
  eq occTL2occsT(neOccTL) = '__[neOccTL] .  **** could flatten tl

  eq occsT2occTL('none.Occs) = empty .
  eq occsT2occTL('__[occTL]) = occTL2occTL(occTL) .   **** flatten 
  eq occsT2occTL(term) = (if isOccT(term) then term else empty fi) [owise] .

  eq occTL2occTL(empty) = empty .
  eq occTL2occTL((occT,occTL)) = (occsT2occTL(occT), occTL2occTL(occTL)) .

  eq normalizeOccTL(empty,occTL,b) = 
       (if b then normalizeOccTL(occTL,empty,false) else occTL fi)  .
  eq normalizeOccTL((term,tl),occTL, b) =
       normalizeOccTL(tl,(occTL, occsT2occTL(term)),  
                       (if isOccT(term) then b else true fi)) .

  op occTLconc : TermList Term -> TermList .
  eq occTLconc(tl,term) = (if isOccT(term) then (tl,term) else tl fi) .

**** pnt terms
  op mkPntT : Term Term Term Term -> Term .
  op isPntT : Term -> Bool .
  ops pntT2ridT pntT2ioccsT pntT2ooccsT pntT2boccsT : Term -> TermList . 
                       *** empty if arg not a pntT
  op pntTL2pntTL : TermList -> TermList .

  eq mkPntT(ridT,ioccsT,ooccsT,boccsT) = 'pnTrans[ridT,ioccsT,ooccsT,boccsT] .
  eq isPntT('pnTrans[ridT,ioccsT,ooccsT,boccsT]) = true .
  eq isPntT(term) = false [owise] .
  eq pntT2ridT('pnTrans[ridT,ioccsT,ooccsT,boccsT]) = ridT .
  eq pntT2ridT(term) = empty [owise] .
  eq pntT2ioccsT('pnTrans[ridT,ioccsT,ooccsT,boccsT]) = ioccsT .
  eq pntT2ioccsT(term) = empty [owise] .
  eq pntT2ooccsT('pnTrans[ridT,ioccsT,ooccsT,boccsT]) = ooccsT .
  eq pntT2ooccsT(term) = empty [owise] .
  eq pntT2boccsT('pnTrans[ridT,ioccsT,ooccsT,boccsT]) = boccsT .
  eq pntT2boccsT(term) = empty [owise] .

  op pntTL2pntlT : TermList -> Term .
  op pntlT2pntTL : Term -> TermList .
  op normalizePntTL : TermList TermList Bool -> TermList .  **** flatten

  eq pntTL2pntlT(empty) = 'nil.PNTransList .
  eq pntTL2pntlT(pntT) = pntT .
  eq pntTL2pntlT(nePntTL) = '__[nePntTL] .  **** could flatten tl

  eq pntlT2pntTL('nil.PNTransList) = empty .
  eq pntlT2pntTL('__[pntTL]) = pntTL2pntTL(pntTL) .   **** flatten 
  eq pntlT2pntTL(term) = (if isPntT(term) then term else empty fi) [owise] .

  eq pntTL2pntTL(empty) = empty .
  eq pntTL2pntTL((pntT,pntTL)) = (pntlT2pntTL(pntT), pntTL2pntTL(pntTL)) .

  eq normalizePntTL(empty,pntTL,b) = 
       (if b then normalizePntTL(pntTL,empty,false) else pntTL fi)  .
  eq normalizePntTL((term,tl),pntTL,b) =
       normalizePntTL(tl,(pntTL, pntlT2pntTL(term)),  
                       (if isPntT(term) then b else true fi)) .

  op pntTLconc : TermList Term -> TermList .
  eq pntTLconc(tl,term) = (if isPntT(term) then (tl,term) else tl fi) .

**** pnet terms
  op mkPnT : Term Term -> Term .
  op isPnT : Term -> Bool .
  op pnT2pntlT : Term -> Term .
  op pnT2occsT : Term -> Term .

  eq mkPnT(pntlT,occsT) = 'pnet[pntlT,occsT] .
  eq isPnT('pnet[pntlT,occsT]) = true .
  eq isPnT(term) = false [owise] .
  eq pnT2pntlT('pnet[pntlT,occsT]) = pntlT .
  eq pnT2pntlT(empty) = empty [owise] . 
  eq pnT2occsT('pnet[pntlT,occsT]) = occsT .
  eq pnT2occsT(empty) = empty [owise] . 

  op metaGetTrans : TermList Term  -> TermList .
  eq metaGetTrans(empty,ridT) = empty .
  eq metaGetTrans((pntT,pntTL),ridT) =
      (if pntT2ridT(pntT) == ridT then pntT else metaGetTrans(pntTL,ridT) fi) .

**** phase out was in aux-eset
**** meta pnet ops
  ops pnetT2pntlT pnetT2occsT : Term -> Term .
  eq  pnetT2pntlT('pnet[pntlT,occsT]) = pntlT .
  eq  pnetT2pntlT(t) = 'nil.PNTransList [owise] .

  eq  pnetT2occsT('pnet[pntlT,occsT]) = occsT .
  eq  pnetT2occsT(t) = 'none.Occs [owise] .

endfm



fmod TEST-META-PETRI is
  inc META-PETRI .

  ops thT1 thT2 locT1 locT2 : -> Term .
  ops occT1 occT2 : -> Term .

  eq occT1 = mkOccT(thT1,locT1)  .
  eq occT2 = mkOccT(thT2,locT2)  .

  op occsT0 : ->  Term .
  eq occsT0 = occTL2occsT((occT1,occT2)) .

  ops pntT0 pntT1 : -> Term .
  eq pntT0 = mkPntT(mkQidConst('123),occT1,occT2,'none.Occs) .
  eq pntT1 = mkPntT(mkQidConst('321),occT2,occT1,'none.Occs) .

  op pntlT0 : -> Term . 
  eq pntlT0 =  pntTL2pntlT((pntT0,pntT1)) .        

  op pnT0 : -> Term .
  eq pnT0 = mkPnT(pntlT0,occsT0) .

***(
red  isOccT(occT1) .
red  occT2thT(occT1) .
red  occT2locT(occT1) .
red  occT2thT(thT1) .
red  occT2locT(thT1) .

red occsT2occTL(occsT0) .
red occTL2occsT(empty) .
red occTL2occsT(occT1) .

red isPntT(pntT0) .
red pntT2ridT(pntT0) .
red pntT2ridT(occT2) .
red pntT2ioccsT(pntT0) .
red pntT2ooccsT(pntT0) .
red pntT2boccsT(pntT0) .

red pntlT2pntTL(pntlT0) .

red pnT2pntlT(pnT0) .
red pnT2occsT(pnT0) .

red normalizeOccTL((occsT0, occT1, 'none.Occs),empty,false) .
red normalizePntTL((pntT0, pntlT0, 'nil.PNTransList),empty,false) .

red pntTLconc(pntT1,pntT0) .
red pntTLconc(pntT1,'nil.PNTransList) .

red occTLconc(occT2,occT1) .
red occTLconc(occT2,'none.Occs) .

)



endfm

**** loadmaude loaded pl2tlt.maude

fmod PL2TLT is
  inc MY-META-ALL .
  inc META-PETRI .
**** assume PL + PETRI loaded

  vars lhs rhs t t' ioccsT ooccsT pntlT  ridT preOccsT postOccsT : Term .
  vars tl vals : TermList .
  var mod : Module .
  var v : Variable . var const : Constant . 
  var vs  : QidSet .
  vars sbs sbs' : SubstSet .
  var subst : Substitution .
  var cond : Condition .
  var rule : Rule .
  var rules : RuleSet .
  var attrs : AttrSet .
  var rid  qid modname : Qid .
  var vset : QidSet .
  var sortset : SortSet .  
  var n : Nat .
  var b : Bool .
  var res?? : [ResultPair?] .

  sort SubstSet .
  op sb : Substitution -> SubstSet  [ctor] .
  op mt : -> SubstSet [ctor] .
  op __ :  SubstSet SubstSet -> SubstSet [ctor assoc comm id: mt] .
  eq sb(subst) sb(subst) = sb(subst) .

****************** op decls ***********************

**** map pl ruleset to PNTransList term 
**** pnTrans(rid,ioccs,ooccs,bokkc)
  ops pl2tlt  : Qid -> Term . ****

**** map set of pl rules to PNTransList term .
  ops plrules2tlt  : Module RuleSet -> Term . 

**** occs version of rules
  op plrules2orules : Module RuleSet -> RuleSet .
  op plrule2orule : Module Rule -> RuleSet .        **** 0 or 1 

**** PL rule condition has form thingVar soupVar := groundThingSoup
**** finds thing variable in PL rule condition
  op thingVar : Module TermList -> Qid .    
**** instance substs for PL rule condition
  op cond2sbs : Module Condition -> SubstSet .
  op cond2sbsX : Module Qid TermList -> SubstSet .

**** List of constants having one of given sorts
**** replace consSetBySort that returns a QidSet
  op constListBySort : OpDeclSet  SortSet  -> TermList .
  op constBySortZ : OpDecl  SortSet  -> TermList .

**** all instances given by condition for  PL conditional rule 
  op expandCond : Module Term Term Qid AttrSet SubstSet Nat -> RuleSet .

****  finds all substitutions for a set of variables
  op allInst : Module QidSet SubstSet -> SubstSet .
  op extendSbS : SubstSet Variable TermList -> SubstSet .
  op extendSbSX : SubstSet Variable Constant SubstSet -> SubstSet .

**** generates instances of orules
  op orules2pntl : Module RuleSet -> TermList .
  op orule2pntl : Module Rule -> TermList .
  op orule2pntlX : Module Term Term  Qid SubstSet Nat -> TermList .
  op orule2pnt : Module Term Term  Qid Substitution Nat -> TermList .

  op mkTransId : Qid Nat -> Qid .

****************** end op decls ***********************

**** basic in PL modules converting soup term to its 
  op soupT2tl : Module Term -> TermList .
  ceq soupT2tl(mod,t) =
       (if hasSort(mod,t','Soup)
        then (if (hasSort(mod,t','Thing)
                  or hasSort(mod,t','Location)
                  or hasSort(mod,t','Cell))
              then t'
              else (if getOp(t') == '__
                    then getArgs(t')
                    else empty fi)
               fi)
        else empty
        fi) 
    if res?? := metaReduce(mod,t)
    /\ t' := (if res?? :: ResultPair then getTerm(res??) else 'empty.Soup fi) .
    

**** mod must extend DISH-OPS
  op plT2occsT : Module Term -> Term .
  eq plT2occsT(mod,t) =
       (if metaReduce(mod,'pl2occs[t]) :: ResultPair 
        then getTerm(metaReduce(mod,'pl2occs[t])) 
        else 'none.Occs fi) .
  
**** map pl ruleset to PNTransList term .
****  ops pl2tlt  : Qid -> Term . ****
  eq pl2tlt(modname) = plrules2tlt([modname],upRls(modname,true)) .
***  eq pl2txlt(modname) = plrules2txlt([modname],upRls(modname,true)) .

**** map set of pl rules to PNTransList term .
****  ops plrules2tlt plrules2txlt : Module RuleSet -> Term . ****
***(  ceq plrules2txlt(mod,rules) =
     (if res?? :: ResultPair then getTerm(res??) else 'nil.PNTransList fi)
  if pntlT := plrules2tlt(mod,rules) 
  /\ res?? := metaReduce(mod,'pntl2pntxl[pntlT]) .
)
  eq plrules2tlt(mod,rules) =
       pntTL2pntlT(orules2pntl(mod, plrules2orules(mod,rules))) .

**** occs version of rules
****  op plrules2orules : Module RuleSet -> RuleSet .
****  op plrule2orule : Module Rule -> RuleSet .        **** 0 or 1 

  eq plrules2orules(mod,none) = none .
  eq plrules2orules(mod,rule rules) = 
        plrule2orule(mod,rule) plrules2orules(mod, rules) .

  ceq plrule2orule(mod,rl lhs => rhs [ attrs ] .) =
      (if ioccsT == 'none.Occs or ooccsT == 'none.Occs
       then none
       else  (rl ioccsT => ooccsT [ attrs ] .)
       fi)
     if ioccsT := plT2occsT(mod,lhs)
     /\ ooccsT := plT2occsT(mod,rhs) .
 
**** assumes conditions have the form thingvar soupvar := gs 
**** where thingvar occurs on lhs and gs is a group soup of things
**** Example: ?Bmp:Bmp S:Soup := Bmp2 Bmp4 Bmp7
  ceq plrule2orule(mod, (crl lhs => rhs if cond [ label(rid) attrs ] .)) =
      (if ioccsT == 'none.Occs or ooccsT == 'none.Occs
       then none
       else expandCond(mod, ioccsT, ooccsT,rid,attrs,sbs,0)
       fi)
     if ioccsT := plT2occsT(mod,lhs)
     /\ ooccsT := plT2occsT(mod,rhs) 
     /\ sbs := cond2sbs(mod,cond) .

****  op thingVar : Module TermList -> Qid .
  eq thingVar(mod,empty) = 'nonVariable .
  eq thingVar(mod,(t,tl)) =
     (if hasSort(mod,t,'Thing) :: Bool
      then (if hasSort(mod,t,'Thing) 
            then t
            else thingVar(mod,tl)
            fi)
      else 'nonVariable fi) .


****  op cond2sbs : Module Condition -> SubstSet .
****  op cond2sbsX : Module Qid TermList -> SubstSet .
  eq cond2sbs(mod,lhs := rhs) =
      (if thingVar(mod, soupT2tl(mod,lhs)) :: Variable
       then cond2sbsX(mod,thingVar(mod, soupT2tl(mod,lhs)), soupT2tl(mod,rhs)) 
       else mt fi) .
  eq cond2sbs(mod,cond) = mt [owise] .

  eq cond2sbsX(mod,v,empty) = mt .
  eq cond2sbsX(mod,v,(t,tl)) = (sb(v <- t) cond2sbsX(mod,v,tl)) .

**** op expandCond : Module Term Term Qid AttrSet SubstSet Nat -> RuleSet .
 eq expandCond(mod,ioccsT,ooccsT,rid, attrs,mt,n) = none .
 eq expandCond(mod,ioccsT,ooccsT,rid, attrs, sb(subst) sbs,n) =
      (rl substApp(subst,ioccsT) => substApp(subst,ooccsT) 
          [label(mkTransId(rid,n)) attrs] .)
     expandCond(mod,ioccsT,ooccsT,rid, attrs,sbs, s n) .

**** Given a set of variables, find all instances
****  op allInst : Module QidSet SubstSet -> SubstSet .
  eq allInst(mod,none, sbs) = sbs .
  ceq allInst(mod,v ; vs, sbs) = allInst(mod,vs,sbs')
***    if vals := constListBySort(upOpDecls('PROTEINOPS,true),  ****!!!!false
       if vals := constListBySort(upOpDecls(getName(mod),true),  ****!!!!false
                                (lesserSorts(mod,getType(v)) ; getType(v))) 
       /\ sbs' := extendSbS(sbs,v,vals) .
 *** skip non Var
  eq allInst(mod,qid ; vs, sbs) = allInst(mod,vs,sbs)  [owise] . 


****  op constListBySort : OpDeclSet  SortSet  -> TermList .
****  op constBySortZ : OpDecl  SortSet  -> TermList .
  eq constListBySort(none, sortset)  = empty .
  eq constListBySort(od:OpDecl ods:OpDeclSet, sortset) = 
       (constBySortZ(od:OpDecl, sortset) ,
       constListBySort(ods:OpDeclSet, sortset)) .

  eq constBySortZ((op qid : tl:TypeList -> t:Type [atts:AttrSet] .),
                   sortset) 
      = if ((tl:TypeList == nil) and (t:Type in sortset))
        then mkConst(qid,t:Type)
        else empty
        fi .

****  op extendSbS : SubstSet Variable TermList -> SubstSet .
****  op extendSbSX : SubstSet Variable Constant SubstSet -> SubstSet .

  eq extendSbS(sbs,v,empty) = mt .
  eq extendSbS(sbs,v, (const, vals)) = 
        extendSbSX(sbs,v,const, mt)  extendSbS(sbs,v,vals) .
  **** skip nonval
  eq extendSbS(sbs,v, (qid , vals)) = extendSbS(sbs,v,vals) [owise] . 

  eq extendSbSX(mt,v, const,sbs) = sbs .
  eq extendSbSX(sb(subst) sbs,v, const, sbs') = 
       extendSbSX(sbs,v,const, sbs' sb(subst ; v <- const)) .

****  op orules2pntl : Module RuleSet -> TermList .
****  op orule2pntl : Module Rule -> TermList .
****  op orule2pntlX : Module Term Term  Qid SubstSet Nat -> TermList .
****  op orule2pnt : Module Term Term  Qid Substitution Nat -> TermList .

  eq orules2pntl(mod,none) = empty .
  eq orules2pntl(mod,rule rules) = 
      orule2pntl(mod,rule) , orules2pntl(mod,rules) .

**** conditions have been eliminated from PL rules
  eq orule2pntl(mod,rl lhs => rhs [ label(rid) attrs ] .) = 
    orule2pntlX(mod,lhs,rhs,rid,allInst(mod,getVars(lhs),sb(none)),0) . 
**** ; getVars(getRhs(rule)) no need to get vars of rhs RIGHT??

  eq orule2pntlX(mod,lhs,rhs,rid,mt,n) = empty .
  eq orule2pntlX(mod,lhs,rhs,rid,sb(subst) sbs,n) =
      orule2pnt(mod,lhs,rhs,rid,subst,n),
      orule2pntlX(mod,lhs,rhs,rid,sbs,s n) .

  ceq orule2pnt(mod,lhs,rhs,rid,subst,n) = 
      (if res?? :: ResultPair then getTerm(res??) else empty fi)
    if ridT := mkQidConst(mkTransId(rid,n))
    /\ preOccsT := substApp(subst,lhs)
    /\ postOccsT := substApp(subst,rhs)
    /\ res?? := metaReduce(mod,'mkPNTrans[ridT,preOccsT,postOccsT]) .

****  op mkTransId : Qid Nat -> Qid .
  eq mkTransId(rid,0) = rid .
  eq mkTransId(rid,s n) = qid(string(rid) + "#" + string(s n,10)) .


endfm
**** loadmaude loaded pl-print.maude
fmod PL-PRINT is
  inc MY-META-ALL .
  inc STRING .
  inc CONVERSION .
  inc META-PETRI .

****************************     opdecls     **************************** 
**** printing rule ids
*** print  up to first dot in ddd, or all if no dot
  op printRid : Qid -> String .

**** ridT has form ''ddd.Qid  maybe ddd has no dot
*** print  up to first dot in ddd, or all if no dot
*** if PNRidSuffix occurs, then what follows is rule instance index n
*** add -n to printed id
  op printRidT : Term -> String .

**** print the full id (just drop the single quote)
  op printRidTAll : Term -> String .

**** applies printRidTall to each term in the list (with blank separator)
  op printRidTL : TermList -> String .

**** printing an occ termlist, space separated, full occ name (occ2label)
  op printOccTL : Module TermList -> String .

**** prints occ as  thing - loc
  op occ2label : Module Term -> String .
**** prints occ without loc
  op occ2labelx : Module Term -> String .

**** prints location name -- assume constants, ow print as "?"
  op printLoc : Module Term -> String .

******** printing things
  op printThing : Module Term -> String .

**** separator for rule instance count, currently #
  op PNRidSuffix : -> String .

****************************   end opdecls    **************************** 
  vars rid : Qid .
  vars rn prn sfx : String .
  vars res res1 : FindResult .
  vars ridT locnameT strT thC : Constant .
  var thV : Variable .
  var mod : Module .
  vars occT thT lT pT msT t thT0 thT1 thT2 tsoupT : Term .
  var occTL tl : TermList .
  vars res?? res0?? res1?? : [ResultPair?] .

**** printing rule ids
**** print  up to first dot in ddd, or all if no dot
****  op printRid : Qid -> String .
  eq printRid(rid) =
       (if (find(string(rid) , ".",0) :: Nat) 
        then substr(string(rid) ,0,find(string(rid) , ".",0))  
        else string(rid) fi) .

****  op PNRidSuffix : -> String .
  eq PNRidSuffix = "#" .

**** ridT has form ''ddd.Qid  maybe ddd has no dot
**** print  up to first dot in ddd, or all if no dot
**** if PNRidSuffix occurs, then what follows is rule instance index n
**** add -n to printed id
****  op printRidT : Term -> String .
  ceq printRidT(ridT) =
       prn + sfx     
  if rn := string(getName(ridT)) 
  /\ res := find(rn, ".", 0) 
  /\ prn := substr(rn, 1, 
                   ( if res :: NzNat then sd(res,1) else length(rn) fi))
  /\ res1 := rfind(rn, PNRidSuffix, length(rn)) 
  /\ sfx := (if res1 :: Nat
             then "-" + substr(rn,s res1, length(rn)) 
             else "" fi) .

**** print the full id (just drop the single quote)
****  op printRidTAll : Term -> String .
  eq printRidTAll(ridT) = 
       substr(string(getName(ridT)), 1,length(string(getName(ridT)))) .

****  op printRidTL : TermList -> String .
  eq printRidTL(empty) = "" .
  eq printRidTL((ridT, tl)) = printRidTAll(ridT) + " " + printRidTL(tl) .

*** turning occs into strings
*** module must include DISH-OPS  (define Occ, Loc)

****  op printOccTL : Module TermList -> String .
  eq printOccTL(mod,empty) = "" .
  eq printOccTL(mod,(occT,occTL)) = 
       occ2label(mod,occT) + " " + printOccTL(mod,occTL) .

**** prints occ as  thing - loc
****  op occ2label : Module Term -> String .
  eq occ2label(mod, occT) =
      (if isOccT(occT)
       then printThing(mod,occT2thT(occT))  
                       + "-" +  printLoc(mod, occT2locT(occT)) 
       else "" fi) .

**** prints occ without loc
****  op occ2labelx : Module Term -> String .
  eq occ2labelx(mod, occT) =
        (if isOccT(occT) then printThing(mod,occT2thT(occT)) else "" fi) .

**** prints location name -- assume constants, ow print as "?"
****  op printLoc : Module Term -> String .

  eq printLoc(mod,'newL[strT]) =  stringT2String(strT) .
  eq printLoc(mod,locnameT) =  string(getName(locnameT)) .
  eq printLoc(mod,lT) = "?" [owise]  .

**** printing things
**** ops printThing  : Module Term -> String .
  ops printComplex printModified printModSet : Module Term -> String .
  op printModList : Module TermList -> String .

 eq printThing(mod,thC) = string(getName(thC)) .
 eq printThing(mod,thV) = "?" + string(getType(thV)) .
**** eq printThing(mod,'_:_[thT1,thT2]) = 
****      "(" + printThing(mod,thT1) + ":" + printThing(mod,thT2) + ")" . 
**** allow for assoc 
**** 07apr08 drop parens -- makes sending chattylabels to maude weird
**** eq printThing(mod,'_:_[tl]) = "(" + printThingSoupL(mod,tl) + ")" . 
 eq printThing(mod,'_:_[tl]) =  printThingSoupL(mod,tl)  . 

 eq printThing(mod,'<_>[tsoupT]) =  "<" + printTSoup(mod,tsoupT) + ">" .
 eq printThing(mod,'`[_-_`][pT,msT]) = 
      printThing(mod,pT) + "-" + printModSet(mod,msT) .
 eq printThing(mod,'newC[strT]) = stringT2String(strT) .

eq printThing(mod,thT) = "???" +
   (if metaPrettyPrint(mod,thT) :: QidList
   then qidl2strx(metaPrettyPrint(mod,thT))
   else "*" fi)    [owise] .

  op qidl2strx : QidList -> String .
  eq qidl2strx(nil) = "" .
  eq qidl2strx(q:Qid) = string(q:Qid) .
  eq qidl2strx(q:Qid q':Qid ql:QidList) = 
         string(q:Qid) + "%" + qidl2strx(q':Qid ql:QidList) .


***!!! NEWCOMPLEX

  op printTSoup : Module Term -> String .
  op printThingL : Module TermList -> String .
  op printThingSoupL : Module TermList -> String .

****  eq printComplex(mod,'<_>[tsoupT]) = "<" + printTSoup(mod,tsoupT) + ">" .
****  assume tsoupT is soup of things possibly not normalized
  eq printTSoup(mod,tsoupT) =
      (if tsoupT == 'empty.Soup
       then " "
       else (if getOp(tsoupT) =/= '__ **** hasSort(mod,tsoupT,'Thing)
             then printThing(mod,tsoupT)
             else printThingSoupL(mod,getArgs(tsoupT))
             fi)
       fi) .

****  eq printTSoup(mod,tsoupT) = "" [owise] .  **** just in case

**** terms are things or thing soups
  eq printThingSoupL(mod, empty) = "" .
  eq printThingSoupL(mod, (t, tl)) = 
        (if getOp(t) == '__    **** a soup
         then printThingSoupL(mod,getArgs(t)) 
         else printThing(mod,t)
         fi) 
        + (if tl == empty then "" else ":" + printThingSoupL(mod,tl) fi) .


  eq printThingL(mod, empty) = "" .
  eq printThingL(mod, (thT, tl)) = 
        (if  hasSort(mod,thT,'Thing)
         then printThing(mod,thT)
         else printThingL(mod,getArgs(thT)) fi) 
        + (if tl == empty then "" else ":" + printThingL(mod,tl) fi) .

****!!! END NEWCOMPLEX

****  eq printModified(mod,'`[_-_`][pT,msT]) = 
****       printThing(mod,pT) + "-" + printModSet(mod,msT) + "" .

***(
Modification is
  constant
  op[site]
site is '__[aa,n]
)

  eq  printModSet(mod,m:Constant) = string(getName(m:Constant)) .
  eq  printModSet(mod,op:Qid[tl]) =
        (if (op:Qid == '__)
         then printModList(mod,tl) 
***        else (if (tl :: Constant)
***              then string(op:Qid) + "(" + string(getName(tl)) + ")"
***              else "" fi)
***      else printOpTerm(op:Qid, tl)
         else (if (op:Qid == 'num)
               then "num" + "(" + printNat(first(tl)) + ")" 
               else printSiteMod(op:Qid, tl)
          fi) fi) .

  op printSiteMod : Qid TermList -> String .
  eq printSiteMod(op:Qid, t) =
      string(op:Qid) + "-" + printSite(t) .

  op printSite : Term -> String .
  eq printSite(c:Constant) = string(getName(c:Constant)) .
  eq printSite('__[c:Constant,nT:Term]) =
        string(getName(c:Constant)) + printNat(nT:Term).

  op printNat : Term -> String .
  eq printNat(t) = string(downTerm(t,0),10) .

**** Not used ??
  op printOpTerm : Qid TermList -> String .
  op printTerm : Term -> String .
  op printTermList : TermList -> String .

  eq printOpTerm(op:Qid, tl) = 
       string(op:Qid) + "(" + printTermList(tl) + ")" .

  eq printTerm(t) =
        (if (t :: Variable) 
         then "?" + string(getName(t))
         else (if (t :: Constant)
               then  string(getName(t))
               else printOpTerm(getOp(t),getArgs(t))
               fi ) fi ) .

  eq printTermList(empty) =  "" .
                
  eq printTermList((t,tl)) =
      printTerm(t) + (if tl == empty then "" else "," + printTermList(tl) fi) . 

  eq  printModList(mod,empty) = "" .
  eq  printModList(mod,(t, tl)) =
        printModSet(mod,t) +  
          (if tl == empty then "" else " " + printModList(mod,tl) fi) .

  op stringT2String : Term -> String .
  eq stringT2String(t) = 
     if (t :: Constant) and getType(t) == 'String
     then substr(string(getName(t)),1,sd(length(string(getName(t))),2))
     else "" fi .

endfm


**** loadmaude loaded pntl2graph.maude
**** generates graph (with mt title and notes) from a PNTransList
**** if parent node set is given, use that to get node ids, ow generate


fmod PNTL2GRAPH is
  inc GRAPH .
  inc META-PETRI .
  inc PL-PRINT .
  inc QVAL .  inc SVAL .  inc TVAL .   **** note values
  inc NAT-QID .

************************      opdecls         ************************ 
**** TermList is list of pnet transitions (meta represented)
  op pntl2graph : Module TermList NodeList -> Graph .  
  op pntl2graph : Qid TermList NodeList -> Graph .  

**** pntl2g0 processes transitions one at a time 
****         modname pntTL    new     new      next  parent
  op pntl2g0 : Qid TermList NodeList EdgeList Nat NodeList -> Graph .

**** pntl2g1 processing  trans given by terms
****        modname ridT ioccsT ooccsT boccsT   pntTL
  op pntl2g1 : Qid Term Term   Term   Term    TermList 
              NodeList EdgeList Nat NodeList -> Graph .


**** get occ nodes for list of occ terms,
**** returns updated nodelist, ids of occ nodes, and next occ id nat
****           modname  occTL   found    next found  parent
  op getONodes : Qid TermList NodeList Nat NatList NodeList -> getNodesResult .
  op getONode : Qid Term NodeList Nat NodeList -> getNodesResult .

****                                            pre     post
  op getRNode : Qid Term NodeList Nat NodeList NatList NatList -> getNodesResult .

**** make Occ or Rule node with atts computed from occ or rule id term
  op mkONode : Qid Term Nat -> Node .
  op mkRNode : Qid Term Nat String String -> Node .

**** making incoming, outgoing and bidir edges, with empty notes
  ops mkIedges mkOedges mkBedges : NatList Nat EdgeList -> EdgeList .

************************    end opdecls        ************************ 

  vars t ridT ioccsT ooccsT boccsT pntlT preT postT thT locT : Term .
  vars pntTL tl : TermList .
  vars res0?? res1?? res2?? : [ResultPair?] .
  var mod : Module .
  var modname : Qid .
  vars ndl ndl' indl ondl bndl rndl pndl node? : NodeList .
  var nendl : NeNodeList .
  vars edl iedl oedl bedl : EdgeList .
  vars n n' id n0 n1 n2 n3 : Nat .
  vars ids inl onl bnl rnl : NatList .
  var id? : FindResult .
  vars thStr locStr inlStr onlStr : String .

**** trying more efficient flattening of occs term
  eq pntl2graph(mod,pntTL,pndl) = pntl2g0(getName(mod),pntTL,nil,nil,0,pndl) .
  eq pntl2graph(modname,pntTL,pndl) = pntl2g0(modname,pntTL,nil,nil,0,pndl) .
  eq pntl2g0(modname,empty,ndl,edl,n,pndl) = graph("",mt,ndl,edl) .
  eq pntl2g0(modname,('pnTrans[ridT,ioccsT,ooccsT,boccsT], pntTL), 
                  ndl,edl,n,pndl) = 
      pntl2g1(modname,ridT,ioccsT,ooccsT,boccsT,pntTL,ndl,edl,n,pndl) .

  ceq  pntl2g1(modname,ridT,ioccsT,ooccsT,boccsT,pntTL,ndl,edl,n,pndl) =
      pntl2g0(modname,pntTL, rndl,bedl,n3,pndl)
  if {{indl,n0},inl} := getONodes(modname,occsT2occTL(ioccsT),ndl,n,(nil).NatList,
                                  pndl)
  /\ {{ondl,n1},onl} := getONodes(modname,occsT2occTL(ooccsT),indl,n0,
                                   (nil).NatList, pndl)
  /\ {{bndl,n2},bnl} := getONodes(modname,occsT2occTL(boccsT),ondl,n1,
                                   (nil).NatList, pndl)
  /\ {{rndl,n3},rnl} := getRNode(modname,ridT,bndl,n2,pndl, inl bnl, onl bnl)
  /\ iedl := mkIedges(inl,rnl,edl)
  /\ oedl := mkOedges(onl,rnl,iedl)
  /\ bedl := mkBedges(bnl,rnl,oedl)
.

****  op getONodes : Qid TermList NodeList Nat NatList NodeList 
****                 -> getNodesResult .
****  op getRNode : Qid Term NodeList Nat NodeList NatList NatList -
****                     > getNodesResult .
****  op mkONode : Qid Term Nat -> Node .
****  op mkRNode : Qid Term Nat -> Node .

  eq getONodes(modname,empty,ndl,n,ids,pndl) = {{ndl,n},ids} .
  ceq getONodes(modname,(t,tl),ndl,n,ids,pndl) =
        getONodes(modname,tl,ndl',n',(ids id),pndl) 
  if {{ndl',n'},id} := getONode(modname,t,ndl,n,pndl) .

  ceq getONode(modname,t,ndl,n,nendl) =
      (if node? :: Node
       then (if getNode(ndl,id?) :: Node
             then {{ndl,n}, id?}   *** already in graph
             else {{ndl node?,n},id?}
             fi)
        else {{ndl,n}, (nil).NatList}  **** shouldn't happen
        fi)
  if node? := getNode(nendl, "occ", tm(modname,t) )
  /\ id? := (if node? :: Node then nodeId(node?) else notFound fi)  .

  ceq getONode(modname,t,ndl,n,nil) =
     (if id? :: Nat
      then {{ndl,n}, id?}
      else {{ndl mkONode(modname,t,n), s n}, n}
      fi)        
  if id? := findNode(ndl, "occ", tm(modname,t) ) .

  eq mkONode(modname,t,n) =
      nd(n,
        (("type" := sv("occ")),
         ("occ" := tm(modname,t)),
         (if isOccT(t)
          then (("label" :=  sv(printThing([modname],occT2thT(t)))),
                ("loc" :=  sv(printLoc([modname],occT2locT(t)))),
                ("chattylabel" := sv(printThing([modname],occT2thT(t))
                                     + "-" + printLoc([modname],occT2locT(t)))) )
          else (("label" := sv("???")),
                ("loc" := sv("???")),
                ("chattylabel" := sv("???" + "-" + "???")) )
          fi) 
         )) .

****  op getRNode : Module Term NodeList Nat NodeList NatList NatList 
****                -> getNodesResult .
  ceq getRNode(modname,ridT,ndl,n,nendl,inl,onl) =
      (if node? :: Node
       then (if getNode(ndl,id?) :: Node
             then {{ndl,n}, id?}   *** already in graph
             else {{ndl node?, n},id?}
             fi)
        else {{ndl,n}, (nil).NatList}  **** shouldn't happen
        fi)
  if node? := getNode(nendl, "rule", tm(modname, ridT) ) 
  /\ id? := (if node? :: Node then nodeId(node?) else notFound fi)  .

  ceq getRNode(modname,ridT,ndl,n,nil,inl,onl) =
     (if id? :: Nat
      then {{ndl,n}, id?}
      else {{ndl mkRNode(modname,ridT,n,natl2str(inl),natl2str(onl)), s n}, n}
      fi)        
  if id? := findNode(ndl, "rule", tm(modname, ridT)) .

**** pre/post
  eq mkRNode(modname,ridT,n,inlStr,onlStr) =
      nd(n,
        (("type" := sv("rule")),
         ("label" := sv(printRidT(ridT))),
         ("chattylabel" := sv(printRidTAll(ridT))),
         ("rule" := tm(modname, ridT)),
         ("pre" := sv(inlStr)),
         ("post" := sv(onlStr)) ) ) .

  eq mkIedges(nil,n,edl) =  edl .
  eq mkIedges(n' inl,n,edl) =
         mkIedges(inl,n,edl ed(n',n,("type" := sv("unidir")))) .
****  eq mkIedges(inl,rnl,edl) = edl [owise] .

  eq mkOedges(nil,n,edl) =  edl .
  eq mkOedges(n' onl,n,edl) = 
        mkOedges(onl,n,edl ed(n,n',("type" := sv("unidir")))) .
****  eq mkOedges(onl,rnl,edl) = edl [owise] .

  eq mkBedges(nil,n,edl) =  edl .
  eq mkBedges(n' bnl,n,edl) = 
        mkBedges(bnl,n,edl ed(n',n, ("type" := sv("bidir")))) .
****  eq mkBedges(bnl,rnl,edl) = edl [owise] .

endfm
*** load graph2g2d

**** loadmaude loaded pl-thing2aexp.maude
***(
Converting ground thing terms GThT to array exp representation

GThT ~ Unit + Complex
Unit ~ Constant + ModT
ModT ~ '`[_-_`][GThT,MsT]
Complex ~ '_:_[GThTList] + '<_>[GThTSoupT]

MsT ~ Constant + 'num[NumeralT] + modQ[SiteT]
SiteT ~ '__[AAT,NumeralT]

)

fmod PL-THING2AEXP is
  inc MY-META-ALL .
  inc STRING .
  inc CONVERSION .
  inc META-PETRI .
  inc TEMPLATES .

  vars mop : Qid .
  vars name type base modstr aestr : String .
  vars strT thC modC aaC : Constant .
  vars thT  pT msT msT' t thT0 thT1 thT2 tsoupT : Term .
  var  tl tl' : TermList .

**** flattening complex bodies to Unit lists
  op csoupT2tl : Term -> TermList .
  op csoupTl2tl : TermList -> TermList .
  
  eq csoupT2tl('empty.Soup) = empty .
  eq csoupT2tl('__[tl]) = csoupTl2tl(tl) .
  eq csoupT2tl('_:_[tl]) = csoupTl2tl(tl) .
  eq csoupT2tl('<_>[tsoupT]) = csoupT2tl(tsoupT) .
  eq csoupT2tl(t) = t  [owise] .

  eq csoupTl2tl(empty) = empty .
  eq csoupTl2tl((t,tl)) = (csoupT2tl(t) , csoupTl2tl(tl)) .

  op mkComplexAexp : String -> String .
  eq mkComplexAexp(aestr) = 
       "(array java.lang.Object " + squote("complex") + " " + aestr + ")" .

  op mkBaseAexp : String String -> String .
  op mkModAexp : String  String -> String .

  eq mkBaseAexp(name,type) =
      "(array java.lang.Object " + squote("base") 
              + " " + squote(name) + " " + squote(type) + ")" .
****           base  modifiers
  eq mkModAexp(aestr,modstr) =
      "(array java.lang.Object " + squote("modified") 
              + " " + aestr + " " + modstr + ")" .

**** to handle malformed "occ" node "occ" attributes
  op thingTl2aexp  :  TermList -> String .
  eq thingTl2aexp(t) = thing2aexp(t) .
  eq thingTl2aexp(tl) = "(object null)"  [owise] .
  
  op thing2aexp  :  Term -> String .
  op unitT2aexp : Term -> String .
  op unitTl2aexp : TermList String -> String .

  eq thing2aexp('_:_[tl]) = mkComplexAexp(unitTl2aexp(csoupTl2tl(tl),"")) .
  eq thing2aexp('<_>[tsoupT]) = 
       mkComplexAexp(unitTl2aexp(csoupT2tl(tsoupT),"")) .
  eq thing2aexp(thT) = unitT2aexp(thT) [owise] .

  eq unitT2aexp(thC) = mkBaseAexp(string(getName(thC)),string(getType(thC))) .
  eq unitT2aexp('`[_-_`][pT,msT]) = mthing2aexp(pT,msT) .
  eq unitT2aexp(thT) = "" [owise] .

  eq unitTl2aexp(empty,aestr) = aestr .
  eq unitTl2aexp((t,tl),aestr) =  unitTl2aexp(tl,aestr + " " + unitT2aexp(t)) .  

**** normalizing nested modifier -- rare
  op mthing2aexp : Term Term -> String .
  eq mthing2aexp(thC,msT) = 
     mkModAexp( mkBaseAexp(string(getName(thC)),string(getType(thC))),
                modTl2aexp(modsT2tl(msT,empty), ""))  .
  eq mthing2aexp('`[_-_`][pT,msT'],msT) = mthing2aexp(pT, '__[msT',msT]) .
  eq mthing2aexp(thT,msT) = "" [owise] .


**** flatten modification set term to list of modifier terms
  op modsT2tl : Term TermList -> TermList .
  op modsTl2tl : TermList TermList -> TermList .

  eq modsT2tl('none.ModSet,tl) = tl .
  eq modsT2tl('__[tl'],tl) = modsTl2tl(tl',tl) .
  eq modsT2tl(t,tl) = (tl, t) [owise] .

  eq modsTl2tl((t,tl'), tl) = modsTl2tl(tl', modsT2tl(t,tl)) .
  eq modsTl2tl(empty, tl) = tl .


**** modification to aexp representation
  op modT2aexp : Term -> String .
  op modTl2aexp : TermList String -> String .

  eq  modTl2aexp(empty,modstr) = modstr .
  eq  modTl2aexp((t,tl),modstr) = modTl2aexp(tl, modstr + " " + modT2aexp(t)) .

  eq  modT2aexp(modC) =
          "(array java.lang.Object " + squote("mod") 
                   + " " + squote(string(getName(modC))) + ")" .
  eq  modT2aexp(mop[t]) =
        (if (mop == 'num)
         then "(array java.lang.Object " + squote("mod")
                     + " " + squote("num")
                     + " " + squote(string(downTerm(t,0),10)) + ")" 
         else   "(array java.lang.Object " + squote("mod")
                       + " " + squote(string(mop)) + " " + site2aexp(t) + ")" 
         fi) .
  eq  modT2aexp(t)  = "" [owise] .

  op site2aexp : Term -> String .
  eq site2aexp(aaC) = squote(string(getName(aaC))) .
  eq site2aexp('__[aaC,t]) =
       squote(string(getName(aaC))) + " " + squote(string(downTerm(t,0),10)) .
  eq site2aexp(t) = "" [owise] .

endfm


fmod TEST-PL-THING2AEXP is
  inc PL-THING2AEXP .

  ops srcB rasB pipB pipD srcP srcPP rasG : -> Term .
  ops gMod pMod sMod yMod nMod :  -> Term .
  ops cplx1 cplx2 cplx3 :  -> Term .
  ops msT csT0 csT1 :  -> Term .

  eq srcB =   'Src.Protein .
  eq rasB =   'Ras.Protein .
  eq pipB = 'PIP2.Chemical .

  eq gMod = 'GTP.Modification .
  eq pMod = 'phos.Modification .
  eq sMod =  'phos['__['S.AminoAcid, upTerm(245)]] .
  eq yMod =  'phos['__['Y.AminoAcid, upTerm(429)]] .
  eq nMod = 'num[upTerm(2)] .
  eq msT = '__[gMod, '__[yMod,'__[nMod,sMod]], '__[pMod,'none.ModSet]] .

  eq srcP = '`[_-_`][srcB,pMod] .
  eq pipD = '`[_-_`][pipB,nMod] .
  eq rasG = '`[_-_`][rasB,gMod] .

  eq srcPP = '`[_-_`][srcB,'__[yMod,sMod]] .

  eq cplx1 = '<_>['__[rasG,srcP]] .
  eq cplx2 = '_:_[rasG,srcP] .
  eq cplx3 = '_:_[cplx1,cplx2] .
  
  eq csT0 = '__[srcPP, cplx3, '_:_[cplx1,pipD]] .
  
endfm

***(

red csoupTl2tl((cplx1,cplx2)) .
red csoupT2tl(csT0)  .
red modsT2tl(yMod,empty) .
red modsT2tl(msT,empty) .
red unitT2aexp(srcB) .
red unitT2aexp(srcP) .
red unitT2aexp(srcPP) .
red unitTl2aexp((rasG, srcP), "") .

red srcB .
red thing2aexp(srcB) .
red srcP .
red thing2aexp(srcP) .
red srcPP .
red thing2aexp(srcPP) .
red pipD .
red thing2aexp(pipD) .
red cplx1 .
red thing2aexp(cplx1) .
red cplx2 .
red thing2aexp(cplx2) .
red cplx3 .
red thing2aexp(cplx3) .
q
)
**** loadmaude loaded newgraph2g2d.maude
fmod NEW-GRAPH2G2D is
  inc GRAPH .
  inc NAT-QID .
  inc TEMPLATES .
  inc QVAL .  inc SVAL .  inc TVAL .   **** note values
  inc PL-THING2AEXP .
  
  var nid srcid tgtid : Nat .
  vars b remove? : Bool .
  var bindings : TBinds .
  vars notes gnotes : Notes .
  var ndl : NodeList .
  var edl : EdgeList .
  vars gname pname pgname kbname gtype q ptype : Qid .
  var attrids qidl oatts ratts  : QidList .
  var ?graph removedG : Graph .
  vars id str src tgt type label clabel nodesExp edgesExp  : String .
  vars nidstr valstr tagsExp valsExp selections colorFun toolBarFun : String .
  vars title subtitle : String .
  var val : Val .

*****************************************************************************
**** helper
  op qidl2squotes : QidList -> String .
  eq qidl2squotes(nil) = "" .
  eq qidl2squotes(q qidl) = squote(string(q)) + " " + qidl2squotes(qidl) .

*****************************************************************************
**** creating KBGraph in viewer 4 string arrays
  vars occ-labs occ-ids occ-aexps occ-locs rule-labs rule-ids : String .
  vars occ-lab-arr occ-id-arr occ-aexp-arr occ-loc-arr 
         rule-lab-arr rule-id-arr : String .

  op defKBGraphTemplate : -> String [ctor] .
  eq defKBGraphTemplate = 
       "(apply defKBGraph %kbname %occ-labs  %occ-ids %occ-aexps %occ-locs %rule-labs %rule-ids)" .
  op stringArrayTemplate : -> String [ctor] .
  eq stringArrayTemplate = "(array java.lang.String %strings )" .

  op objectArrayTemplate : -> String [ctor] .
  eq objectArrayTemplate = "(array java.lang.Object %strings )" .

  op mkdefKBGraphExp : Qid NodeList -> String .
  op mkOccArrExp : Qid NodeList String  String  String String  String  String -> String .
  eq mkdefKBGraphExp(kbname, ndl) = mkOccArrExp(kbname,ndl,"","","","","","") .

  ceq mkOccArrExp(kbname, nil,occ-labs,occ-ids,occ-aexps,occ-locs, 
                              rule-labs,rule-ids) =
       fillTemplate(defKBGraphTemplate,bindings)   
    if occ-lab-arr := 
          fillTemplate(stringArrayTemplate, ("%strings" :~ occ-labs))
    /\ occ-id-arr :=
           fillTemplate(stringArrayTemplate,("%strings" :~ occ-ids))
    /\ occ-aexp-arr :=
           fillTemplate(objectArrayTemplate,("%strings" :~ occ-aexps))
    /\ occ-loc-arr :=
           fillTemplate(stringArrayTemplate,("%strings" :~ occ-locs))
    /\ rule-lab-arr :=
        fillTemplate(stringArrayTemplate,("%strings" :~ rule-labs))
    /\ rule-id-arr :=
        fillTemplate(stringArrayTemplate,("%strings" :~ rule-ids)) 
    /\ bindings := 
      (("%kbname" :~ squote(string(kbname))),
       ("%occ-labs" :~ occ-lab-arr),
       ("%occ-ids" :~ occ-id-arr),
       ("%occ-aexps" :~ occ-aexp-arr),
       ("%occ-locs" :~ occ-loc-arr),
       ("%rule-labs" :~ rule-lab-arr),
       ("%rule-ids" :~ rule-id-arr))  .

  eq mkOccArrExp(kbname,nd(nid,(("type" := sv("occ")),notes)) ndl,
                  occ-labs,occ-ids,occ-aexps,occ-locs,rule-labs,rule-ids) =
      mkOccArrExp(kbname,ndl,
      occ-labs + " " + squote(svalString(lookupd(notes,"chattylabel",sv("")))),
      occ-ids + " " + squote(string(nid,10)),
      occ-aexps + " " + thingTl2aexp(occT2thT(tvalTerm(lookupd(notes,"occ", 
                                               tm('BOOL,'true.BOOL)))) ), 
      occ-locs + " " + squote(svalString(lookupd(notes,"loc",sv("")))),
                  rule-labs,rule-ids) .

  eq mkOccArrExp(kbname,nd(nid,(("type" := sv("rule")),notes)) ndl,
                 occ-labs,occ-ids,occ-aexps,occ-locs,rule-labs,rule-ids) =
      mkOccArrExp(kbname,ndl, occ-labs, occ-ids, occ-aexps,occ-locs,
         rule-labs + " " + 
                     squote(svalString(lookupd(notes,"chattylabel",sv("")))),
         rule-ids + " " + squote(string(nid,10))) .

**** drop nodes of unknow type -- shouldn't happen
  eq mkOccArrExp(kbname,nd(nid,notes) ndl,
                 occ-labs,occ-ids,occ-aexps,occ-locs,rule-labs,rule-ids) =
    mkOccArrExp(kbname,ndl, 
                occ-labs,occ-ids,occ-aexps,occ-locs,rule-labs,rule-ids) [owise] .


*****************************************************************************
**** making the attrs controlled by maude only
  op defineNewGraphTemplate : -> String .
  eq defineNewGraphTemplate = 
"(let ((makeGraph (lambda (graph mouseClickedClosure)\n\
        (seq\n\
         %nodes\n\
         %edges\n\
      )))\n\
        (graph (object (\"g2d.graph.IOPGraph\")))\n\
        (mouseClickedClosure \n\
          (if %ispnet \n\
             (apply mkPnetMouseClickedClosure graph)\n\
          (if %isxnet \n\
             (apply mkXnetMouseClickedClosure graph)\n\
             (object null)\n\
          )) ))\n\
   (seq\n\
     (apply makeGraph graph mouseClickedClosure)\n\
     (invoke graph \"setUID\" %gid)\n\
     (apply setAttrsAV graph %tags %vals (int %len) (int 0))\n\
     (setAttr graph \"colorFun\" %colorFun)\n\
     graph\n\
   )\n\
 )"  .


  op mkDefineNewGraphExp : Qid Graph Notes -> String .
  ceq mkDefineNewGraphExp(gname,?graph,gnotes) = 
        fillTemplate(defineNewGraphTemplate,bindings) 
  if ql(oatts) := lookupd(gnotes,"oatts",ql(nil))
  /\ ql(ratts) := lookupd(gnotes,"ratts",ql(nil))
  /\ sv(colorFun) := lookupd(gnotes,"colorFun",sv(""))
  /\ nodesExp := ng2nodesExp(graphNodes(?graph),oatts,ratts,colorFun,"")
  /\  edgesExp := ng2edgesExp(graphEdges(?graph),"")
  /\  ql(attrids) := lookupd(gnotes,"gatts",ql(nil))
  /\  tagsExp := qids2StringArrayExp(attrids,"")
  /\  valsExp := notes2StringArrayExp(gnotes,attrids,"")
  /\ ql(ptype pname)  := lookupd(gnotes,"source",ql('unknown 'unknown))
  /\ ql(gtype)  := lookupd(gnotes,"gtype",ql('unknown))
  /\  bindings := 
     (
      ("%gid" :~ squote(string(gname))),
**** xnet could be cnet then no IOP mouse clicks
      ("%ispnet" :~ (if ptype == 'pnet 
                    then "(boolean true)"  **** respond to mouse click
                    else "(boolean false)" fi)),
      ("%isxnet" :~ (if ptype == 'xnet and gtype =/= 'cnet
                    then "(boolean true)"  **** respond to mouse click
                    else "(boolean false)" fi)),
      ("%tags" :~ tagsExp),
      ("%vals" :~ valsExp),
      ("%len" :~ string(size(attrids),10)),
      ("%colorFun" :~ colorFun),
      ("%nodes" :~ nodesExp),
      ("%edges" :~ edgesExp)) .


  op qids2StringArrayExp : QidList String -> String .
  eq qids2StringArrayExp(nil,str) = "(array java.lang.String " + str + ")" .
  eq qids2StringArrayExp(q qidl,str) = 
          qids2StringArrayExp(qidl,str + " " + squote(string(q))) .

  op notes2StringArrayExp : Notes QidList String -> String .
  eq notes2StringArrayExp(notes,nil,str) = "(array java.lang.String " + str + ")" .

  ceq notes2StringArrayExp(notes, q qidl,str) = 
       notes2StringArrayExp(notes,qidl, str + " " + squote(valstr))
   if val := lookupd(notes,string(q),dummy)
   /\ valstr :=
             (if val :: QVal
              then qidl2str(qvalQidList(val))
              else (if val :: SVal
                    then svalString(val)
                    else "" fi) fi) .


**** making the attrs controlled by maude only
  op newNodeTemplate : -> String .
  eq newNodeTemplate = 
"(apply %newNode graph mouseClickedClosure %nid %lab %clab %tags %vals %colorFun)" .

  op ng2nodesExp : NodeList QidList QidList String String -> String .
  op ng2ndExp : Nat Notes QidList QidList String -> String .

  eq ng2nodesExp(nil,oatts,ratts,colorFun,nodesExp) = nodesExp .
  eq ng2nodesExp(nd(nid,notes) ndl,oatts,ratts,colorFun,nodesExp) =
       ng2nodesExp(ndl,oatts,ratts, colorFun,
         nodesExp + ng2ndExp(nid,notes,oatts,ratts,colorFun) + "\n") .
  
  ceq ng2ndExp(nid,notes,oatts,ratts,colorFun) =    
       (if type == "occ" or type == "rule"
        then fillTemplate(newNodeTemplate,bindings)
        else "" fi) 
   if sv(type) := lookupd(notes,"type",sv("")) 
   /\ label :=
        svalString(lookupd(notes,"label",sv("")))        *** label attr
   /\ clabel :=
        svalString(lookupd(notes,"chattylabel",sv("")))  *** clabel attr
   /\ nidstr :=  string(nid,10)                          *** nid attr
   /\ tagsExp := 
       qids2StringArrayExp(if type == "occ" then oatts else ratts fi,"")
   /\ valsExp :=
       notes2StringArrayExp(notes,if type == "occ" then oatts else ratts fi,"")
   /\ bindings :=
           (("%newNode" :~
                 (if type == "occ" then "newOccNode" else "newRuleNode" fi)),
             ("%nid" :~ squote(nidstr)),
             ("%lab" :~ squote(label)),
             ("%clab" :~ 
                  squote(if clabel == "" then label else clabel fi)),
             ("%tags" :~ tagsExp),
             ("%vals" :~ valsExp),
             ("%colorFun" :~ colorFun) )  .

  op newEdgeTemplate : -> String .
  eq newEdgeTemplate = "(apply newEdge graph %edgeSrc %edgeTgt %bidir?)" .

  op ng2edgesExp : EdgeList  String -> String .
  op ng2edExp : Nat Nat Notes -> String .

  eq ng2edgesExp(nil,edgesExp) = edgesExp .
  eq ng2edgesExp(ed(srcid,tgtid,notes) edl,edgesExp) = 
       ng2edgesExp(edl, edgesExp + ng2edExp(srcid,tgtid,notes) + "\n") .  

  ceq ng2edExp(srcid,tgtid,notes) = 
        fillTemplate(newEdgeTemplate,bindings)
   if type := svalString(lookupd(notes,"type",sv("unidir")))
   /\ src :=  string(srcid,10) 
   /\ tgt :=  string(tgtid,10) 
   /\ bindings := 
        (("%bidir?" :~ squote(if type == "bidir" then "true" else "false" fi)),
         ("%edgeSrc" :~ squote(src)),
         ("%edgeTgt" :~ squote(tgt)))  .

  op showNewGraphTemplate : -> String .
  eq showNewGraphTemplate =
 "(apply showNewGraph %gname %parent %selections %title %subtitle  %toolBarFun )" .

  op mkShowNewGraphExp : Qid Notes -> String .
  ceq mkShowNewGraphExp(gname,notes) =
        fillTemplate(showNewGraphTemplate,bindings)
  if sv(toolBarFun) :=  lookupd(notes,"toolBarFun",sv(""))
   /\ sv(title) := lookupd(notes,"title",sv(string(gname)))
   /\ sv(subtitle) := lookupd(notes,"subtitle",sv(""))
   /\ sv(selections) := lookupd(notes,"selections",sv("false"))
   /\ ql(pgname) := lookupd(notes,"parent",ql('unknown))
   /\ bindings := 
        (("%gname" :~ squote(string(gname))),
         ("%title" :~ squote(title)),
         ("%subtitle" :~ squote(subtitle)),
         ("%toolBarFun" :~ toolBarFun),
         ("%selections" :~ (if selections == "true" 
                            then "(boolean true)"
                            else "(boolean false)" fi)),
         ("%parent" :~ (if pgname == 'unknown
                        then "(object null)" 
                            else squote(string(pgname)) fi)) ) .

*****************************************************************************
**** updating a graph
*****************************************************************************


   op graphNewExtendTemplate : -> String .
  eq graphNewExtendTemplate = 
"(let ((graph (fetch %gid))\
       (mouseClickedClosure (apply mkXnetMouseClickedClosure graph))\n\
       )\n\
      (seq\n\
        %nodes\n\
        %edges\n\
      )\n\
 )"  .

****        (apply resetXselect graph)\n\

   op graphNewRemoveTemplate : -> String .
  eq graphNewRemoveTemplate = 
"(let ((graph (fetch %gid)))\n\
        (seq\n\
         %edges\n\
         %nodes\n\
      )\n\
 )"  .


  op mkupdXGraphExp : Qid Graph Graph Notes -> String .
  ceq mkupdXGraphExp(gname,?graph,removedG,gnotes) =
      (if remove?
       then fillTemplate(graphNewRemoveTemplate,bindings) 
       else fillTemplate(graphNewExtendTemplate,bindings) 
      fi)
  if remove? := removedG =/= mtGraph
  /\ ndl := graphNodes(if remove? then removedG else ?graph fi)
  /\ edl := graphEdges(if remove? then removedG else ?graph fi)
  /\ ql(oatts) := lookupd(gnotes,"oatts",ql(nil))
  /\ ql(ratts) := lookupd(gnotes,"ratts",ql(nil))
  /\ sv(colorFun) := lookupd(gnotes,"colorFun",sv(""))
  /\ nodesExp := (if remove?
                  then removeXGNodesExp(ndl,"")
                  else addXGNodesExp(ndl,oatts,ratts,colorFun,"")
                  fi)
  /\ edgesExp :=  (if remove?
                  then removeXGEdgesExp(edl,"")
                  else addXGEdgesExp(edl,"")
                 fi)
  /\ bindings := 
     (("%gid" :~ squote(graphId(?graph))),
      ("%nodes" :~ nodesExp),
      ("%edges" :~ edgesExp)) .

  op addXGNodesExp :  NodeList QidList QidList String String -> String .
  op addXGEdgesExp  : EdgeList String -> String .

  eq addXGNodesExp(nil,oatts,ratts,colorFun,str) = str .
  eq addXGNodesExp(nd(nid,notes) ndl,oatts,ratts,colorFun,str) = 
      addXGNodesExp(ndl,oatts,ratts,colorFun, str +
      (if lookupd(notes,"new",sv("false")) == sv("true") 
***       then ng2ndExp(nid,notes,oatts,ratts,colorFun) + "\n"  
       then ng2xndExp(nid,notes,oatts,ratts,colorFun) + "\n"  
       else **** (if lookupd(notes,"type",sv("none")) == sv("occ")  then 
            "(apply updateXNode graph " +  squote(string(nid,10)) + " " 
                   + " " + squote(svalString(lookupd(notes,"xstatus",sv("none"))))
                           + " " + colorFun + ")" + "\n"  
****             else "" fi) 
         fi)) .
 
  eq addXGEdgesExp(nil,str) = str . 
  eq addXGEdgesExp(ed(srcid,tgtid,notes) edl,str) = 
      addXGEdgesExp(edl, str +
           (if lookupd(notes,"new",sv("false")) == sv("true") 
***            then ng2edExp(srcid,tgtid,notes) + "\n"
            then ng2xedExp(srcid,tgtid,notes) + "\n"
            else ""
            fi)) .


**** making the attrs controlled by maude only
  op newXNodeTemplate : -> String .
  eq newXNodeTemplate = 
"(apply newXNode graph %type mouseClickedClosure %nid %lab %clab %tags %vals %colorFun)" .

  op ng2xndExp : Nat Notes QidList QidList String -> String .
  ceq ng2xndExp(nid,notes,oatts,ratts,colorFun) =    
     fillTemplate(newXNodeTemplate,bindings)
   if sv(type) := lookupd(notes,"type",sv("")) 
   /\ label :=
        svalString(lookupd(notes,"label",sv("")))        *** label attr
   /\ clabel :=
        svalString(lookupd(notes,"chattylabel",sv("")))  *** clabel attr
   /\ nidstr :=  string(nid,10)                          *** nid attr
   /\ tagsExp := 
       qids2StringArrayExp(if type == "occ" then oatts else ratts fi,"")
   /\ valsExp :=
       notes2StringArrayExp(notes,if type == "occ" then oatts else ratts fi,"")
   /\ bindings :=
           (("%newNode" :~
                 (if type == "occ" then "newOccNode" else "newRuleNode" fi)),
             ("%type" :~ squote(type)),
             ("%nid" :~ squote(nidstr)),
             ("%lab" :~ squote(label)),
             ("%clab" :~ 
                  squote(if clabel == "" then label else clabel fi)),
             ("%tags" :~ tagsExp),
             ("%vals" :~ valsExp),
             ("%colorFun" :~ colorFun) )  .

  op newXEdgeTemplate : -> String .
  eq newXEdgeTemplate = "(apply newXEdge graph %edgeSrc %edgeTgt %bidir?)" .

  op ng2xedExp : Nat Nat Notes -> String .
  ceq ng2xedExp(srcid,tgtid,notes) = 
        fillTemplate(newXEdgeTemplate,bindings)
   if type := svalString(lookupd(notes,"type",sv("unidir")))
   /\ src :=  string(srcid,10) 
   /\ tgt :=  string(tgtid,10) 
   /\ bindings := 
        (("%bidir?" :~ squote(if type == "bidir" then "true" else "false" fi)),
         ("%edgeSrc" :~ squote(src)),
         ("%edgeTgt" :~ squote(tgt)))  .

****!!!! delete incontext

**** remove existing (old) node
  op ngDelNodeTemplate : -> String .
  eq ngDelNodeTemplate =  "(apply delXNode graph  %nodeId)" .

****   "(invoke graph \"rmNode\" (invoke graph \"getNode\" %nodeId))" .

  op ng2ndDelExp : Nat -> String .
  eq ng2ndDelExp(nid) =     
      fillTemplate(ngDelNodeTemplate,("%nodeId" :~ squote(string(nid,10)))) .


**** remove existing (old) edge
  op ngDelEdgeTemplate : -> String .
  eq ngDelEdgeTemplate = "(apply delXEdge graph  %srcId %tgtId)" .

**** "(invoke graph \"rmEdge\" \n\
****    (invoke graph \"getEdge\" \n\
****     (invoke graph \"getNode\" %srcId) (invoke graph \"getNode\" %tgtId)))" .


  op ng2edDelExp : Nat Nat -> String .
  eq ng2edDelExp(srcid,tgtid) =     
      fillTemplate(ngDelEdgeTemplate,
           (("%srcId" :~ squote(string(srcid,10))),
            ("%tgtId" :~ squote(string(tgtid,10))))) .


  op removeXGNodesExp : NodeList String -> String .
  op removeXGEdgesExp  : EdgeList String -> String .

  eq removeXGNodesExp(nil,str) = str .
  eq removeXGNodesExp(nd(nid,notes) ndl,str) =
     removeXGNodesExp(ndl, str + ng2ndDelExp(nid) ) .

  eq removeXGEdgesExp(nil,str) = str .
  eq removeXGEdgesExp(ed(srcid,tgtid,notes) edl,str) =
     removeXGEdgesExp(edl, str + ng2edDelExp(srcid,tgtid) ) .

*****************************************************************************
**** showing an updated graph
*****************************************************************************

 op xshowUGraphTemplate : -> String .
  eq xshowUGraphTemplate = "(apply showUXGraph %gid)"  .

**** called with false
  op mkshowUXGraphExp :  Qid  -> String .

  eq mkshowUXGraphExp(gname) = 
       fillTemplate(xshowUGraphTemplate,("%gid" :~ squote(string(gname)))) . 


*****************************************************************************
**** saving jlambda expression for graph
*****************************************************************************
  op savedNewGraphTemplate : -> String .
  eq savedNewGraphTemplate = 
"(seq \n\
   %loadstr\n\
   (apply defKBManager)\n\
   %defineNewGraph\n\
   %showNewGraph\n\
 )"  .

  op mkSavedNewGraphExp : Qid Graph Notes  -> String .
  ceq mkSavedNewGraphExp(gname,?graph,gnotes) = 
        fillTemplate(savedNewGraphTemplate,bindings) 
  if bindings := 
     (
      ("%defineNewGraph" :~ mkDefineNewGraphExp(gname,?graph,gnotes)),
      ("%showNewGraph" :~ mkShowNewGraphExp(gname,
                                      insert("parent",ql('unknown),gnotes))),
      ("%loadstr" :~ loadprefix1) ) .

  op loadprefix1 : -> String .
  eq loadprefix1 = "(load \"~/Maude/Lib/M2.2/PLA1/load-g2dlib.lsp\")\n" .


endfm




**** loadmaude loaded graph2lola.maude
fmod GRAPH2LOLA is
  inc GRAPH .
  inc SVAL .
  inc NAT-QID .

***(
PLACES p0, p1, p2, p3, p4, p5;

MARKING p0 : 1, p1 : 0, p4 : 1;

TRANSITION t64
CONSUME p80 : 1, p30 : 1, p68 : 1, p84 : 1, p1 : 1;
PRODUCE p80 : 1, p30 : 1, p68 : 1, p84 : 1, p81 : 1;
...
)

  vars att val def ?string : String .
  vars pathStr preStr postStr placesStr initStr transStr : String .
  var nds : NodeList .
  vars n nodeId : Nat .
  var notes : Notes .
  vars nodes nodes' occNodes initNodes ruleNodes : NodeList .
  var edges : EdgeList .
  vars start end : FindResult .
  vars rids qids : QidList .
  var nid : Qid .

*** Assume graph of relevant subnet with init and goal status marked

  op mkLolaNetString     : Graph  -> String .
  op mkLolaNetString     : NodeList  -> String .
  op mkLolaPlacesString  : NodeList String -> String .
  op mkLolaMarkingString : NodeList String -> String .
  op mkLolaTransString   : NodeList String -> String .
  op mkLolaTrans1        : Nat Notes -> String .
  op mkLolaPrePost       : QidList -> String .

  eq mkLolaNetString(graph(?string,notes,nodes,edges)) =
       mkLolaNetString(nodes) .
  ceq mkLolaNetString(nodes) =
      placesStr + initStr + transStr 
   if occNodes := getNodes(nodes,"type",sv("occ"))
   /\ initNodes := getNodes(occNodes,"init", sv("true"))
   /\ ruleNodes := getNodes(nodes,"type",sv("rule"))
   /\ placesStr := mkLolaPlacesString(occNodes,"PLACE ") + ";\n" 
   /\ initStr := mkLolaMarkingString(initNodes, "\nMARKING ") + ";\n" 
   /\ transStr := mkLolaTransString(ruleNodes, "") 
  .

  eq mkLolaPlacesString(nil, ?string) = ?string .
  eq mkLolaPlacesString(nd(nodeId,notes) nds, ?string) = 
         mkLolaPlacesString(nds,
           (if nds == nil 
            then ?string + "p" + string(nodeId,10)
            else ?string + "p" + string(nodeId,10) + ", "
            fi)) .

  eq mkLolaMarkingString(nil, ?string) = ?string .
  eq mkLolaMarkingString(nd(nodeId,notes) nds, ?string) = 
         mkLolaMarkingString(nds,
           (if nds == nil 
            then ?string + "p" + string(nodeId,10) + " : 1"
            else ?string + "p" + string(nodeId,10) + " : 1" + ", "
            fi)) .

  eq mkLolaTransString(nil, ?string) = ?string .
  eq mkLolaTransString(nd(nodeId,notes) nds, ?string) = 
         mkLolaTransString(nds, ?string + mkLolaTrans1(nodeId,notes)) .

  ceq mkLolaTrans1(nodeId,notes) = 
      "TRANSITION " + "t" + string(nodeId,10) + "\n"
       + "CONSUME " + mkLolaPrePost(str2qidl(preStr)) + ";\n"
       + "PRODUCE " + mkLolaPrePost(str2qidl(postStr)) + ";\n"
  if sv(preStr) := lookupd(notes,"pre",sv(""))
  /\ sv(postStr) := lookupd(notes,"post",sv("")) .

  eq mkLolaPrePost(nil) = "" .
  eq mkLolaPrePost(nid qids) = 
      "p" + string(nid) + " : 1" +
     (if qids == nil then "" else ", " + mkLolaPrePost(qids) fi) .


**** FORMULA ( (p72 = 1) AND  (p73 = 1) )

  op mkLolaTaskString : Graph -> String .
  op mkLolaTaskString : NodeList -> String .
  op mkLolaGoalString : NodeList -> String .
  
  eq mkLolaTaskString(graph(?string,notes,nodes,edges)) =
          mkLolaTaskString(nodes) .

  eq mkLolaTaskString(nodes)
     =
   "FORMULA ( " + 
      mkLolaGoalString(getNodes(getNodes(nodes,"type",sv("occ")),
                        "status",sv("goal"))) 
      + " )\n" .

  eq mkLolaGoalString(nil) = "" .
  eq mkLolaGoalString(nd(nodeId,notes) nds) = 
      "( " + "p" + string(nodeId,10) + " = 1 )" 
      + (if nds == nil then "" else " AND " + mkLolaGoalString(nds) fi) .   

****HERE!!!
**** Parsing Lola output
**** "PATH t0 t15 ... "
***(
  op firstNonBlank : String Nat -> FindResult .
  eq firstNonBlank(?string, n) =
      (if n >= length(?string) 
       then notFound
       else (if substr(?string,n,1) =/= " "
             then n
             else firstNonBlank(?string,s n)
             fi)  fi) .

  op string2rids : String Nat -> Nats .  *** strip offf "t" and convert to nat

  ceq string2rids(?string,n) = 
     ( ( if (nodeId :: Nat) then nodeId else emptyNatList fi ) 
       ( if (end :: Nat) then string2rids(?string,end) else emptyNatList fi ))
     if start := firstNonBlank(?string,n)
     /\ end := if start :: Nat then find(?string," ",start) else start fi
     /\ nodeId :=
          rat((if (start :: Nat) 
               then (if  (end :: Nat)
                    then substr(?string,s start,sd(end,s start))
                    else substr(?string,s start,length(?string)) fi)
               else "" fi),10)  .
)

****  op readLolaResult : Graph String -> QidList .   **** ruleids of
  op readLolaResult : NodeList QidList -> QidList . **** the transitions fired
  op getLolaTrans : NodeList QidList -> QidList . 
 
  eq readLolaResult(nodes, qids) = 
     (if (size(qids) <= 2)
      then nil
      else getLolaTrans(nodes, getPost(2,qids)) fi) .
 ****  skip the code and initial PATH 

  eq getLolaTrans(nodes,nil) = nil .
  ceq getLolaTrans(nodes,nid qids) = 
        ( rids getLolaTrans(nodes,qids)  )
      if ?string := substr(string(nid),1,length(string(nid)))
      /\ n := rat(?string,10) 
      /\ nodes' := (if n :: Nat then getNode(nodes,n) else nil fi)
      /\ rids := 
            (if nodes' :: Node
             then qid(svalString(lookupd(nodeNotes(nodes'),
                                         "chattylabel",sv("")))) 
                  else nil fi)
      .

endfm



**** loadmaude loaded graph-info.maude
fmod COMPONENT-INFO is
  inc MY-META-ALL .
  inc META-PETRI .
  inc NAT-QID .
  inc PARSE-SEXP-STRING .
  inc NEW-GRAPH2G2D .


  var next : FindResult .
  vars qid modname opname gname kbname opsort clab : Qid .
  vars qidl toks : QidList .
  vars str str' astr opstr field : String .
  var sexp : Sexp .  

  vars sl sl' sexpl : SexpL . 
  var sexp? : Sexp? . 
  var atm : SAtom .

  var typel : TypeList . var type : Type .
  var attrs : AttrSet .
  var opdecls : OpDeclSet .
  vars occT thT locT : Term .
  vars nodes nodes' : NodeList .


  op getField : Sexp String -> Sexp .  *** returns [field  vals] or [nil]
  op getFieldL : SexpL String -> Sexp .  *** returns [field  vals] or [nil]

  eq getField(atm,str) = [nil] .
  eq getField([sl],str) = getFieldL(sl,str) .

  eq getFieldL(nil,str) = [nil] .
  eq getFieldL([a(str') sl] sl',str) = 
       (if str == str' 
        then [a(str) sl] 
        else getFieldL(sl',str)
        fi) .

**** want string part of atomic string value
  op getFieldStr : SexpL -> String .
  eq getFieldStr(a(str) sexpl) = str .
  eq getFieldStr(sexpl) = "" [owise] .

  op getFieldVal : Sexp String -> String .
  eq getFieldVal(sexp,str) = getFieldStr(getFieldVals(sexp,str)) .

  op getFieldVals : Sexp String -> SexpL .
  eq getFieldVals(sexp,str) = cdrl(sexp2l(getField(sexp,str))) .

**** assumes SexpL is list of atoms
  op sexpl2arrayExp : SexpL String -> String .
  eq sexpl2arrayExp(nil,astr) = 
        fillTemplate("(array java.lang.String %strings )",("%strings" :~ astr)) .
  eq sexpl2arrayExp(a(str) sexpl,astr) = 
           sexpl2arrayExp(sexpl,astr + " " + squote(str)) . 
  eq sexpl2arrayExp(sexp sexpl,astr) = sexpl2arrayExp(sexpl,astr) [owise] .

  op proteinInfoTemplate : -> String .
  eq proteinInfoTemplate = 
    "(apply displayProteinInfo %gname %hugosym %spnum %synonymsArray)" .

****                  gname   metadata 
  op mkProteinInfoSExp : Qid   Sexp -> String .
  eq mkProteinInfoSExp(gname,sexp) =
       fillTemplate(proteinInfoTemplate,
       (("%gname" :~ squote(string(gname))),
        ("%hugosym" :~ squote(getFieldVal(sexp,"hugosym"))),
        ("%spnum" :~ squote(getFieldVal(sexp,"spnumber"))),
        ("%synonymsArray" :~ sexpl2arrayExp(getFieldVals(sexp,"synonyms"),""))
       )) . 

  op chemicalInfoTemplate : -> String .
  eq chemicalInfoTemplate = 
    "(apply displayChemicalInfo %gname %keggcpd %synonymsArray)" .

****                  gname modname opname
  op mkChemicalInfoSExp : Qid Sexp -> String .
  eq mkChemicalInfoSExp(gname,sexp) =
       fillTemplate(chemicalInfoTemplate,
       (("%gname" :~ squote(string(gname))),
        ("%keggcpd" :~ squote(getFieldVal(sexp,"keggcpd"))),
        ("%synonymsArray" :~ sexpl2arrayExp(getFieldVals(sexp,"synonyms"),""))
       )) . 


**** occT2ThT
**** what about the includes attribute?
****  op leastSort : Module Term ~> Type

**** reduce use of meta/graph to the mkComponent/Rule info call

  op getOpMetaData : Qid Qid -> String .
  op getOpMetaData1 : OpDeclSet Qid -> String .
  eq getOpMetaData(modname,opname) =
      getOpMetaData1(upOpDecls(modname,true),opname) .

  eq getOpMetaData1((op qid : typel -> type[attrs].) opdecls, 
                    opname) = 
      (if qid == opname 
       then getMetaData(attrs)
       else getOpMetaData1(opdecls,opname) 
       fi) .
  eq getOpMetaData1(none,opname) = "" .

****                  gname modname thT
  op mkComponentInfoExp : Qid Qid Term -> String .
  ceq mkComponentInfoExp(gname,modname,thT) =
      (if hasSort([modname],thT,'Protein)
****       then mkProteinInfoExp(gname,modname,getBaseName(thT)) 
       then mkProteinInfoSExp(gname,sexp)
       else (if hasSort([modname],thT,'Chemical)
             then mkChemicalInfoSExp(gname,sexp)
             else mkOtherInfoExp(gname,modname,leastSort([modname],thT),
                             qidl2str(metaPrettyPrint([modname],thT)))
             fi)  fi) 
  if str := getOpMetaData(modname,getBaseName(thT)) 
  /\ ixs(next,sexp?) := readSexp(str,0,length(str)) 
  /\ sexp := (if sexp? :: Sexp
              then sexp?
              else [nil] fi) .


**** put in meta-petri
  op getBaseName : Term -> Qid .
  eq getBaseName(v:Variable) = getName(v:Variable) .
  eq getBaseName(c:Constant) = getName(c:Constant) .
  eq getBaseName('`[_-_`][(t:Term,tl:TermList)]) = getBaseName(t:Term) .
  eq getBaseName(t:Term) = 'false [owise] .

  op otherInfoTemplate : -> String .
  eq otherInfoTemplate = 
    "(apply displayOtherInfo %gname %sort %opstr)" .

****                  gname modname opsort opstr
  op mkOtherInfoExp : Qid   Qid    Qid     String -> String .
  eq mkOtherInfoExp(gname,modname,opsort,opstr) =
       fillTemplate(otherInfoTemplate,
       (("%gname" :~ squote(string(gname))),
        ("%sort" :~ squote(string(opsort))),
        ("%opstr" :~ squote(opstr))
       )) . 

**** from meta-petri
****  op occT2thT : Term -> TermList .
****  eq occT2thT('<_`,_>[thT,locT]) = thT .
****  eq occT2thT(occT) = empty [owise] .

  op ruleEvidenceTemplate : -> String .
  eq ruleEvidenceTemplate = 
    "(apply ruleEvidence %gname %clab %refArray)" .

  op ql2arrayExp : QidList String -> String .
  eq ql2arrayExp(nil,astr) = 
        fillTemplate("(array java.lang.String %strings )",("%strings" :~ astr)) .
  eq ql2arrayExp(qid qidl,astr) = 
          ql2arrayExp(qidl,astr + " " + squote(string(qid))) . 

****                gname clab pmids
  op mkRuleEvidenceExp : Qid Qid QidList -> String .
  eq mkRuleEvidenceExp(gname,clab,toks) =
       fillTemplate(ruleEvidenceTemplate,
       (("%gname" :~ squote(string(gname))),
        ("%clab" :~ squote(string(clab))),
        ("%refArray" :~ ql2arrayExp(toks,""))
       )) . 



endfm


**** loadmaude loaded graph-info-x.maude
fmod GRAPH-INFO is
  inc COMPONENT-INFO .
****  inc MY-META-ALL .
****  inc META-PETRI .
****  inc NAT-QID .
****  inc PARSE-SEXP-STRING .
****  inc GRAPH2G2D .


  var next : FindResult .
  vars qid modname opname gname kbname opsort clab : Qid .
  vars qidl toks : QidList .
  vars str str' astr opstr field key name fun urlpat : String .
  var sexp : Sexp .  

  vars sl sl' sexpl : SexpL . 
  var sexp? : Sexp? . 
  var atm : SAtom .

  var typel : TypeList . var type : Type .
  var attrs : AttrSet .
  var opdecls : OpDeclSet .
  vars occT thT locT : Term .
  vars nodes nodes' : NodeList .
  var bindings : TBinds .


  vars ispec cspec : Sexp .
  var lsort : [Type] .
  vars  ispecl cspecl : SexpL .
  var vstr : String .

**** mkComponentInfoExpX(ispec,gname,modname,clab,tl)
**** sxv(ispec) := getVal(es,'sxval,'ComponentInfoSpec,sxv([nil]))

  op mkComponentInfoExpX : Sexp Qid Qid Qid Term -> String .
  ceq mkComponentInfoExpX(ispec,gname,modname,clab,thT)
         =  mkCInfoExp(gname,clab,cspecl,sexp)
  if lsort := leastSort([modname],thT)
  /\ cspecl := (if lsort :: Type 
                then getCSpecL(sexp2l(ispec),modname,lsort) 
                else [nil] fi)
  /\ str := getOpMetaData(modname,getBaseName(thT)) 
  /\ ixs(next,sexp?) := readSexp(str,0,length(str)) 
  /\ sexp := (if sexp? :: Sexp then sexp? else [nil] fi) .


  op getCSpecL : SexpL Qid Type -> SexpL .
  eq getCSpecL(nil,modname,lsort) = nil .
  eq getCSpecL(sexp sexpl,modname,lsort) = 
       (if specFor(sexp,modname,lsort) =/= nil
        then specFor(sexp,modname,lsort) 
        else getCSpecL(sexpl,modname,lsort) fi) .

  op specFor : Sexp Qid Type -> SexpL .
  eq specFor([a(str) sexpl],modname,lsort) =
      (if sortLeq([modname], lsort, qid(str)) then sexpl else nil fi) .
  eq specFor(sexp,modname,lsort) = nil [owise] .


  op ComponentInfoTemplate : -> String .
  eq ComponentInfoTemplate =
  "(apply displayComponentInfo %gname %clab (array java.lang.Object  %iarrstr))" .

  op mkCInfoExp : Qid Qid SexpL Sexp -> String .
  eq mkCInfoExp(gname,clab,cspecl,sexp) =
      fillTemplate(ComponentInfoTemplate,
       (("%gname" :~ squote(string(gname))),
        ("%clab" :~ squote(string(clab))),
        ("%iarrstr" :~ mkIArrayStr(cspecl,sexp,""))) ) .

  op mkIArrayStr : SexpL Sexp String -> String .
  eq mkIArrayStr(nil,sexp,str) = str .
  eq mkIArrayStr(cspec cspecl,sexp,str) = 
      mkIArrayStr(cspecl,sexp, mkIItemStr(cspec,sexp,str)) .


  op valInfoTemplate : -> String .
  eq valInfoTemplate =  "(array java.lang.String \"val\" %name %val)" .

  op mkIItemStr : Sexp Sexp String -> String .
  ceq mkIItemStr([a(key) a("val") a(name)],sexp,str) =
    (if vstr == "" 
     then str 
     else  str + "\n" 
           + fillTemplate(valInfoTemplate,
                   (("%name" :~ squote(name)),
                    ("%val" :~ squote(vstr))) ) fi) 
  if vstr := getFieldVal(sexp,key) .

  op linkInfoTemplate : -> String .
  eq linkInfoTemplate =  "(array java.lang.String \"link\" %name %arg %url)" .

  ceq mkIItemStr([a(key) a("link") a(name) a(urlpat)],sexp,str) =
    (if vstr == "" 
     then str 
     else  str + "\n" +
            fillTemplate(linkInfoTemplate,
                (("%name" :~ squote(name)),
                 ("%arg" :~ squote(vstr)),
                 ("%url" :~ squote(fillTemplate(urlpat, ("%arg" :~ vstr))))) ) fi) 
  if vstr := getFieldVal(sexp,key) .

  op listInfoTemplate : -> String .
  eq listInfoTemplate =  
  "(array java.lang.Object \"list\" %name %fun (array java.lang.String %list) )" .

  ceq mkIItemStr([a(key) a("list") a(name) a(fun)],sexp,str) =
    (if sexpl == nil 
     then str 
     else  str + "\n" +
            fillTemplate(listInfoTemplate,
                  (("%name" :~ squote(name)),
                   ("%fun" :~ fun),
                   ("%list" :~ astr)) ) fi)
  if sexpl := getFieldVals(sexp,key) 
  /\   astr := sexpl2astr(sexpl,"") .

  eq mkIItemStr(cspec,sexp,str) = str [owise] .

  op sexpl2astr : SexpL String -> String .
  eq sexpl2astr(nil,str) = str .
  eq sexpl2astr(a(str') sexpl,str) = sexpl2astr(sexpl, str + " " + squote(str')) .
  eq sexpl2astr(sexp sexpl,str) = sexpl2astr(sexpl, str) .



endfm

fmod TEST-COMPONENT-INFO is
  inc GRAPH-INFO .

  op cispec : -> Sexp .
  eq cispec = 
    [ [a("Protein")
        [a("hugosym") a("val") a("HUGO") ]
        [a("spnumber") a("link") a("SwissProt")
          a("http://www.expasy.ch/cgi-bin/niceprot.pl?%arg") ]
        [a("synonyms") a("list") a("Synonyms") a("ident") ]
       ]
       [a("Chemical")
        [a("keggcpd") a("link") a("KEGG")
          a("http://www.genome.jp/dbget-bin/www_bget?compound+%arg") ]
        [a("synonyms") a("list") a("Synonyms") a("ident") ]
       ]
     ] .

  ops mdPIP3 mdPlcg  : -> String .
  eq mdPIP3 = "(\
   (category Chemical)\
   (keggcpd C05981)\
   (synonyms \"Phosphatidylinositol-3,4,5P \" ))" .

  eq mdPlcg = "(\
  (spname PIG1_HUMAN)\
  (spnumber P19174)\
  (hugosym PLCG1)\
  (synonyms \"1-phosphatidylinositol-4,5-bisphosphate phosphodiesterase gamma 1\" \
            \"EC 3.1.4.11 \" \
            \"Phosphoinositide phospholipase C \" \
            \"PLC-gamma-1 \" \
            \"Phospholipase C-gamma-1 \" \
            \"PLC-II,  PLC-148, PLC1 \"))"  .

  op pip3Sexp : -> Sexp .
  ceq pip3Sexp =   (if f:FindResult :: Nat and sexp?:Sexp? :: Sexp
                   then sexp?:Sexp?
                   else [nil] fi)
  if ixs(f:FindResult, sexp?:Sexp?) := readSexp(mdPIP3,0,length(mdPIP3)) .

  op plcgSexp : -> Sexp .
  ceq plcgSexp =   (if f:FindResult :: Nat and sexp?:Sexp? :: Sexp
                   then sexp?:Sexp?
                   else [nil] fi)
  if ixs(f:FindResult, sexp?:Sexp?) := readSexp(mdPlcg,0,length(mdPlcg)) .




endfm



***(

  ceq mkComponentInfoExpX(gname,modname,clab,thT)
         =  mkCInfoExp(gname,clab,cspecl,sexp)
  if sxv(ispec) := getVal(es,'sxval,'ComponentInfoSpec,sxv([nil]))
  /\ lsort := leastSort([modname],thT)
  /\ cspecl := (if lsort :: Type then getCSpecL(sexp2l(ispec),lsort) else [nil] fi)
  /\ str := getOpMetaData(modname,getBaseName(thT)) 
  /\ ixs(next,sexp?) := readSexp(str,0,length(str)) 
  /\ sexp := (if sexp? :: Sexp then sexp? else [nil] fi) .

red getCSpecL(sexp2l(cispec),'QQQ,'Chemical) .
red getCSpecL(sexp2l(cispec),'QQQ,'Protein) .

red mkCInfoExp('g4,'PIP3-CLm,getCSpecL(sexp2l(cispec),'QQQ,'Chemical),pip3Sexp) .

(apply displayComponentInfo "g4" "PIP3-CLm" (array java.lang.Object (array java.lang.String "link" "KEGG" "C05981" "http://www.genome.jp/dbget-bin/www_bget?compound+C05981")(array java.lang.Object "list" "Synonyms" ident (array java.lang.String  "Phosphatidylinositol-3,4,5P ") )))

red mkCInfoExp('g4,'Plcg1-CLc,getCSpecL(sexp2l(cispec),'QQQ,'Protein),plcgSexp) .

(apply displayComponentInfo "g4" "Plcg1-CLc" (array java.lang.Object (array java.lang.String "val" "HUGO" "PLCG1")(array java.lang.String "link" "SwissProt" "P19174" "http://www.expasy.ch/cgi-bin/niceprot.pl?P19174")(array java.lang.Object "list" "Synonyms" ident (array java.lang.String  "1-phosphatidylinositol-4,5-bisphosphate phosphodiesterase gamma 1" "EC 3.1.4.11 " "Phosphoinositide phospholipase C " "PLC-gamma-1 " "Phospholipase C-gamma-1 " "PLC-II,  PLC-148, PLC1 ") )))

red mkComponentInfoExpX(cispec, 'g4,'QQQ,'PIP3-CLm,'PIP3.Chemical) .

red mkComponentInfoExpX(cispec, 'g4,'QQQ,'Plcg1-CLc,'Plcg1.Protein) .

)

**** loadmaude loaded aux-eset.maude
fmod PLA-AUX is
  inc IDATA .

**** additional Val subsorts
  inc GVAL-IO .
  inc MVAL-IO .     
  inc SXVAL-IO .     

  inc PL-PRINT .  *** for printing titles
  inc META-PETRI .
****  inc SEXP .

  var es : ESet .
  var n : Nat .
  vars s gstr astr rstr : String .
  vars pntlT occsT t uoccsT goccsT aoccsT ridsT : Term .
  vars gname pname qid type modname name kbname xname dname user-dname  : Qid .
  var pnotes gnotes notes : Notes .
  var b : Bool .
  var sexpl : SexpL .
  var toks : QidList .


    
******************************************************************************
***** for conditional ESet functions

  sort BoolESet .
  op `{_,_`} : Bool ESet -> BoolESet [ctor] .
  op be2b : BoolESet -> Bool .
  op be2e : BoolESet -> ESet .
  eq be2b({b,es}) = b .
  eq be2e({b,es}) = es .

**** gensym hack for generating new ids 

  op getGlobalCounter : ESet -> String .
  op incGlobalCounter : ESet -> ESet .
  op incGlobalCounter : ESet Nat -> ESet .

  eq getGlobalCounter(es) = 
          svalString(getVal(es,'sval,'globalCounter,sv("0"))) .
  eq incGlobalCounter(es) = incGlobalCounter(es,1) .
  eq incGlobalCounter(es,n) = 
       addEntry(es,'sval,'globalCounter,
                sv(string(rat(getGlobalCounter(es),10) + n,10))) .


  op stringInc : String -> String .
  eq stringInc(s) = 
      (if string(rat(s,10) + 1, 10) :: String
       then string(rat(s,10) + 1, 10) 
       else s fi) .

**** sort refinement for added Val sorts 
  op getVal : ESet Qid QidList GVal -> GVal .
  op getVal : ESet Qid QidList MVal -> MVal .

  op getGraphKBname : ESet Qid Qid -> Qid .
  eq getGraphKBname(es,gname,qid) =
       getNth(0,
              qvalQidList(lookupd(getNotes(es,'gval,gname),"kbname",ql(qid))), 
              qid) .

  op isXnetG : ESet Qid -> Bool .
  eq isXnetG(es,gname) =
        getNth(0,
               qvalQidList(lookupd(getNotes(es,'gval,gname),
                                           "source",ql('unknown 'unknown))),
               'unknown) == 'xnet .


  op isKB : ESet Qid -> Bool .
  eq isKB(es,gname) =
       'tkb == getNth(0, 
                      qvalQidList(lookupd(getNotes(es,'gval,gname),
                                          "source",
                                           ql('unknown 'unknown))),
                      'unknown) . 

 

  ops traceGraph tracePNet traceXNet : ESet Qid -> Sexp .
  ceq traceGraph(es,gname) = [a("graph") a(string(gname)) sexpl]
  if gnotes := getNotes(es,'gval,gname)
  /\ ql(type pname) := lookupd(gnotes,"source",ql('unknown 'unknown)) 
  /\ [sexpl] :=  traceNet(es,type,pname) .

  op traceNet : ESet Qid Qid -> Sexp .
  eq traceNet(es,'pnet,pname) = tracePNet(es,pname) .
  eq traceNet(es,'xnet,pname) = traceXNet(es,pname) .
  eq traceNet(es,type,pname) = [nil]  [owise] .
  
  ceq tracePNet(es,pname) = [a(string(type)) a(string(pname)) sexpl]
  if pnotes := getNotes(es,'tval,'pnet pname)
  /\ ql(type name) := lookupd(pnotes,"source",ql('unknown 'unknown)) 
  /\ sexpl := (if type == 'dishnet
               then dishnetTrace(pnotes,name)
               else queryTrace(pnotes,name)
                fi) .

  ops dishnetTrace queryTrace : Notes  Qid -> SexpL .
  ceq dishnetTrace(notes,dname)  = 
      ( [a("kbname") a(string(kbname)) ]
        [a("initialState") a(string(user-dname)) ] )
  if ql(name user-dname) := lookupd(notes,"dishname",ql('unknown 'unknown) )
  /\ ql(kbname) := lookupd(notes,"kbhname",ql('unknown) ) .

  ceq queryTrace(notes,name) =
     ( [a("parent") a(string(name)) ]
       [a("kbname") a(string(kbname))]       
       [a("initialState") a(string(user-dname))]
       [a("goalOccs") a(gstr)]
       [a("avoidOccs") a(astr)]
       [a("hiddenRules") a(rstr)] )
  if ql(dname user-dname) := lookupd(notes,"dishname",ql('unknown 'unknown) )
  /\ ql(kbname) := lookupd(notes,"kbhname",ql('unknown) ) 
  /\ tm(modname,goccsT) := lookupd(notes,"gOccs",tm('UNKNOWN,'none.Occs))
  /\ tm(modname,aoccsT) := lookupd(notes,"aOccs",tm('UNKNOWN,'none.Occs))
  /\ tm(modname,ridsT) := lookupd(notes,"aRules",tm('UNKNOWN,'nil.QidList)) 
  /\ gstr := printOccTL([modname],occsT2occTL(goccsT))
  /\ astr := printOccTL([modname],occsT2occTL(aoccsT))
  /\ rstr := printRidTL(qidlT2tl([modname],ridsT)) .

  ceq traceXNet(es,xname) =
     [a("xnet") a(string(xname)) 
       [a("scope") a(string(type)) a(string(name))]
       [a("kbname") a(string(kbname))]
       [a("history") history2sexp(toks)] ]
  if notes := getNotes(es,'tval,'xnet xname)
  /\ ql(type name) := lookupd(notes,"source",ql('unknown 'unknown))
  /\ ql(gname) := lookupd(notes,"graph",ql('unknown)) 
  /\ ql(kbname) := lookupd(getNotes(es,'gval,gname),"kbname",ql('unknown)) 
  /\ ql(toks) :=  lookupd(notes,"history", ql(nil)) .

  op traceTkb : ESet Qid -> Sexp .
  ceq traceTkb(es,kbname) = 
       [a("tkb") a(string(kbname)) a(string(type)) a(string(name))]
  if notes := getNotes(es,'tval,'tkb kbname)
  /\ ql(type name) := lookupd(notes,"source",ql('unknown 'unknown)) .

  op history2sexp : QidList -> Sexp .
  eq history2sexp(toks) = [a("history")] .   ***** hack

**** shared by pla-graph and pla-explore

  op mkGraphTitle : Qid Notes -> String .
  op mkGraphSubTitle : Notes -> String .

  ceq mkGraphTitle(pname,pnotes) =
         "Graph for " + string(type) + " " + string(pname) 
      if ql(type qid) := lookupd(pnotes,"source",ql('unknown 'unknown)) .

****  eq mkGraphTitle('pathnet,gname) = "Graph for path in "  + string(gname) .

**** 09aug02 clt to display in SEpanel
  ceq mkGraphSubTitle(pnotes) =
****    (if gstr == "" then "" else "\t Goals: " + gstr + "\n" fi)
    (if gstr == "" then "" else " Goals: " + gstr + "\n" fi)
    +
****    (if astr == "" then "" else "\t OccAvoids: " + astr + "\n" fi)
    (if astr == "" then "" else " OccAvoids: " + astr + "\n" fi)
    +
****    (if rstr == "" then "" else "\t RuleAvoids: " + rstr + "\n" fi)
    (if rstr == "" then "" else " RuleAvoids: " + rstr + "\n" fi)
  if tm(modname,goccsT) := lookupd(pnotes,"gOccs",tm('BOOL,'true.Bool)) 
  /\ tm(modname,aoccsT) := lookupd(pnotes,"aOccs",tm('BOOL,'true.Bool)) 
  /\ tm(modname,ridsT) := lookupd(pnotes,"aRules",tm('BOOL,'true.Bool)) 
  /\ gstr := printOccTL([modname],occsT2occTL(goccsT))
  /\ astr := printOccTL([modname],occsT2occTL(aoccsT))
  /\ rstr := printRidTL(qidlT2tl([modname],ridsT)) .

**** gname to be added at graph defn time
  op mkPGraphTitle : Qid Notes -> String .
  ceq mkPGraphTitle(gname,pnotes) =
       mkPGraphTitle(gname,type,user-dname)
    if ql(type name) := lookupd(pnotes,"source",ql('unknown 'unknown)) 
    /\ ql(dname user-dname) := lookupd(pnotes,"dishname",ql('unknown 'unknown)) .

  op mkPGraphTitle : Qid Qid Qid -> String .
  eq mkPGraphTitle(gname,'dishnet,dname) = "InitialNet for " + string(dname) .
  eq mkPGraphTitle(gname,'subnet,dname) =  "Subnet of " + string(dname) .
  eq mkPGraphTitle(gname,'pathnet,dname) = "Pathnet in " + string(dname) .

**** gname to be added at graph defn time
  op mkXGraphTitle : Qid Qid Qid -> String .
  eq mkXGraphTitle(gname,'tkb,kbname) = "Exploring in KB " + string(kbname) .
  eq mkXGraphTitle(gname,'pnet,dname) =
          "Exploring in InitialNet " + string(dname) .

  op mkQueryGNotes : Notes -> Notes .
  ceq mkQueryGNotes(pnotes) =
       (("gOccs" := sv(printOccTL([modname],occsT2occTL(goccsT)))),
        ("aOccs" := sv(printOccTL([modname],occsT2occTL(aoccsT)))),
        ("aRules" := sv(printRidTL(qidlT2tl([modname],ridsT)))),
        ("unRchGoals" := sv(printOccTL([modname],occsT2occTL(uoccsT))))
       )
  if tm(modname,goccsT) := lookupd(pnotes,"gOccs",tm('BOOL,'true.Bool)) 
  /\ tm(modname,aoccsT) := lookupd(pnotes,"aOccs",tm('BOOL,'true.Bool)) 
  /\ tm(modname,ridsT) := lookupd(pnotes,"aRules",tm('BOOL,'true.Bool)) 
  /\ tm(modname,uoccsT) := lookupd(pnotes,"unRchGoals",tm(modname,'none.Occs)) .

endfm

***(
pnet graph title:  
 Initial Net Graph gname  for user-dname
 Subnet Graph gname for user-dname

Pnet Graph info
    goals avoids hides -- strings -- if non-empty
    source string "pnet foo"
    
XNet Graph info
   source "tkb bar", "pnet foo"

info cmd -- show history


)
**** loadmaude loaded aux-status.maude
fmod STATUS-AUX is 
  inc GRAPH .
  inc QSTNOTES .
  inc MY-META-ALL .

var n nodeId : Nat .
vars type nid qid : Qid .
vars toks toks' : QidList .
var ?graph : Graph .
vars notes notes' : Notes .
vars id status : String .
vars nds nds' ndl ndl' nodes : NodeList .
var edl : EdgeList .
var occTL : TermList .

******************************************************************************
  op initNodeLAtts : NodeList TermList NodeList -> NodeList .
  op initNotesStatus : Notes TermList -> Notes .

  eq initNodeLAtts(nil,occTL,ndl') = ndl' .
  eq initNodeLAtts(nd(nodeId,notes) ndl,occTL,ndl') =
       initNodeLAtts(ndl,occTL,ndl' nd(nodeId,initNotesStatus(notes,occTL))) .

  eq initNotesStatus(notes,occTL) =
      insert("status",sv("none"),
         (if lookupd(notes,"type",sv("")) == sv("occ") 
             and eltOf(tvalTerm(lookupd(notes,"occ",tm('BOOL,'true.Bool))),
                       occTL)
          then insert("init",sv("true"),notes)
          else notes fi)) .

  op setNodesGoalStatus : NodeList TermList NodeList -> NodeList .
  op setNotesGoalStatus : Notes TermList -> Notes .

  eq setNodesGoalStatus(nil,occTL,ndl') = ndl' .
  eq setNodesGoalStatus(nd(nodeId,notes) ndl,occTL,ndl') =
      setNodesGoalStatus(ndl,occTL,
          ndl' nd(nodeId,setNotesGoalStatus(notes,occTL))) .

  eq setNotesGoalStatus(notes,occTL) =
        (if lookupd(notes,"type",sv("")) == sv("occ") 
            and eltOf(tvalTerm(lookupd(notes,"occ",tm('BOOL,'true.Bool))),
                       occTL)
         then insert("status",sv("goal"),notes)
         else notes fi) .



**** toks are alternating pairs (nid flag)
  sorts Selection SelectionList .
  subsort Selection < SelectionList .
  op (_`,_) : Nat String -> Selection .
  op nil : -> SelectionList .
  op __ : SelectionList SelectionList -> SelectionList [ctor assoc id: nil] .

  var  selects : SelectionList .
  op toks2sel : QidList SelectionList -> SelectionList .
  eq toks2sel( nid qid toks, selects) =
        (if (rat(string(nid),10) :: Nat)
         then toks2sel(toks,selects (rat(string(nid),10), string(qid)))
         else toks2sel(toks, selects)
         fi ) .
  eq toks2sel(toks, selects) = selects [owise] . *** not two left


**** assume (nid status) --- complete status setting
  op setGraphStatus : Graph QidList -> Graph .
  eq setGraphStatus(graph(id,notes,ndl,edl),toks) = 
       graph(id,notes,setNodeLStatus(ndl,toks2sel(toks,nil),nil),edl) .


  op setNodeLStatus : NodeList SelectionList NodeList -> NodeList .
  eq setNodeLStatus(nds' nd(nodeId,notes) nds, (nodeId, status) selects,ndl) =
        setNodeLStatus(nds' nds, selects,
                       ndl nd(nodeId,setNotesStatus(notes,status))) .
  eq setNodeLStatus(nds,(nodeId, status) selects,ndl) = 
         setNodeLStatus(nds, selects,ndl) .  *** no such node 
  eq setNodeLStatus(nds,nil,ndl) = ndl nds .

  op setNotesStatus : Notes String -> Notes .
  eq setNotesStatus(notes,status) =
      (if statusAllowed(notes,status)
       then insert("status", sv(status), notes)
       else notes fi) .

  op statusAllowed : Notes String -> Bool .
  eq statusAllowed(notes, status) =
     (if status == "none" 
      then true
      else (if lookupd(notes,"type",sv("")) == sv("rule")
            then status == "avoid"
            else (lookupd(notes,"type",sv("")) == sv("occ")
****                     and lookupd(notes,"init",sv("false")) == sv("false")
                     and (status == "goal" or status == "avoid"))
            fi )
     fi ) .

**** true ~ set if occ and not init,  false ~ unset if occ and non init and goal
  op setGraphGoals : Graph QidList -> Graph .
  op setNodeLGoals : NodeList SelectionList NodeList -> NodeList .
  op setNotesGoal : Notes String -> Notes .

  eq setGraphGoals(graph(id,notes,ndl,edl),toks) = 
       graph(id,notes,setNodeLGoals(ndl,toks2sel(toks,nil),nil),edl) .
  eq setNodeLGoals(nds nd(nodeId,notes) nds', (nodeId,status) selects, ndl)
     = setNodeLGoals(nds nds',selects,
                     ndl nd(nodeId,setNotesGoal(notes,status))) .
  eq setNodeLGoals(nds,  (nodeId,status) selects, ndl) =
        setNodeLGoals(nds, selects, ndl) [owise] . **** node missing
  eq setNodeLGoals(nds, nil, ndl) = ndl nds .

  eq setNotesGoal(notes,status) = 
       (if lookupd(notes,"type",sv("")) == sv("occ")
           and lookupd(notes,"init",sv("false")) == sv("false")
        then (if status == "true"
              then insert("status", sv("goal"), notes)
              else (if lookupd(notes,"status",sv("none")) == sv("goal")
                    then insert("status", sv("none"), notes) 
                    else notes fi)
              fi)
        else notes
        fi) .


**** true ~ set if  occ and not init, false ~ unset if occ and non init and avoid
  op setGraphAvoids : Graph QidList -> Graph .
  op setNodeLAvoids : NodeList SelectionList NodeList -> NodeList .
  op setNotesAvoid : Notes String -> Notes .

  eq setGraphAvoids(graph(id,notes,ndl,edl),toks) = 
       graph(id,notes,setNodeLAvoids(ndl,toks2sel(toks,nil),nil),edl) .
  eq setNodeLAvoids(nds nd(nodeId,notes) nds', (nodeId,status) selects, ndl)
     = setNodeLAvoids(nds nds',selects,
                     ndl nd(nodeId,setNotesAvoid(notes,status))) .
  eq setNodeLAvoids(nds,  (nodeId,status) selects, ndl) =
        setNodeLAvoids(nds, selects, ndl) [owise] . **** node missing
  eq setNodeLAvoids(nds, nil, ndl) = ndl nds .

  eq setNotesAvoid(notes,status) = 
       (if lookupd(notes,"type",sv("")) == sv("occ")
           and lookupd(notes,"init",sv("false")) == sv("false")
        then (if status == "true"
              then insert("status", sv("avoid"), notes)
              else (if lookupd(notes,"status",sv("none")) == sv("avoid")
                    then insert("status", sv("none"), notes) 
                    else notes fi)
              fi)
        else notes
        fi) .

**** true ~ set if  rule, false ~ unset if rule
  op setGraphHides : Graph QidList -> Graph .
  op setNodeLHides : NodeList SelectionList NodeList -> NodeList .
  op setNotesHide : Notes String -> Notes .

  eq setGraphHides(graph(id,notes,ndl,edl),toks) = 
       graph(id,notes,setNodeLHides(ndl,toks2sel(toks,nil),nil),edl) .
  eq setNodeLHides(nds nd(nodeId,notes) nds', (nodeId,status) selects, ndl)
     = setNodeLHides(nds nds',selects,
                     ndl nd(nodeId,setNotesHide(notes,status))) .
  eq setNodeLHides(nds,  (nodeId,status) selects, ndl) =
        setNodeLHides(nds, selects, ndl) [owise] . **** node missing
  eq setNodeLHides(nds, nil, ndl) = ndl nds .

  eq setNotesHide(notes,status) = 
       (if lookupd(notes,"type",sv("")) == sv("rule")
        then (if status == "true"
              then insert("status", sv("avoid"), notes)
              else insert("status", sv("none"), notes) 
              fi)
        else notes
        fi) .

**** sets all status attributed to "none"
  op resetGraphStatus : Graph -> Graph .
  eq resetGraphStatus(graph(id,notes,ndl,edl)) = 
       graph(id,notes,
              resetNodesStatus(ndl,nil),
              edl) .

  op resetNodesStatus : NodeList NodeList -> NodeList .
  op resetNotesStatus : Notes -> Notes .
  eq resetNodesStatus(nil,nodes) = nodes .
  eq resetNodesStatus(nd(nodeId,notes) nds,nodes) = 
      resetNodesStatus(nds,
                      nodes nd(nodeId,insert("status", sv("none"), notes) )) . 


endfm
**** loadmaude loaded kbgraph-io.maude
**** saving and restoring kbgraph 
***(

(entry gval

(qidlist PLTest)

toks2
(notes
 (note kbname :=(qval PLTest))
 (note source :=(qval tkb PLTest))
 (note title :=(sval  "Graph for KB PLTest" )))

toks3
(gval(graph PLTest(notes)(
    nodelist(node 0 (notes(note chattylabel :=(sval  "Cbl-CLc" )) ...)) ..)
))
)



  ceq parseEntry('`( 'entry etype toks '`)) = 
       (if b and val? :: Val then e(etype,ids,notes,val?) else mt fi)
   if {b,'`( 'qidlist ids '`), toks1} := splitParen(toks)
   /\ {b0,toks2,toks3} := splitParen(toks1)
   /\ notes := (if b0 then parseNotes(toks2) else mt fi)
   /\ val? := (if b then parseVal(toks3) else undefined fi) .

saving KB should produce
(kbgval 
  (kbgraph kbname modname (kbnodes 
     (kbnd nid (occ occql ) )
     (kbnd nid (rule ridT) (pre ... ) (post ...)) )
)
 )


)


fmod KBGVAL-IO is
  inc GVAL-IO .
  inc PNTL2GRAPH .

  vars edl iedl oedl bedl : EdgeList .
  vars ndl nds : NodeList .
  vars nid rid kbname modname : Qid .
  vars qidl qidl0 qidl1 toks0 toks1 : QidList .
  var notes : Notes .
  var nodeId : Nat .
  vars inl onl bnl : NatList .
  var ridT t : Term .
  var graph : Graph .
  var id prestr poststr : String .
  var b : Bool .
  vars res?? res1?? : [ResultPair?] .

  op showKBGVal : Qid GVal -> QidList  .
  eq showKBGVal(modname,gv(graph)) = 
       '`( 'kbgval '\n showKBGraph(modname,graph) '`) .
  eq parseVal( '`( 'kbgval qidl '`) ) = gv(parseKBGraph(qidl)) .

  op showKBGraph : Qid Graph -> QidList  .
  eq showKBGraph(modname, graph(id,notes,ndl,edl)) =
      '`( 'kbgraph qid(id) modname '`( 'kbnodes '\n showKBNodes(ndl) '`) '`) .

  op showKBNodes : NodeList -> QidList .
  eq showKBNodes(nil) = nil .
  eq showKBNodes(nd(nodeId,notes) ndl) = 
      '`( 'kbnd qid(string(nodeId,10)) showKBNotes(notes) '`) '\n
       showKBNodes(ndl) .

  op showKBNotes : Notes -> QidList .
  ceq showKBNotes((notes, "type" := sv("occ") )) =  '`( 'occ  qidl '`)
  if tm(modname,t) := lookupd(notes,"occ",tm('BOOL,'true.Bool)) 
  /\ qidl := (if modname == 'BOOL 
              then nil 
              else metaPrettyPrint([modname],t) 
              fi) .

  ceq showKBNotes((notes, "type" := sv("rule") )) = 
        '`( 'rule qidl '`) 
       '`( 'pre str2qidl(prestr) '`) '`( 'post str2qidl(poststr)  '`)  
  if tm(modname,t) := lookupd(notes,"rule",tm('BOOL,'true.Bool))  
  /\ qidl := (if modname == 'BOOL 
              then nil 
              else metaPrettyPrint([modname],t) 
              fi) 
  /\ sv(prestr) := lookupd(notes, "pre", sv(""))
  /\ sv(poststr) := lookupd(notes, "post", sv("")) .

  eq showKBNotes(notes) = nil [owise] .

  op parseKBGraph : QidList -> Graph .
  eq parseKBGraph('`( 'kbgraph kbname modname '`( 'kbnodes qidl '`) '`)) =
     parseKBNodes(kbname,modname,mt,nil,nil,qidl) .

   eq parseKBGraph(qidl) = mtGraph [owise] .

  op parseKBNodes : Qid Qid Notes NodeList EdgeList QidList -> Graph .
  op parseKBNode : Qid Qid Notes NodeList EdgeList QidList QidList -> Graph .
  
  ceq parseKBNodes(kbname,modname,notes,ndl,edl,qidl) =
        (if b 
         then parseKBNode(kbname,modname,notes,ndl,edl,toks1,toks0) 
         else  graph(string(kbname), notes, ndl, edl)
         fi) 
      if {b,toks0,toks1} := splitParen(qidl) .

  ceq parseKBNode(kbname,modname,notes,ndl,edl,toks1,
             '`( 'kbnd nid '`( 'occ qidl '`) '`) ) =
       parseKBNodes(kbname,modname,notes,ndl nds,edl,toks1)
  if res?? := metaParse([modname],qidl,'Occ)
  /\ res1?? := (if res?? :: ResultPair 
                then metaReduce([modname],getTerm(res??))
                else res?? fi)
  /\ nodeId := rat(string(nid),10) 
  /\ nds := (if res1?? :: ResultPair and nodeId :: Nat
             then mkONode(modname,getTerm(res1??),nodeId)
             else nil
             fi) .


  ceq parseKBNode(kbname,modname,notes,ndl,edl,toks1,
  '`( 'kbnd nid '`( 'rule rid '`) '`( 'pre qidl0 '`) '`( 'post qidl1 '`) '`) ) =
       parseKBNodes(kbname,modname,notes,ndl nds,bedl,toks1)
  if  res?? := metaParse([modname],rid,'Qid)
**** ridT := mkQidConst(rid)
  /\ nodeId := rat(string(nid),10) 
  /\ nds := (if res?? :: ResultPair and nodeId :: Nat
             then mkRNode(modname,getTerm(res??),nodeId,
                          qidl2str(qidl0),qidl2str(qidl1))
             else nil
             fi) 
  /\ inl := qidl2natl(lDiff(qidl0, qidl1))
  /\ onl := qidl2natl(lDiff(qidl1, qidl0))
  /\ bnl := qidl2natl(lDiff(qidl0, lDiff(qidl0, qidl1)))
  /\ iedl := mkIedges(inl,nodeId,edl)
  /\ oedl := mkOedges(onl,nodeId,iedl)
  /\ bedl := mkBedges(bnl,nodeId,oedl)
.
  
endfm


***(
in PLTest
maude load-pl
load ../PLA.ibgraph-io.maude
load test-pla.maude
)
**** loadmaude loaded pla-kb.maude
******************************************************************************
*** PLA based on IMaude
******************************************************************************
mod PLA-KB is
  inc RFE  .   *** rewriter + filemanager
  inc PLA-AUX .

  inc PL2TLT .
****  inc PNTL2GRAPH .
  inc KBGVAL-IO .
  inc NEW-GRAPH2G2D .

---var
******************************************************************************
*** Variables
******************************************************************************
var ctl : Control .
var wait4s : Wait4Set .
vars reqQ reqQ' reqQ0 reqQ1 : RequestQ .
vars es es' : ESet .
var ee : Entry .
var ee? : Entry? .
var log : Log .

var n : Nat .
vars mname g2dname g2dvname kbname modname restore? save? : Qid .
vars type tkbFname occsFname graphFname user-dname : Qid .
vars outQ toks toks' qidl : QidList .
var ?graph : Graph .
vars pntlT occsT : Term .
vars res0?? res1?? res?? : [ResultPair?] .
vars pnotes gnotes notes : Notes .
var ndl : NodeList .
var edl : EdgeList .
var id ?string : String .



******************************************************************************
**** KB management initKBnet
******************************************************************************
  eq isReq('initKBnet) = true .
  eq enabled(wait4s,req('initKBnet,ql(kbname modname toks),reqQ)) = true .

rl[initKBnet]:
   [nil,  
    st(processing(req('initKBnet, ql(kbname modname toks),reqQ0)), 
       wait4s,reqQ,es,log), 
   outQ] 
  =>
   [nil,
    st(ready, wait4s, (reqQ reqQ0), initKBnet(es,kbname,modname), log), 
    outQ] .

op initKBnet : ESet Qid Qid -> ESet .
ceq initKBnet(es,kbname,modname) =
        addEntry(es,'tval,'tkb kbname, pnotes, tm(modname,pntlT))
  if pntlT := pl2tlt(modname)
  /\ pnotes :=  ("source" := ql('rules modname))
   .


******************************************************************************
**** KB management initKBgraph
******************************************************************************
  eq isReq('initKBgraph) = true .
  eq enabled(wait4s,req('initKBgraph,ql(kbname toks),reqQ)) = true .

rl[initKBgraph]:
   [nil,  
    st(processing(req('initKBgraph, ql(kbname toks),reqQ0)), 
       wait4s,reqQ,es,log), 
   outQ] 
  =>
   [nil,
    st(ready, wait4s, (reqQ reqQ0), initKBgraph(es,kbname), log), 
    outQ] .

op initKBgraph : ESet Qid -> ESet .
ceq initKBgraph(es,kbname) =
     addEntry(
      addEntry(updateNotes(es,'tval, 'tkb kbname,
                             insert("graph",ql(kbname), 
                                     getNotes(es,'tval, 'tkb kbname))),
               'gval,kbname, gnotes, gv(graph(string(kbname),mt,ndl,edl))),
             'qval,'knownKBs,ql(qidl kbname))
  if tm(modname,pntlT) := getVal(es,'tval,'tkb kbname, dumTv)
  /\ ql(qidl) := getVal(es,'qval,'knownKBs,ql(nil))
  /\ graph(id,notes,ndl,edl) := 
          (if modname == 'BOOL
           then mtGraph
           else pntl2graph([modname],pntlT2pntTL(pntlT),nil)
           fi)
  /\ gnotes := (("source" := ql('tkb kbname)), 
                ("kbname" := ql(kbname)))  .


******************************************************************************
**** KB management initKB ~ initKBnet ; initKBGraph
******************************************************************************
  eq isReq('initKB) = true .
  eq enabled(wait4s,req('initKB,ql(kbname modname toks),reqQ)) = true .

rl[initKB]:
   [nil,  
    st(processing(req('initKB, ql(kbname modname toks),reqQ0)), 
       wait4s,reqQ,es,log), 
   outQ] 
  =>
   [nil,
    st(ready,
       wait4s, 
       (reqQ req('initKBnet,ql(kbname modname),
                 req('initKBgraph,ql(kbname),reqQ0))),
       es,
       log), 
    outQ] .


******************************************************************************
***  KB management 
**** defineKBGraph send kb node info to viewer g2d
******************************************************************************

  eq isReq('defineKBGraph) = true .
****                                      what   where   
  eq enabled(wait4s,req('defineKBGraph,ql(kbname g2dvname toks),reqQ)) = 
      not(waiting4(wait4s,g2dvname)) .

  crl[defineKBGraph]:
   [nil,
    st(processing(req('defineKBGraph, ql(kbname g2dvname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
       (wait4s !
         wait4(g2dvname,kbname,
               req('logreq,ql('defineKBGraph kbname g2dvname),reqQ'))), 
       reqQ,
       es,
       log), outQ 
     g2dvname '\n mname '\n toks' maudePrompt ]
   if gv(?graph) := getVal(es,'gval,kbname,gv(mtGraph)) 
   /\ mname :=  getMaudeName(es)
   /\ ?string :=
        withAck((if (graphNodes(?graph) == nil)
                   then "(apply displayMessage \"Alert\" \"Empty Graph\")"
                   else mkdefKBGraphExp(kbname,graphNodes(?graph)) 
                   fi), mname,g2dvname) 
   /\ toks' := str2toks(?string) .

******************************************************************************
**** KB management saveKB, restoreKB
**** default filenames  <kbname>-tkb.txt <kbname>-occs.txt  <kbname>-graph.txt
**** use filemanager services
****  (save fname entry etype ids)
****  (restore fname vname stype)
******************************************************************************

  op mkKBFileName : Qid Qid -> Qid .
  eq mkKBFileName(kbname,type) = 
        qid(string(kbname) + "-" + string(type) + ".txt") .

**** save graph in reduced form
  eq isReq('saveKBG) = true .
  eq enabled(wait4s,
             req('saveKBG,ql(kbname modname graphFname toks),reqQ)) = true .
  crl[saveKBG]:
   [nil,  
    st(processing(req('saveKBG, ql(kbname modname graphFname toks),reqQ0)), 
       wait4s,reqQ,es,log), 
   outQ] 
  =>
   [nil,
    st(ready, wait4s, (reqQ reqQ1), es, log), 
    outQ] 
  if qidl := 
     '`( 'entry 'gval '`( 'qidlist kbname '`) '\n
           showNotes(getNotes(es,'gval,kbname)) '\n
           showKBGVal(modname,getVal(es,'gval,kbname,gv(mtGraph))) '`)
  /\ reqQ1 := req('filewrite,ql(graphFname 'C qidl), 
                   req('logreq,ql('saveKBG graphFname 'C kbname modname), 
                       reqQ0)) .

  eq isReq('saveKB) = true .
  eq enabled(wait4s,req('saveKB,ql(kbname toks),reqQ)) = true .
  crl[saveKB]:
   [nil,  
    st(processing(req('saveKB, ql(kbname toks),reqQ0)), 
       wait4s,reqQ,es,log), 
   outQ] 
  =>
   [nil,
    st(ready, wait4s, (reqQ reqQ1), es, log), 
    outQ] 
  if tkbFname := mkKBFileName(getNth(0,toks,kbname),'tkb)
  /\ graphFname := mkKBFileName(getNth(0,toks,kbname),'graph) 
  /\ tm(modname,pntlT) := getVal(es,'tval,'tkb kbname, tm('BOOL,'true.Bool))
  /\ reqQ1 :=  (if modname == 'BOOL
                then reqQ0   *** no kb
                else  req('save,ql(tkbFname 'C 'entry 'tval 'tkb kbname), 
                           req('saveKBG,ql(kbname modname graphFname), reqQ0) ) 
                fi)  .

  eq isReq('restoreKB) = true .
  eq enabled(wait4s,req('restoreKB,ql(kbname toks),reqQ)) = true .

  crl[restoreKB]:
   [nil,  
    st(processing(req('restoreKB, ql(kbname toks),reqQ0)), 
       wait4s,reqQ,es,log), 
   outQ] 
  =>
   [nil,
    st(ready, wait4s, (reqQ reqQ1), es, log), 
    outQ] 
  if tkbFname := mkKBFileName(getNth(0,toks,kbname),'tkb)
  /\ graphFname := mkKBFileName(getNth(0,toks,kbname),'graph) 
  /\ reqQ1 := req('restore,ql(tkbFname 'tmp 'entry), 
                  req('restore,ql(graphFname 'tmp 'entry), 
                    reqQ0))
   .

endm
**** loadmaude loaded pla-dish.maude
******************************************************************************
*** PLA based on IMaude
******************************************************************************
mod PLA-DISH is

  inc RFE .
  inc PLA-AUX .
  inc META-PETRI .
  inc NEW-GRAPH2G2D .

******************************************************************************
*** Variables
******************************************************************************
var ctl : Control .
var wait4s : Wait4Set .
var reqQ reqQ' reqQ0 reqQ1 : RequestQ .
vars es es' es0 : ESet .
var ee : Entry .
var ee? : Entry? .
var log : Log .

var n : Nat . var b : Bool .
vars maudename mname g2dname g2dvname kbname modname restore? save? : Qid .
vars user-dname source dname dname' newname fname ack nid sign tmp oname : Qid .
vars outQ toks toks' toks0 toks1 toks2 edit-toks args fname?  dnames : QidList .
vars t pntlT occsT occsT' occT : Term .
vars dnotes dnotes' notes  : Notes .
vars res0?? res1?? res?? : [ResultPair?] .
vars adds removes tl : TermList .
vars ndl ndl' nds : NodeList .
var edl : EdgeList .
vars id ?string str clab : String .
var ?graph : Graph .


******************************************************************************
**** using a predDefined dish, no editing
******************************************************************************

****              mod  kbnodes  occTL    occndl 
  op occTL2Nodes : Qid NodeList TermList NodeList -> NodeList .
  eq occTL2Nodes(modname,ndl,(t,tl),ndl') =
        occTL2Nodes(modname, ndl,tl,ndl' getNode(ndl,"occ",tm(modname,t))) .
  eq occTL2Nodes(modname,ndl,empty,ndl') = ndl' .

  op chatty2occsT : Qid NodeList QidList TermList  -> Term .
  eq chatty2occsT(modname,ndl, nil, tl) = occTL2occsT(tl) .
  ceq chatty2occsT(modname,ndl, oname toks, tl) = 
        chatty2occsT(modname,ndl,toks,
                     (if occT == 'none.Occs then tl else (tl,occT) fi))
    if nds := getNode(ndl,"chattylabel",sv(string(oname)))
    /\ notes := (if nds :: Node then nodeNotes(nds) else mt fi)
    /\ occT := tvalTerm(lookupd(notes,"occ",tm(modname,'none.Occs))) .

******************************************************************************
  eq isReq('predefDish) = true .
  eq enabled(wait4s,
            req('predefDish,ql(kbname user-dname newname dname toks), reqQ))
             = true .

  crl[predefDish]:
   [nil,  
    st(processing(req('predefDish, 
                      ql(kbname user-dname newname dname toks), 
                      reqQ0)), 
       wait4s,reqQ,es,log), 
   outQ] 
  =>
   [nil,
    st(ready, wait4s, (reqQ reqQ'), es', log), 
    outQ] 
  if {b,es'} := predefDish(es,kbname, user-dname, newname, dname)  
  /\ reqQ' := (if b 
               then reqQ0
               else req('logreq, ql('predefDish 'nodish 
                             kbname user-dname newname dname toks), 
                        reqQ0)
                fi)  .

  op predefDish : ESet Qid Qid Qid Qid -> BoolESet .
  ceq predefDish(es,kbname, user-dname, newname, dname) =
    {res?? :: ResultPair, 
      (if res?? :: ResultPair 
       then  addEntry(
               addEntry(es,
                       'tval, 'dish newname, dnotes, tm(modname,occsT)),
                       'qval,'knownDishes,ql(dnames newname user-dname))
       else es fi)}
  if tm(modname,pntlT) := getVal(es,'tval,'tkb kbname,tm('BOOL,'true.Bool))
  /\ res?? := metaReduce([modname], 'pl2occs[mkConst(dname,'Dish)])
  /\ occsT := (if res?? :: ResultPair then getTerm(res??) else 'none.Occs fi)
  /\ ql(dnames) := getVal(es,'qval,'knownDishes,ql(nil))
  /\ dnotes := (("source" := ql('predef dname)),
                ("kbname" := ql(kbname)),
                ("user-dname" := ql(user-dname))) .


******************************************************************************
**** Create a new dish/initial state
**** (newDish kbname  g2dvname)
****   startup dish editor scope from (fetch kbname) . occ-labs, and userdname list

******* (getDish kbname g2dvname dname)
****        get the occs, occs2labs  
****      in viewer  get dishEditor from kbname, set selection labs

******* (setDish kbname g2dvname udname toks)
****     labs to occs using graph of kbname, gen fresh dname, add dname udname to
****     knownDishes,  and add tval dish dname (modname,occsT) to env
******* (displayDish kbname g2dvname udname toks)
****     setDish; dish2pnet; pnet2graph; defineGraph; showGraph
******************************************************************************
**** newDish
******************************************************************************
  eq isReq('newDish) = true .
  eq enabled(wait4s, req('newDish,ql(kbname g2dvname toks), reqQ))
            = not(waiting4(wait4s,g2dvname)) .

  crl[newDish]:
   [nil,  
    st(processing(req('newDish, ql(kbname g2dvname toks), reqQ')), 
       wait4s,reqQ,es,log), 
   outQ] 
  =>
   [nil,
    st(ready, 
       wait4s  !
        wait4(g2dvname,nil,
              req('logreq, 
                   ql('newDish kbname g2dvname toks),reqQ')), 
       reqQ, es, log), 
    outQ  g2dvname '\n mname '\n toks' maudePrompt ]
   if mname :=  getMaudeName(es)
   /\ ?string :=
        withAck(mkNewDishExp(es,kbname), mname,g2dvname) 
   /\ toks' := str2toks(?string) .

  op newDishTemplate : -> String .
  eq newDishTemplate = "(apply initDishEditor %kbname %dishnames)" .

  op mkNewDishExp : ESet Qid  -> String .
  ceq mkNewDishExp(es,kbname) =
      fillTemplate(newDishTemplate, 
           (("%kbname" :~ squote(string(kbname))),
            ("%dishnames" :~ ?string)))
    if dnames := qvalQidList(getVal(es,'qval,'knownDishes,ql(nil)))
    /\ ?string := known2userDnameArrStr(dnames,"") .

  op known2userDnameArrStr : QidList String -> String .
  eq known2userDnameArrStr(dname user-dname toks,str) = 
       known2userDnameArrStr(toks, str + " " + squote(string(user-dname))) .
  eq known2userDnameArrStr(toks,str) = "(array java.lang.String " + str + ")" .
 
******************************************************************************
**** getDish
******************************************************************************
  eq isReq('getDish) = true .
  eq enabled(wait4s, req('getDish,ql(kbname g2dvname user-dname toks), reqQ))
            = not(waiting4(wait4s,g2dvname)) .

  crl[getDish]:
   [nil,  
    st(processing(req('getDish, ql(kbname g2dvname user-dname toks), reqQ')), 
       wait4s,reqQ,es,log), 
   outQ] 
  =>
   [nil,
    st(ready, 
       wait4s  !
        wait4(g2dvname,nil,
              req('logreq, 
                   ql('getDish kbname g2dvname user-dname toks),reqQ')), 
       reqQ, es, log), 
    outQ  g2dvname '\n mname '\n toks' maudePrompt ]
   if mname :=  getMaudeName(es)
   /\ ?string :=
        withAck(mkGetDishReplyExp(es,kbname,user-dname), mname,g2dvname) 
   /\ toks' := str2toks(?string) .

  op getDishReplyTemplate : -> String .
  eq getDishReplyTemplate = "(apply getDishReply %kbname %dishoccs)" .

  op mkGetDishReplyExp : ESet Qid Qid -> String .
  ceq mkGetDishReplyExp(es,kbname,user-dname) =
      fillTemplate(getDishReplyTemplate, 
           (("%kbname" :~ squote(string(kbname))),
            ("%dishoccs" :~ ?string)))
    if dnames := qvalQidList(getVal(es,'qval,'knownDishes,ql(nil)))
    /\ dname  := lookupDname(dnames,user-dname)
    /\ tm(modname,pntlT) := getVal(es,'tval,'tkb kbname,dumTv)
    /\ occsT := 
         (if dname == user-dname 
          then getPreDefDishOccs(es,modname,dname)
          else tvalTerm(getVal(es,'tval,'dish dname, tm(modname,'none.Occs)))
          fi) 
   /\ ndl := graphNodes(gvalGraph(getVal(es,'gval,kbname,gv(mtGraph))))
   /\ ?string := occTL2ArrExp(modname,ndl,occsT2occTL(occsT),"") .

  op getPreDefDishOccs : ESet Qid Qid -> Term .
  ceq getPreDefDishOccs(es,modname, dname) = occsT
  if res?? := metaReduce([modname], 'pl2occs[mkConst(dname,'Dish)])
  /\ occsT := (if res?? :: ResultPair then getTerm(res??) else 'none.Occs fi) .

  op lookupDname : QidList Qid -> Qid .
  eq lookupDname(dname dname' dnames, user-dname) = 
       (if user-dname == dname' 
        then dname 
        else lookupDname(dnames, user-dname) 
        fi) .
  eq lookupDname(dnames, user-dname) = 'unknown [owise] .


****               mod  kbnodes  occTL    occ-labs 
  op occTL2ArrExp : Qid NodeList TermList String -> String .
  ceq occTL2ArrExp(modname,ndl,(t,tl),str) =
        occTL2ArrExp(modname, ndl,tl, 
              str + (if clab == "" then "" else " " + squote(clab) fi))
   if nds := getNode(ndl,"occ",tm(modname,t))
   /\ sv(clab) := (if nds :: Node
                   then lookupd(nodeNotes(nds),"chattylabel",sv(""))
                   else sv("") fi) .
  eq occTL2ArrExp(modname,ndl,empty,str) = "(array java.lang.String " + str + ")" .
 
******************************************************************************
**** setDish
******************************************************************************
  eq isReq('setDish) = true .
  eq enabled(wait4s,
            req('setDish,ql(kbname user-dname newname toks), reqQ))
             = true .

  crl[setDish]:
   [nil,  
    st(processing(req('setDish, 
                      ql(kbname user-dname newname toks), 
                      reqQ0)), 
       wait4s,reqQ,es,log), 
   outQ] 
  =>
   [nil,
    st(ready, wait4s, (reqQ reqQ'), es', log), 
    outQ] 
  if {b,es'} := setDish(es,kbname, user-dname, newname, toks)  
  /\ reqQ' := (if b 
               then reqQ0
               else req('logreq, ql('setDish 'failed
                             kbname user-dname newname toks), 
                        reqQ0)
                fi)  .

****            kbname  user-dname newname 
  op setDish : ESet Qid   Qid   Qid  QidList -> BoolESet .
  ceq setDish(es,kbname, user-dname,newname,toks) =
    {b, (if b
         then addEntry(
                addEntry(es,
                        'tval, 'dish newname, dnotes, tm(modname,occsT)),
                        'qval,'knownDishes,ql(dnames newname user-dname))
       else es fi)}
   if  ql(dnames) := getVal(es,'qval,'knownDishes,ql(nil))
   /\ tm(modname,pntlT) := getVal(es,'tval,'tkb kbname,dumTv)
   /\ ndl := graphNodes(gvalGraph(getVal(es,'gval,kbname,gv(mtGraph))))
   /\ occsT := chatty2occsT(modname,ndl, toks, empty)
   /\ b := modname =/= 'BOOL and ndl =/= nil 
   /\ dnotes := (("kbname" := ql(kbname)),
                 ("user-dname" := ql(user-dname))) .



******************************************************************************
******* (displayNewDish kbname g2dvname udname toks)
****     setDish; dish2pnet; pnet2graph; defineGraph; showGraph
******************************************************************************
  eq isReq('displayNewDish) = true .
  eq enabled(wait4s,
            req('displayNewDish,ql(kbname g2dvname user-dname toks), reqQ))
             = true .

  crl[displayNewDish]:
   [nil,
    st(processing(req('displayNewDish, ql(kbname g2dvname user-dname toks), 
                       reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, incGlobalCounter(es,1), log), outQ]
   if newname := qid("dish" + getGlobalCounter(es))
   /\ reqQ0 :=
       req('setDish,ql(kbname user-dname newname toks),
         req('displayDishnet,ql(kbname g2dvname newname),     
               reqQ')) .

endm
**** loadmaude loaded pla-graph.maude
******************************************************************************
*** PLA based on IMaude
******************************************************************************
mod PLA-GRAPH is

  inc RFE .
  inc PLA-AUX .
  inc STATUS-AUX .

  inc META-PETRI .
  inc PNTL2GRAPH .
****  inc GRAPH2G2D .
  inc NEW-GRAPH2G2D .
  inc GRAPH2LOLA .


******************************************************************************
*** Variables
******************************************************************************
var ctl : Control .
var wait4s : Wait4Set .
var reqQ reqQ' reqQ0 reqQ1 reqQ2 : RequestQ .
vars es es' : ESet .
var ee : Entry .
var ee? : Entry? .
var log : Log .

vars b avoid? : Bool .
var n nodeId : Nat .
vars mname g2dname g2dvname kbname modname modname' : Qid .
vars type ptype tkbFname occsFname graphFname nid flag qid opname parent : Qid .
vars gname pname newgname newpname pathpname dname newdname user-dname : Qid .
vars outQ toks toks' rids qidl : QidList .
var ?graph : Graph .
vars pntlT pntlT' pnetT occsT ioccsT ioccsT' uoccsT roccsT nT occT : Term .
vars goccsT aoccsT ridsT ugoccsT : Term .
var tl occsTL : TermList .
vars dnotes gnotes pnotes notes : Notes .
vars res0?? res1?? res?? res2?? res3?? : [ResultPair?] .
vars id ?string status str gstr astr rstr title subtitle : String .
vars ctr  ctr1 ctr2 netStr taskStr : String .
vars ndl ndl' nds nodes pndl : NodeList .
var edl : EdgeList .
 
*** 12feb04
var requestor : Qid .

******************************************************************************
  

******************************************************************************
**** defineGraph -- as iop graph, but don't display
******************************************************************************
  eq isReq('defineGraph) = true .
****                                    where   what
  eq enabled(wait4s,req('defineGraph,ql(g2dvname gname toks),reqQ)) = 
      not(waiting4(wait4s,g2dvname)) .

  crl[defineGraph]:
   [nil,
    st(processing(req('defineGraph, ql(g2dvname gname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
       (wait4s !
         wait4(g2dvname,gname,
               req('logreq,ql('defineGraph g2dvname gname),reqQ'))), 
       reqQ,
       es,
       log), outQ 
     g2dvname '\n mname '\n toks' maudePrompt ]
   if gv(?graph) := getVal(es,'gval,gname,gv(mtGraph)) 
   /\ mname :=  getMaudeName(es)
   /\ gnotes := getNotes(es,'gval,gname)
   /\ ?string :=
        withAck((if (graphNodes(?graph) == nil)
                 then "(apply mtGraphAlert)"
**** 09oct10 to stop the progress bar when no graph is shown
*****            then "(apply displayMessage \"Alert\" \"Empty Graph\")"
                 else mkDefineNewGraphExp(gname,?graph,gnotes)
                   fi), mname,g2dvname) 
   /\ toks' := str2toks(?string) .


******************************************************************************
**** showGraph -- display an already defined  graph
******************************************************************************
  eq isReq('showGraph) = true .
****                                   where   what
  eq enabled(wait4s,req('showGraph,ql(g2dvname gname toks),reqQ)) = 
      not(waiting4(wait4s,g2dvname)) .

  crl[showGraph]:
   [nil,
    st(processing(req('showGraph, ql(g2dvname gname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   (if notes == mt or graphNodes(?graph) == nil
    then [nil,  
          st(ready,wait4s,
             reqQ  req('logreq,
                       ql('showGraph 'mtgraph g2dvname gname toks),
                       reqQ'),
              es, log),
           outQ]
    else [nil,  
          st(ready,
             wait4s !
                   wait4(g2dvname,gname,
                         req('logreq,ql('showGraph g2dvname gname toks),reqQ')),
             reqQ,
              es,
              log), outQ g2dvname '\n mname '\n toks' maudePrompt ]
    fi)
   if notes := getNotes(es,'gval,gname) 
   /\ gv(?graph) := getVal(es,'gval,gname,gv(mtGraph)) 
   /\ mname :=  getMaudeName(es)
   /\ ?string := (if graphNodes(?graph) =/= nil
                  then withAck(mkShowNewGraphExp(gname,notes), mname,g2dvname) 
                  else "" fi)
   /\ toks' := str2toks(?string) .

******************************************************************************
**** kbFixup given dishnet and its graph
**** redefines kb net to be pntl of dishnet and sets kbgraph to be its graph
******************************************************************************
  eq isReq('kbFixup) = true .
  eq enabled(wait4s, req('kbFixup,ql(kbname pname gname toks),reqQ)) 
       = true .

  rl[kbFixup]:
   [nil,
    st(processing(req('kbFixup, ql(kbname pname gname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ', kbFixup(es,kbname,pname,gname), log), outQ] .

  op kbFixup : ESet Qid Qid Qid -> ESet .
  ceq kbFixup(es,kbname,pname,gname) =
      addEntry(addEntry(es,'tval,'tkb kbname, pnotes, tm(modname,pntlT)),
              'gval,kbname, gnotes, getVal(es,'gval, gname,gv(mtGraph)))
   if tm(modname,pnetT) := getVal(es,'tval, 'pnet pname, dumTv)
   /\ pntlT := (if modname == 'BOOL 
                then 'nil.PNTransList 
                else pnetT2pntlT(pnetT) fi)
   /\ pnotes :=  (("source" := ql('pnet pname)),("graph" := ql(kbname)))
   /\ gnotes := (("source" := ql('tkb kbname)), 
                 ("kbname" := ql(kbname))) .

******************************************************************************
**** dishShortCut  assumes kb is defined, but not graph
**** makes dishnet, redefined kb to be the dishnet Pntl
**** makes graph, stores it as kbgraph and as dishnet graph
**** then display the dishnet graph
******************************************************************************
  eq isReq('dishShortCut) = true .
  eq enabled(wait4s, req('dishShortCut,ql(kbname g2dvname dname toks),reqQ)) 
       = true .

  crl[dishShortCut]:
   [nil,
    st(processing(req('dishShortCut, ql(kbname g2dvname dname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, incGlobalCounter(es,3), log), outQ]
   if ctr := getGlobalCounter(es) 
   /\ newdname := qid("dish" + ctr)
   /\ newpname := qid("pnet" + stringInc(ctr) )
   /\ newgname := qid("graph" + stringInc(stringInc(ctr)) )
   /\ reqQ0 :=
       req('predefDish,ql(kbname dname newdname dname),
         req('dish2pnet, ql(kbname newdname newpname),
           req('pnet2graph, ql(kbname newpname newgname),
             req('kbFixup, ql(kbname newpname newgname),
               req('defineGraph, ql(g2dvname newgname),
                 req('startListener, ql(newgname 'graphreq g2dvname),
                   req('showGraph, ql(g2dvname newgname),
               reqQ'))))))) .

***(seq
  (predefDish PLTest graphics2d quiz dishq quiz)
  (dish2pnet PLTest dishq pnetq)
  (pnet2graph PLTest dishnet pnetq graphq)
  (kbFixup PLTest pnetq graphq)
  (defineGraph  graphics2d graphq)
  (showGraph  graphics2d graphq)
)

******************************************************************************
****  dish2pnet --- uses
****                              Init   
****  op fwdCollect : PNTransList Occs -> PNTL3 .
****                    I^Rch I-Rch Rch    *** I-Rch = unused
****       {PNTransList Occs Occs Occs}
******************************************************************************
  eq isReq('dish2pnet) = true .
  eq enabled(wait4s, req('dish2pnet,ql(kbname dname pname toks),reqQ)) 
       = true .
  rl[dish2pnet]:
   [nil,
    st(processing(req('dish2pnet, ql(kbname dname pname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
       wait4s,
       (reqQ reqQ'),
       dish2pnet(es,kbname,dname,pname),
       log), outQ] .

  op dish2pnet : ESet Qid Qid Qid -> ESet .
  ceq dish2pnet(es,kbname,dname,pname) =
       addEntry(updateNotes(es,'tval,'dish dname,
                            insert("pnet",ql('pnet pname), dnotes)),
               'tval,'pnet pname, pnotes, 
               tm(modname,'pnet[pntlT',ioccsT]))
   if tm(modname,occsT) := getVal(es,'tval,'dish dname,tm('BOOL,'true.Bool))
   /\ dnotes := getNotes(es,'tval,'dish dname)
   /\ ql(user-dname) := lookupd(dnotes,"user-dname",ql(dname))
   /\ tm(modname',pntlT) := getVal(es,'tval, 'tkb kbname,tm('BOOL,'true.Bool))
   /\ res?? := metaReduce([modname],'fwdCollect[pntlT,occsT])
   /\ b := modname =/= 'BOOL and  modname' =/= 'BOOL and res?? :: ResultPair
   /\ '`{_`,_`,_`,_`}[pntlT',ioccsT,uoccsT,roccsT] :=
         (if b
          then getTerm(res??)
          else '`{_`,_`,_`,_`}['nil.PNTransList,'none.Occs,'none.Occs,'none.Occs]
          fi )
   /\ pnotes := (if b
                 then (("source" := ql('dishnet dname)),
							  ("requestor" := ql(kbname)),
							  ("rchOccs" := tm(modname, roccsT)),
							  ("unusedOccs" := tm(modname, uoccsT)),
							  ("dishname" := ql(dname user-dname)),
							  ("kbname" := ql(kbname)))
                 else mt
                 fi)   .

******************************************************************************
****  pnet2graph --- uses pnetT2graph which uses pntl2graph initNodeLStatus
******************************************************************************
  eq isReq('pnet2graph) = true .
  eq enabled(wait4s, req('pnet2graph,ql(kbname pname gname toks),reqQ)) 
       = true .
  rl[pnet2graph]:
   [nil,
    st(processing(req('pnet2graph, ql(kbname pname gname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
       wait4s,
       (reqQ reqQ'),
       pnet2graph(es,kbname,pname,gname),
       log), outQ] .

**** name of graph of parent -- better be visible
  op getParentG : ESet Qid -> Qid .
  ceq getParentG(es,qid) =
     (if gname == 'unknown
      then getParentG(es,
                      getNth(1,
                             qvalQidList(lookupd(getNotes(es,'tval,'pnet qid),
                                                 "source",ql('unknown 'unknown))),
                             'unknown) )
      else gname
      fi)
  if ql(gname) := lookupd(getNotes(es,'tval, 'pnet qid), "graph", ql('unknown) ) .


  op pnet2graph : ESet Qid Qid Qid -> ESet .
  ceq  pnet2graph(es,kbname,pname,gname) =
        addEntry(updateNotes(es,'tval,'pnet pname,
                             insert("graph",ql(gname), pnotes)),
                 'gval, gname, gnotes, 
                 gv(graph(string(gname),mt,ndl',edl)))
   if tm(modname,pnetT) := getVal(es,'tval,'pnet pname,tm('BOOL,'true.Bool))
   /\ pnotes := getNotes(es,'tval, 'pnet pname)
   /\ ql(ptype qid) := lookupd(pnotes,"source",ql('unknown 'unknown))
   /\ ql(requestor) := lookupd(pnotes,"requestor",ql('unknown))
   /\ gv(?graph) := getVal(es,'gval, kbname, gv(mtGraph))
   /\ b := modname =/= 'BOOL and ptype =/= 'unknown
   /\ graph(str,notes,ndl,edl) := (if b 
                                   then pnetT2graph(modname, pnetT, 
                                                    graphNodes(?graph))
                                   else mtGraph fi)
   /\ tm(modname',uoccsT) := 
           lookupd(pnotes,"unRchGoals",tm(modname,'none.Occs))
   /\ parent := (if ptype == 'dishnet 
                 then 'unknown
                 else getParentG(es,qid) fi)
   /\ gnotes :=
         (if b
          then (("source" := ql('pnet pname)),
			       ("kbname" := ql(kbname)),
		    		 ("unRchGoals" :=
					      sv(printOccTL([modname],occsT2occTL(uoccsT)))),
					 (if ptype == 'pathnet 
					  then ("lolapath" := lookupd(pnotes, "lolapath",ql(nil)))
					  else mt fi),
**** 09aug02 clt added subtitle to gatts					  
			       ("gatts" := ql('kbname 'unRchGoals 'source 'subtitle
   	                      'requestor 'requestop 'requestargs
                  			(if ptype == 'pathnet then 'lolapath else nil fi))),
			       ("oatts" := ql('init 'status)),      
             ("ratts" := ql('status 'pre 'post)),           
             ("colorFun" := sv("colorPnetNode")),   
             ("title"  := sv(mkPGraphTitle(gname,pnotes))), 
             ("subtitle" := 
                    sv(if ptype == 'subnet or ptype == 'pathnet
                       then mkGraphSubTitle(pnotes)
                       else "" fi)), 
             (if parent == 'unknown then mt else ("parent" := ql(parent)) fi),
             ("selections" := sv("true")),
             ("toolBarFun" := sv("toolBarFunPnet")),
         **** assume a pnet
             ("requestor" := ql(requestor)),
             ("requestop" := ql(ptype)),
             ("requestargs" :=
                 sv(if (ptype == 'dishnet) then getUserDName(pnotes)
                 		else mkReqArgString(modname,pnotes) fi))  
         )
          else mt
          fi) 
    /\ goccsT  := tvalTerm(lookupd(pnotes,"gOccs",tm(modname,'none.Occs)))
    /\ ndl' := (if b and  (ptype == 'subnet or ptype == 'pathnet)
                then setNodesGoalStatus(ndl,occsT2occTL(goccsT),nil)
                else ndl
                fi) .

  op getUserDName : Notes -> String .
  ceq getUserDName(notes) = string(user-dname)        
    if 
      ql(dname user-dname) := lookupd(notes,"dishname",ql('unknown 'unknown))
     .

  op mkReqArgString : Qid Notes -> String .
  ceq mkReqArgString(modname,pnotes) = 
      "goals " + printOccTL([modname],occsT2occTL(goccsT))
     + "avoids " + printOccTL([modname],occsT2occTL(aoccsT))
     + "hides " + printRidTL(qidlT2tl([modname],ridsT))
   if 
       goccsT  := tvalTerm(lookupd(pnotes,"gOccs",tm(modname,'none.Occs)))
    /\ aoccsT  := tvalTerm(lookupd(pnotes,"aOccs",tm(modname,'none.Occs)))
    /\ ridsT  := tvalTerm(lookupd(pnotes,"aRules",tm(modname,'nil.QidList)))
    .



  op pnetT2graph : Qid Term NodeList -> Graph .
  ceq pnetT2graph(modname,'pnet[pntlT,ioccsT],pndl) =
        graph(str,mt,initNodeLAtts(ndl,occsT2occTL(ioccsT),nil),edl)
  if graph(str,notes,ndl,edl) :=  
                  pntl2graph(modname,pntlT2pntTL(pntlT),pndl) .

  eq pnetT2graph(modname,pnetT,pndl) = mtGraph [owise] .  **** not a pnet

 
******************************************************************************
***** dgraph2subnet 
******************************************************************************

  eq isReq('dgraph2subnet) = true .
  eq enabled(wait4s, req('dgraph2subnet,ql(kbname gname pname toks),reqQ)) 
       = true .
  rl[dgraph2subnet]:
   [nil,
    st(processing(req('dgraph2subnet, ql(kbname gname pname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
       wait4s,
       reqQ reqQ',
       dgraph2subnet(es,kbname,gname,pname),
       log), outQ] .

  op dgraph2subnet : ESet Qid Qid Qid -> ESet .
  ceq dgraph2subnet(es,kbname,gname,pname) =
         (if res1?? :: ResultPair
          then addEntry(es,'tval,'pnet pname, pnotes, 
                            tm(modname,'pnet[pntlT',ioccsT]))
          else es fi)
**** for status annotations
   if ndl := graphNodes(gvalGraph(getVal(es,'gval,gname,gv(mtGraph))))
   /\ ql(type opname) :=
       lookupd(getNotes(es,'gval,gname),"source",ql('unknown 'unknown))
   /\ tm(modname,pnetT) := getVal(es,'tval, type opname, tm('BOOL,'true.Bool))
   /\ ql(toks') := lookupd(getNotes(es,'tval, type opname),"dishname",ql(nil))
   /\ b := modname == 'BOOL 
   /\ (goccsT, aoccsT, ridsT) := 
           (if b
            then ('none.Occs,'none.Occs, 'nil.QidList)
            else (getONodesStatus(ndl,"goal",empty),  *** goccsT 
                  getONodesStatus(ndl,"avoid",empty), *** aoccsT
                  getHiddenRuleIdsT(ndl,empty))               *** ridsT
            fi)
   /\ res?? := (if modname == 'BOOL
                then noParse(0)
                else metaReduce([modname], 
                                'relSubnet[pnetT,goccsT,aoccsT,ridsT]) 
                fi)
   /\ '`{_`,_`,_`,_`}[pntlT',ioccsT,uoccsT,roccsT] :=
        (if res?? :: ResultPair
         then getTerm(res??)
         else '`{_`,_`,_`,_`} 
                ['nil.PNTransList,'none.Occs,'none.Occs,'none.Occs]
         fi )
   /\ res1?? := (if res?? :: ResultPair
                 then metaReduce([modname],'Odiff[goccsT,roccsT])
                 else noParse(0) fi)
   /\ pnotes := (if res1?? :: ResultPair
****!!!! toks' is the dish source?
                 then (("source" := ql('subnet opname)),
                       ("requestor" := ql(gname)),
****!!!! use when displaying to alert user to problem
                       ("unRchGoals" := tm(modname,getTerm(res1??))),
                       ("gOccs" := tm(modname, goccsT) ),
                       ("aOccs" := tm(modname, aoccsT) ),
                       ("aRules" := tm(modname, ridsT) ),
                       ("rchOccs" := tm(modname, roccsT)), 
                       ("unusedOccs" := tm(modname, uoccsT)),
                       ("dishname" := ql(toks')),
                       ("kbname" := ql(kbname)))
                 else mt
                 fi) 
   .


  op getHiddenRuleIdsT : NodeList TermList -> Term .
  eq getHiddenRuleIdsT(nil,tl) = qidTL2qidlT(tl) .
  eq getHiddenRuleIdsT(nd(nodeId,notes) nds,tl) =
      getHiddenRuleIdsT(nds,
         (if lookupd(notes,"type",sv("")) == sv("rule")
             and lookupd(notes,"status",sv("none")) == sv("avoid")
          then (tl, 
                tvalTerm(lookupd(notes,"rule",tm('QID,''?.Qid)))
                )
          else tl fi) ) .
  
  op getONodesStatus :  NodeList String TermList -> Term .
  eq getONodesStatus(nil,status,occsTL) = occTL2occsT(occsTL) .
  eq getONodesStatus(nd(nodeId,notes) nds, status, occsTL) =
       getONodesStatus(nds,status,
         (occsTL, (if (lookupd(notes,"type",sv("")) == sv("occ")
                       and lookupd(notes,"status",sv("")) == sv(status)
                       and tvalTerm(lookupd(notes, "occ", 
                                    tm('BOOL,'true.Bool)))
                                 =/= 'true.Bool)
                     then tvalTerm(lookupd(notes,"occ",tm('BOOL,'true.Bool)))
                     else empty fi)) ) .

******************************************************************************
**** (dgraph2pathsubnet,ql(kbname pname gname newpname),
******************************************************************************
  eq isReq('dgraph2pathsubnet) = true .
  eq enabled(wait4s, req('dgraph2pathsubnet,
                         ql(kbname pname gname newpname toks),reqQ)) 
       = true .
  rl[dgraph2pathsubnet]:
   [nil,
    st(processing(req('dgraph2pathsubnet,
                      ql(kbname pname gname newpname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
       wait4s,
       reqQ reqQ',
       dgraph2pathsubnet(es,kbname,pname,gname,newpname),
       log), outQ] .

  op dgraph2pathsubnet : ESet Qid Qid Qid Qid -> ESet .
  ceq dgraph2pathsubnet(es,kbname,pname,gname,newpname) =
       (if res1?? :: ResultPair
        then addEntry(es,'tval,'pnet newpname, pnotes, 
                      tm(modname,'pnet[pntlT',ioccsT]))
        else es fi)
**** for status annotations
   if ndl := graphNodes(gvalGraph(getVal(es,'gval,gname,gv(mtGraph))))
   /\ goccsT := getONodesStatus(ndl,"goal",empty)
   /\ aoccsT := getONodesStatus(ndl,"avoid",empty)
   /\ ridsT :=  getHiddenRuleIdsT(ndl,empty)
   /\ tm(modname,pnetT) := 
          getVal(es,'tval,'pnet pname, tm('BOOL, 'true.Bool))
   /\ b := modname == 'BOOL
   /\ ql(toks') := lookupd(getNotes(es,'tval,'pnet pname),"dishname",ql(nil))
   /\ pntlT := (if b then 'nil.PNTransList else pnetT2pntlT(pnetT) fi)
   /\ ioccsT' := (if b then 'none.Occs else pnetT2occsT(pnetT) fi)
   /\ res?? := (if b
                then noParse(0)
                else metaReduce([modname], 
                                'omitRules['avoidOccs[pntlT,aoccsT],ridsT]) 
                fi)
   /\ pntlT' := (if res?? :: ResultPair
                 then getTerm(res??)
                 else 'nil.PNTransList
                 fi )
   /\ res0?? := (if res?? :: ResultPair
                 then metaReduce([modname], 'allOccs[pntlT'])
                 else noParse(0)
                 fi)
  /\ roccsT := (if res0?? :: ResultPair 
                 then getTerm(res0??)
                 else 'none.Occs 
                 fi)
   /\ ioccsT := getTerm(metaReduce([modname], 'Osame[ioccsT',roccsT]))
   /\ uoccsT := getTerm(metaReduce([modname], 'Odiff[ioccsT',roccsT]))
   /\ res1?? := (if res0?? :: ResultPair
                 then metaReduce([modname],'Odiff[goccsT, roccsT])
                 else noParse(0) fi)
   /\ ugoccsT := (if res1?? :: ResultPair 
                  then getTerm(res1??) 
                  else 'none.Occs 
                  fi)
   /\ pnotes :=  (("source" := ql('subnet pname)),
                  ("unRchGoals" := tm(modname, ugoccsT)),
                  ("gOccs" := tm(modname, goccsT)),
                  ("aOccs" := tm(modname, aoccsT)),
                  ("aRules" := tm(modname, ridsT)),
                  ("rchOccs" := tm(modname, roccsT)), 
                  ("unusedOccs" := tm(modname, uoccsT)),
                  (if toks' == nil then mt else ("dishname" := ql(toks')) fi),
                  ("kbname" := ql(kbname)))
      .

******************************************************************************
**** (askLola kbname pname gname pathpname)
**** assumes pname names pnet, gname has goals annotation
**** pnet may be that of graph or a reduced form with no graph
**** sends lola request and waits with lolaReply continuation
**** pathpname is to be used for pathgraph
******************************************************************************
  eq isReq('askLola) = true .
  eq enabled(wait4s,req('askLola,ql(kbname pname gname pathpname toks),reqQ)) = 
       not(waiting4(wait4s,'graphics2d)) .
****!!!! getG2dName(es)
 
crl[askLola]:
   [nil,
    st(processing(req('askLola, ql(kbname pname gname pathpname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, 
       (if ?string == ""
        then wait4s
        else (wait4s !  wait4(g2dname, 'askLola pname, 
                   creq('lolaReply,nil,ql(gname pname pathpname toks),reqQ')))
        fi), 
     (reqQ reqQ0), es, log), 
    outQ toks']
   if mname :=  getMaudeName(es)
   /\ g2dname := getG2dName(es) 
   /\  ?string := lolaReqString(es,kbname,pname,gname,mname)
   /\   toks' := (if ?string == "" 
                  then nil 
                  else g2dname '\n mname '\n str2toks(?string) maudePrompt
                  fi)
   /\ reqQ0 := (if ?string == ""
                then req('logreq,
                         ql('askLola 'failed kbname pname pathpname toks),
                     req('sendAlert,
                         ql(getG2dVName(es) 'askLola 'unable 'to 'ask), nil)) 
                else nil fi)   .


  op lolaReqString : ESet Qid Qid Qid Qid -> String .
  ceq lolaReqString(es,kbname,pname,gname,mname) =
          (if modname == 'BOOL or ?graph == mtGraph or goccsT == 'none.Occs
           then ""
           else mkLolaReq(setNodeLGOccs(ndl,occsT2occTL(goccsT),nil),
                           mname)
           fi) 
   if tm(modname,pnetT) := getVal(es,'tval,'pnet pname, tm('BOOL,'true.Bool))
   /\ gv(?graph) := getVal(es,'gval,gname,gv(mtGraph))
   /\ goccsT := getONodesStatus(graphNodes(?graph),"goal",empty)
**** reduce graph if not graph of pnet (pnet tmp subnet)
**** assume pnet is subnet of graph source
   /\ ndl := 
       graphNodes(if lookupd(getNotes(es,'gval,gname),"source", ql(nil)) 
                        == ql('pnet pname)
                  then ?graph
                  else pnetT2graph(modname,pnetT,graphNodes(?graph)) fi) .
    

  op setNodeLGOccs : NodeList TermList NodeList -> NodeList .
  eq setNodeLGOccs(nil,tl,ndl') = ndl' .
  eq setNodeLGOccs(nd(nodeId,notes) ndl,tl,ndl') = 
        setNodeLGOccs( ndl,tl,ndl' nd(nodeId,setNotesGOccs(notes,tl))) .
 
  op setNotesGOccs : Notes TermList -> Notes .
  ceq setNotesGOccs(notes,tl) =
     (if occT == 'true.Bool 
      then notes
      else (if eltOf(occT,tl)
            then insert("status",sv("goal"), notes)
            else notes
            fi)
      fi)
  if occT := (if lookupd(notes,"type",sv("")) == sv("occ")
              then tvalTerm(lookupd(notes, "occ", tm('BOOL,'true.Bool)))
              else 'true.Bool 
              fi)
  .

  op lolaReqTemplate : -> String .
  eq lolaReqTemplate = 
      "(apply lolaRequest %net %task %id %requestor)" .

  op mkLolaReq : NodeList Qid -> String .
  ceq mkLolaReq(ndl,mname) =
     fillTemplate(lolaReqTemplate,
                  (("%net" :~ squote(netStr)),
                   ("%task" :~ squote(taskStr)),
                   ("%id" :~ squote("0")),
                   ("%requestor" :~ squote(string(mname)))) ) 
  if netStr := mkLolaNetString(ndl)
  /\ taskStr := mkLolaTaskString(ndl) .
  


******************************************************************************
**** (lolaReply .... ) -- creq
**** if return code is not 0 or subnet pname does not exist then
****    just log a failure report
****    otherwise create a pathnet from the lola reply and store it
******************************************************************************
**** can not be invoked from outside!
  eq enabled(wait4s,
         creq('lolaReply,g2dname qid toks', 
              ql(gname pname pathpname toks),reqQ))
       = true .

**** qid is the lola return code
**** just the pathsubnet and store it as pathpname
crl[lolaReply]:
   [nil,
    st(processing(creq('lolaReply,g2dname qid toks',
                       ql(gname pname pathpname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, (reqQ reqQ0), es', log),
    outQ]
  if {b,es'} := processLolaReply(es,gname,pname,pathpname,qid,toks')
   /\ reqQ0 :=
         (if b
          then reqQ' 
          else req('logreq,ql('askLola 'nopath gname pname pathpname),
                 req('sendAlert,
                     ql(getG2dVName(es) 'LolaFailed 'return-code qid), nil))
          fi) .


  op processLolaReply : ESet Qid Qid Qid Qid QidList -> BoolESet . 
  ceq processLolaReply(es,gname,pname,pathpname,qid,toks) =
       {res3?? :: ResultPair,
        (if res3?? :: ResultPair
         then addEntry(es,'tval,'pnet pathpname, pnotes,
                       tm(modname,'pnet[pntlT',ioccsT']))     
         else es fi)}
  if ndl := graphNodes(gvalGraph(getVal(es,'gval, gname,gv(mtGraph))))
   /\ rids :=  **** chatty rule labels as qids
       (if qid == '0 then readLolaResult(ndl,qid toks) else nil fi)
   /\ goccsT := getONodesStatus(ndl,"goal",empty)
   /\ aoccsT := getONodesStatus(ndl,"avoid",empty)
   /\ ridsT :=  getHiddenRuleIdsT(ndl,empty)
   /\ tm(modname,pnetT) := getVal(es,'tval,'pnet pname, tm('BOOL,'true.Bool))
   /\ res?? := 
        (if modname == 'BOOL  or qid =/= '0
         then noParse(0)
         else metaReduce([modname],   
                         'getTrans[pnetT2pntlT(pnetT),qidl2qidlT(rids)])
         fi)
   /\ pntlT := (if res?? :: ResultPair 
                then getTerm(res??) 
                else 'nil.PNTransList fi)
**** eliminate junk
   /\ ioccsT := pnetT2occsT(pnetT)
   /\ res2?? := (if res?? :: ResultPair
                then metaReduce([modname],  
                                'relSubnet['pnet[pntlT,ioccsT],
                                           goccsT,'none.Occs,'nil.QidList]) 
                else  noParse(0) 
                fi)
   /\ '`{_`,_`,_`,_`}[pntlT',ioccsT',uoccsT,roccsT] :=
        (if res2?? :: ResultPair
         then getTerm(res2??)
         else '`{_`,_`,_`,_`}['nil.PNTransList,
                              'none.Occs,'none.Occs,'none.Occs]
         fi )
  /\ res3?? := (if res2?? :: ResultPair 
                then metaReduce([modname],'Odiff[goccsT,roccsT]) 
                else  noParse(0) fi)
  /\ ugoccsT := (if res3?? :: ResultPair 
                  then getTerm(res3??) 
                  else 'none.Occs fi)
  /\ ql(toks') := lookupd(getNotes(es,'tval,'pnet pname),"dishname",ql(nil))
  /\ ql(kbname) := 
         lookupd(getNotes(es,'tval,'pnet pname),"kbname",ql('unknown))
  /\ pnotes := 
      (if res3?? :: ResultPair 
       then (("source" := ql('pathnet pname)),
        	   ("requestor" := ql(gname)),
             ("unRchGoals" := tm(modname,ugoccsT)),
             ("gOccs" := tm(modname, goccsT)), 
             ("aOccs" := tm(modname, aoccsT)), 
             ("aRules" := tm(modname, ridsT)), 
             ("rchOccs" := tm(modname, roccsT)),
             ("unusedOccs" := tm(modname, uoccsT)), 
             (if toks' == nil then mt else ("dishname" := ql(toks')) fi),
             ("lolapath" := ql(rids)),
             ("kbname" := ql(kbname))  
            )
       else mt fi)  .


******************************************************************************
**** Viewer requests
******************************************************************************
**** displayPetri  
**** makes predefined dish in kb
**** continues with displayDishnet
******************************************************************************
  eq isReq('displayPetri) = true .
  eq enabled(wait4s, req('displayPetri,ql(kbname g2dvname dname toks),reqQ)) 
       = true .

  crl[displayPetri]:
   [nil,
    st(processing(req('displayPetri, ql(kbname g2dvname dname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, incGlobalCounter(es,1), log), outQ]
   if ctr := getGlobalCounter(es) 
   /\ newdname := qid("dish" + ctr)
   /\ reqQ0 :=
       req('predefDish,ql(kbname  dname newdname dname),
            req('displayDishnet,ql(kbname g2dvname newdname toks),
               reqQ')) .


******************************************************************************
**** displayPetriF  
**** makes dish from chattylabels in file in kb
**** continues with displayDishnet
******************************************************************************
  eq isReq('displayPetriF) = true .
  eq enabled(wait4s, req('displayPetri,
                         ql(kbname g2dvname user-dname occsFname toks),reqQ)) 
       = true .

  crl[displayPetriF]:
   [nil,
    st(processing(req('displayPetriF, 
                      ql(kbname g2dvname user-dname occsFname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, incGlobalCounter(es,1), log), outQ]
   if ctr := getGlobalCounter(es) 
   /\ newdname := qid("dish" + ctr)
   /\ reqQ0 :=
       req('dishFromFile,ql(kbname user-dname newdname occsFname),
            req('displayDishnet,ql(kbname g2dvname newdname toks),
               reqQ')) .


******************************************************************************
**** displayDishNet
**** makes and stores pnet for dish in kb
**** makes and stores graph
**** sends graphdescr to gdvname and starts graph listener
**** toks has fname if provided
******************************************************************************
  eq isReq('displayDishnet) = true .
  eq enabled(wait4s, req('displayDishnet,ql(kbname g2dvname dname toks),reqQ)) 
       = true .

  crl[displayDishnet]:
   [nil,
    st(processing(req('displayDishnet, ql(kbname g2dvname dname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, incGlobalCounter(es,2), log), outQ]
   if ctr := getGlobalCounter(es) 
   /\ ctr1 := stringInc(ctr) 
   /\ pname := qid("pnet" + ctr)
   /\ gname := qid("graph" + ctr1)
   /\ reqQ0 :=
       req('dish2pnet,ql(kbname dname pname),
         req('pnet2graph,ql(kbname pname gname),
           req('defineGraph,ql(g2dvname gname),
             req('startListener, ql(gname 'graphreq g2dvname),
             req('showGraph,ql(g2dvname gname toks),
               reqQ'))))) .

******************************************************************************
**** displaySubnet1  combines status setting and subnet production
**** resets graph status, sets it according to toks, and 
**** invokes displaySubnet
******************************************************************************
  eq isReq('displaySubnet1) = true .
  eq enabled(wait4s, req('displaySubnet1,ql(gname g2dvname toks),reqQ)) 
       = true .

  crl[displaySubnet1]:
   [nil,
    st(processing(req('displaySubnet1, ql(gname g2dvname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, es, log),
    outQ]
   if reqQ0 :=
        req('resetStatus,ql(gname g2dvname),
          req('setStatus,ql(gname g2dvname toks),
            req('displaySubnet,ql(gname g2dvname),
                reqQ'))) .



******************************************************************************
**** displaySubnet
**** makes and stores the relevant subnet for the pnet underlying the graph
****  with goals and avoids from graph annotations
**** makes and stores the subnet's graph
**** sends graphdescr to gdvname and starts graph listener
**** toks has fname if provided
******************************************************************************
  eq isReq('displaySubnet) = true .
  eq enabled(wait4s, req('displaySubnet,ql(gname g2dvname toks),reqQ)) 
       = true .

  crl[displaySubnet]:
   [nil,
    st(processing(req('displaySubnet, ql(gname g2dvname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, incGlobalCounter(es,2), log),
    outQ]
   if ctr := getGlobalCounter(es) 
   /\ ctr1 := stringInc(ctr) 
   /\ pname := qid("pnet" + ctr)
   /\ newgname := qid("graph" + ctr1)
   /\ kbname := getGraphKBname(es,gname,'unknown)
   /\ reqQ0 :=
      (if kbname == 'unknown
       then req('logreq,ql('displaySubnet 'unknownKB gname g2dvname toks), 
                 reqQ')
       else req('dgraph2subnet,ql(kbname gname pname),
              req('pnet2graph,ql(kbname pname newgname),
                req('defineGraph,ql(g2dvname newgname),
                 req('startListener, ql(newgname 'graphreq g2dvname),
                  req('showGraph,ql(g2dvname newgname toks),
                      reqQ'))))) 
      fi) .


******************************************************************************
**** displayPath1  combines status setting and path production
**** resets graph status, sets it according to toks, and 
**** invokes displayPath
******************************************************************************
  eq isReq('displayPath1) = true .
  eq enabled(wait4s, req('displayPath1,ql(gname g2dvname toks),reqQ)) 
       = true .

  crl[displayPath1]:
   [nil,
    st(processing(req('displayPath1, ql(gname g2dvname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, es, log),
    outQ]
   if reqQ0 :=
        req('resetStatus,ql(gname g2dvname),
          req('setStatus,ql(gname g2dvname toks),
            req('displayPath,ql(gname g2dvname),
                reqQ'))) .



******************************************************************************
**** displayPath
****  asks lola, converts result to pathnet and stores,  
****   if the graph is for a subnet and no new avoids/hides specified, 
****   use that subnet, ow generate an invisible subnet by just
****     removing occ and rule avoids, and possibly doing a forward collect. 
**** makes and stores the pathnet's graph
**** sends graphdescr to gdvname and starts graph listener
**** toks has fname if provided
******************************************************************************
  eq isReq('displayPath) = true .
  eq enabled(wait4s, req('displayPath,ql(gname g2dvname toks),reqQ)) 
       = true .

  crl[displayPath]:
   [nil,
    st(processing(req('displayPath, ql(gname g2dvname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
       wait4s,
       reqQ reqQ0,
       es',
       log), outQ]
   if gnotes := getNotes(es,'gval,gname)
   /\  ql(toks') := lookupd(gnotes,"source",ql(nil))
   /\ ql(kbname) := lookupd(gnotes,"kbname",ql('unknown))
   /\ ptype := getNth(0,toks','unknown)    
   /\ pname := getNth(1,toks','unknown) 
***   /\ pnotes := getNotes(es,'tval, ptype pname)
   /\ b := ptype =/= 'pnet or pname == 'unknown  or kbname == 'unknown
   /\ ndl := graphNodes(gvalGraph(getVal(es,'gval,gname,gv(mtGraph))))
   /\ aoccsT := getONodesStatus(ndl,"avoid",empty)
   /\ ridsT :=  getHiddenRuleIdsT(ndl,empty)
   /\ avoid? := (aoccsT =/= 'none.Occs or ridsT =/= 'nil.QidList)
   /\ ctr := getGlobalCounter(es) 
   /\ ctr1 := stringInc(ctr) 
   /\ ctr2 := stringInc(ctr1)
   /\ pathpname := qid("pnet" + ctr)
   /\ newgname := qid("graph" + ctr1)
   /\ newpname := (if avoid? then qid("pnet" + ctr2) else pname fi)
   /\ es' := incGlobalCounter(es,(if avoid? then 3 else 2 fi))
   /\ reqQ2 :=
        req('logreq, 
            ql('displayPath 'failed 'kbname kbname 'ptype ptype 'pname pname 
                gname g2dvname toks),
            reqQ')  
   /\ reqQ1 :=
          req('askLola,ql(kbname newpname gname pathpname),
            req('pnet2graph,ql(kbname pathpname newgname),
              req('defineGraph,ql(g2dvname newgname),
                 req('startListener, ql(newgname 'graphreq g2dvname),
                  req('showGraph,ql(g2dvname newgname toks),
                      reqQ'))))) 
   /\ reqQ0 :=
       (if b 
        then reqQ2
        else (if avoid?
              then req('dgraph2pathsubnet,ql(kbname pname gname newpname), 
                       reqQ1)
              else reqQ1
              fi) 
        fi) .

******************************************************************************
**** manipulating status
******************************************************************************
****  toks are (nid status)*   sets status if allowed
  eq isReq('setStatus) = true .
  eq enabled(wait4s,req('setStatus,ql(gname g2dvname toks),reqQ)) = true .

 crl[setStatus]:
   [nil,
    st(processing(req('setStatus, ql(gname g2dvname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, 
       wait4s, 
       (reqQ req('logreq,ql('setStatus qid gname toks),reqQ')), 
       (if ?graph == mtGraph
        then es
        else addEntry(es, 'gval, gname,  getNotes(es,'gval,gname), 
                      gv(setGraphStatus(?graph, toks)) )
        fi),
       log), 
    outQ]
  if gv(?graph) := getVal(es,'gval,gname,gv(mtGraph)) 
  /\ qid := (if ?graph == mtGraph then 'mtGraph else 'Ok fi) .

******************************************************************************
  eq isReq('resetStatus) = true .
  eq enabled(wait4s,req('resetStatus,ql(gname g2dname toks),reqQ)) = true .

 crl[resetStatus]:
   [nil,
    st(processing(req('resetStatus, ql(gname g2dname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, 
       wait4s, 
       (reqQ  req('logreq,ql('resetStatus gname toks),reqQ')), 
       (if ?graph == mtGraph
        then es
        else addEntry(es, 'gval, gname, getNotes(es,'gval,gname),
                      gv(resetGraphStatus(?graph)) )
        fi),
       log), 
    outQ]
  if gv(?graph) := getVal(es,'gval,gname,gv(mtGraph)) 
  /\ qid := (if ?graph == mtGraph then 'mtGraph else 'Ok fi) .


endm
**** loadmaude loaded pla-info.maude
******************************************************************************
*** PLA based on IMaude
******************************************************************************
mod PLA-INFO is
  inc RFE .
  inc PLA-AUX .
  inc STATUS-AUX .

  inc META-PETRI .
  inc PL-PRINT .

******************************************************************************
*** Variables
******************************************************************************
var ctl : Control .
var wait4s : Wait4Set .
var reqQ reqQ' reqQ0 reqQ1 reqQ2 : RequestQ .
vars es es' : ESet .
var ee : Entry .
var ee? : Entry? .
var log : Log .

var b : Bool .
var n nodeId cur : Nat .
var fres : FindResult .
vars maudename mname g2dname g2dvname kbname modname modname' : Qid .
vars type tkbFname occsFname graphFname nid flag qid clab : Qid .
vars gname pname newgname newpname pathpname dname dgname : Qid .
vars outQ toks toks' rids srctoks : QidList .
var ?graph : Graph .
vars pntlT pntlT' pnetT occsT ioccsT ioccsT' uoccsT roccsT nT occT : Term .
vars goccsT aoccsT ridsT ugoccsT : Term .
var tl occTL : TermList .
var mod : Module .
vars dnotes gnotes pnotes notes : Notes .
vars res0?? res1?? res?? res2?? res3?? : [ResultPair?] .
vars id ?string status str gstr astr rstr title subtitle : String .

vars ndl ndl' nds nodes pndl : NodeList .
var edl : EdgeList .
var rules : RuleSet .
var rule : Rule .
 
******************************************************************************
 op display2GTemplate : -> String .
  eq display2GTemplate = 
      "(apply displayMessage2G %gname %title %message)" .

  op displayTemplate : -> String .
  eq displayTemplate = 
      "(apply displayMessage %title %message)" .

******************************************************************************
**** display unused 
******************************************************************************

  eq isReq('displayUnused) = true .
  eq enabled(wait4s,req('displayUnused,ql(gname g2dvname toks),reqQ)) = 
      not(waiting4(wait4s,g2dvname))  .

 rl[displayUnused]:
   [nil,
    st(processing(req('displayUnused, ql(gname g2dvname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, 
       (wait4s ! wait4(g2dvname,gname,nil)), 
       (reqQ reqQ'),
       es, 
       log), 
    outQ
     displayUnusedToks(es,gname,g2dvname,toks)  ]  .

  op displayUnusedToks : ESet Qid Qid QidList -> QidList .
  ceq displayUnusedToks(es,gname,g2dvname,toks) = 
          g2dvname '\n mname '\n str2toks(?string)  maudePrompt
    if  gnotes := getNotes(es,'gval, gname) 
    /\ ql(srctoks) := lookupd(gnotes,"source",ql(nil))
    /\ pnotes := getNotes(es,'tval,srctoks)
    /\ tm(modname,occsT) := lookupd(pnotes,"unusedOccs", dumTv)
    /\ mname :=  getMaudeName(es)
    /\ dgname := getNth(0,toks,gname)
    /\ ?string := 
         (if modname == 'BOOL
          then ""
          else withAck(fillTemplate(display2GTemplate,
                   (("%gname" :~ squote(string(dgname))),
                     ("%title" :~ squote("Unused in " + string(gname))),
                     ("%message" :~ 
                      squote(printLnOccTL([modname],
                                          occsT2occTL(occsT))))) ),
                   mname,g2dvname)
          fi) 
    .
   

  op printLnOccTL : Module TermList -> String .
  eq printLnOccTL(mod,empty) = "" .
  eq printLnOccTL(mod,(occT, occTL)) = 
      occ2label(mod,occT) + "\n" + printLnOccTL(mod,occTL)
     .
     

******************************************************************************
  op display2GMaudeRule : ESet Qid Qid QidList -> String .
  ceq display2GMaudeRule(es,gname,clab,toks) = 
         fillTemplate(display2GTemplate,
              (("%gname" :~ squote(string(dgname))),
                ("%title" :~ squote(title)),
                ("%message" :~ squote(?string))))
    if dgname := getNth(0,toks,gname)
    /\ gnotes := getNotes(es,'gval,gname)
    /\ ql(kbname) := lookupd(gnotes,"kbname",ql(nil))
    /\ tm(modname,pntlT) := getVal(es,'tval,'tkb kbname,dumTv)
    /\ str := string(clab)
    /\ rules :=   getRule(upRls(modname,true), pnRidStr2Rid(str)) 
    /\ title := "Maude rule " +
                 (if rules :: Rule then string(getRuleId(rules)) else "" fi)
    /\ ?string := 
     (if rules :: Rule then rule2string([modname], rules) else "not found" fi) .

  op pnRidStr2Rid : String -> Qid .
  ceq pnRidStr2Rid(str) = 
          qid(if fres :: Nat then substr(str,0,fres) else str fi)  
    if  fres := rfind(str, PNRidSuffix, length(str)) .


  op rule2string : Module Rule -> String .
  eq rule2string(mod,rule) = 
    "\n rl[" + string(getRuleId(rule)) + "]: \n  "
       + removeBQs(qidl2str(metaPrettyPrint(mod,getLhs(rule),mixfix flat)),0,"")
       + "\n => \n  "
       + removeBQs(qidl2str(metaPrettyPrint(mod,getRhs(rule),mixfix flat)),0,"")
       + " . \n"
    .

  eq isReq('display-maude-rule) = true .
  eq enabled(wait4s,req('display-maude-rule,ql(gname g2dvname clab toks),reqQ))
      = not(waiting4(wait4s,g2dvname))  .


crl[display-maude-rule]:
   [nil,
    st(processing(req('display-maude-rule, ql(gname g2dvname clab toks), 
                      reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
      (wait4s ! wait4(g2dvname, nil, 
                      req('logreq,ql('display-maude-rule gname clab),reqQ'))),
       reqQ, 
       es,
       log), outQ 
     g2dvname '\n mname '\n toks' maudePrompt ]
    if  mname :=  getMaudeName(es)
    /\ ?string :=
          withAck(display2GMaudeRule(es,gname,clab,toks), mname, g2dvname) 
    /\  toks' := str2toks(?string) 
    .

endm


**** loadmaude loaded pla-infox.maude
******************************************************************************
*** PLA based on IMaude
******************************************************************************
mod PLA-INFOX is
  inc PLA-INFO .
  inc GRAPH-INFO .
  inc SPLIT-PAREN .

***  inc PNTL2GRAPH .
***  inc GRAPH2G2D .
***  inc GRAPH2LOLA .

******************************************************************************
*** Variables
******************************************************************************
var ctl : Control .
var wait4s : Wait4Set .
var reqQ reqQ' reqQ0 reqQ1 reqQ2 : RequestQ .
vars es es' : ESet .
var ee : Entry .
var ee? : Entry? .
var log : Log .

var toks toks' htoks outQ : QidList .
vars gname mname kbname clab modname g2dvname dgname  : Qid .
vars funName ptype pname : Qid .
vars gnotes pnotes : Notes .
var b : Bool .
vars nodes nodes' : NodeList .
var occT : Term .
vars str ?string : String .
var fres : FindResult .
var ispec : Sexp .

******************************************************************************
**** Component Info
******************************************************************************
  op displayComponentInfo : ESet Qid Qid QidList -> String .
  ceq displayComponentInfo(es,gname,clab,toks) = 
      (if modname == 'BOOL 
**** 09nov08
****   or tl:TermList == empty
       or not(tl:TermList :: Term)
       then "(apply displayMessage \"Component Info Error\"  \"No Info for "
               + string(clab) + "\")" 
****       else mkComponentInfoExp(dgname,modname,tl:TermList)
       else mkComponentInfoExpX(ispec,gname,modname,clab,tl:TermList)
       fi) 
    if dgname := getNth(0,toks,gname)
    /\ nodes := graphNodes(gvalGraph(getVal(es,'gval,gname,gv(mtGraph))))
    /\ nodes' := getNode(nodes,"chattylabel",sv(string(clab)))
    /\ tm(modname,occT) :=
        (if nodes' :: Node
         then lookupd(nodeNotes(nodes'),"occ",dumTv)
         else dumTv
         fi)
    /\ tl:TermList := (if modname == 'BOOL then empty else occT2thT(occT) fi)
    /\ sxv(ispec) := getVal(es,'sxval,'ComponentInfoSpec,sxv([nil]))
   .

eq isReq('displayComponentInfo) = true .
eq enabled(wait4s,req('displayComponentInfo,ql(gname g2dvname clab toks),reqQ))
      = not(waiting4(wait4s,g2dvname))  .


crl[displayComponentInfo]:
   [nil,
    st(processing(req('displayComponentInfo, ql(gname g2dvname clab toks), 
                      reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
      (wait4s ! wait4(g2dvname, nil, 
                   req('logreq,ql('displayComponentInfo gname clab toks),reqQ'))),
       reqQ, 
       es,
       log), outQ 
     g2dvname '\n mname '\n toks' maudePrompt ]
    if  mname :=  getMaudeName(es)
    /\ ?string :=
          withAck(displayComponentInfo(es,gname,clab,toks), mname, g2dvname) 
    /\  toks' := str2toks(?string) 
    .

******************************************************************************
******************************************************************************
  op displayRuleEvidence : ESet Qid Qid QidList -> String .
  ceq displayRuleEvidence(es,gname,clab,toks) = 
      (if toks == 'unknown 
       then "(apply displayMessage \"Rule Evidence Error\"  \"No rule "
               + string(clab) + "\")" 
       else mkRuleEvidenceExp(dgname,clab,toks')
       fi) 
    if ql(kbname) := lookupd(getNotes(es,'gval,gname),"kbname",ql('unknown))
    /\ ql(toks') :=
           lookupd(getNotes(es,'qval,kbname),pnRid2RidStr(clab),ql('unknown))
    /\ dgname := getNth(0,toks,gname) .

  op pnRid2RidStr : Qid -> String .
  ceq pnRid2RidStr(clab) = 
          (if fres :: Nat then substr(str,0,fres) else str fi)  
    if  str := string(clab)
    /\ fres := rfind(str, PNRidSuffix, length(str)) .


eq isReq('displayRuleEvidence) = true .
eq enabled(wait4s,req('displayRuleEvidence,ql(gname g2dvname clab toks),reqQ))
      = not(waiting4(wait4s,g2dvname))  .


crl[displayRuleEvidence]:
   [nil,
    st(processing(req('displayRuleEvidence, ql(gname g2dvname clab toks), 
                      reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
      (wait4s ! wait4(g2dvname, nil, 
                 req('logreq,ql('displayRuleEvidence gname clab toks),reqQ'))),
       reqQ, 
       es,
       log), outQ 
     g2dvname '\n mname '\n toks' maudePrompt ]
    if  mname :=  getMaudeName(es)
    /\ ?string :=
          withAck(displayRuleEvidence(es,gname,clab,toks), mname, g2dvname) 
    /\  toks' := str2toks(?string) 
    .

*****************************************************************************
**** printing history 
*****************************************************************************
eq isReq('printHistory) = true .
eq enabled(wait4s,req('printHistory,ql(gname g2dvname funName toks),reqQ))
      = not(waiting4(wait4s,g2dvname))  .


crl[printHistory]:
   [nil,
    st(processing(req('printHistory, ql(gname g2dvname funName toks), 
                      reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
      (wait4s ! wait4(g2dvname, nil, 
                 req('logreq,ql('printHistory gname funName toks),reqQ'))),
       reqQ, 
       es,
       log), outQ 
     g2dvname '\n mname '\n toks' maudePrompt ]
    if  mname :=  getMaudeName(es)
    /\ ?string :=
          withAck(printHistory(es,gname,funName), mname, g2dvname) 
    /\  toks' := str2toks(?string) 
    .

op history2string : QidList String -> String .  
op printHistory : ESet Qid Qid -> String .  

ceq history2string(htoks,str) =
  (if b
   then history2string(toks',
                       str + " ( " + removeBQs(qidl2str(toks),0,"")  +  " )\n")
   else str                       
  fi)
if {b,'`( toks '`), toks'} := splitParen(htoks) .

eq history2string(htoks,str) = str [owise] .

ceq printHistory(es,gname,funName) =
   "(apply " + string(funName) + " "  + squote(string(gname)) + " " 
   + squote(history2string(htoks,"")) + ")"
if gnotes := getNotes(es,'gval,gname) 
**** 'xnet xname
/\ ql(ptype pname) := lookupd(gnotes,"source", ql('unknown 'unknown))
/\ pnotes := getNotes(es,'tval, ptype pname)
/\ ql(htoks) := lookupd(pnotes,"history", ql(nil)) 
.

endm

**** loadmaude loaded pla-explore.maude
******************************************************************************
*** PLA based on IMaude
***  exploring upstream downstream from a focus set incrementally
******************************************************************************
mod PLA-EXPLORE is

  inc RFE .
  inc PLA-AUX .
  inc STATUS-AUX .

  inc META-PETRI .
  inc PNTL2GRAPH .
****  inc GRAPH2G2D .
  inc NEW-GRAPH2G2D .
  inc PLA-GRAPH .
***  inc GRAPH2LOLA .


******************************************************************************
*** Variables
******************************************************************************
var ctl : Control .
var wait4s : Wait4Set .
var reqQ reqQ' reqQ0 reqQ1 reqQ2 : RequestQ .
vars es es' : ESet .
var ee : Entry .
var ee? : Entry? .
var log : Log .

var b b0 bad : Bool .
var n nodeId srcId tgtId : Nat .  var ns : NatList .
vars  mname g2dname g2dvname kbname modname modname' : Qid .
vars type  nid flag qid dir nq new? xop replyfor rid : Qid .
vars gname sgname sname pname newgname xgname xname newxname  xkbname : Qid .
vars outQ toks toks' rids history rtoks otoks : QidList .
var ?graph ?graph' graph kbgraph ograph : Graph .
vars pntlT pntlT' sntlT xnetT pnetT occsT ioccsT ioccsT' ooccsT roccsT : Term . 
vars nT ridT occT term : Term .
vars soccsT doccsT uoccsT boccsT : Term .
vars ridsT soccsT' doccsT' uoccsT' boccsT' : Term .
vars scopeT hiddenT newnetT xstateT xstateT' : Term .
vars tl occTL pntTL : TermList .
vars soccTL uoccTL doccTL boccTL : TermList .
vars res0?? res1?? res?? res2?? res3?? : [ResultPair?] .
vars id ?string status str gstr astr rstr title subtitle : String .
vars ctr  ctr1 ctr2  ntype update? occArrStr optArrStr : String .
var val : Val .
vars  gnotes gnotes' pnotes pnotes' xnotes xnotes' notes notes'  : Notes .
vars ndl ndl' nds nodes nodes' ondl ondl' pndl sndl sndl' : NodeList .
vars rnodes inodes onodes bnodes  inodes' onodes' bnodes'  : NodeList .
vars node node' : Node .
var edl oedl oedl' edl' ieds oeds beds : EdgeList .
var mod : Module . 
var bindings : TBinds .
  
******************************************************************************
**** Incremental exploration of net
**** Initiate with gname and initial occs
**** Pnet trans underlying gname is scope for finding rules
**** Could be initiated from tkb or pnet
**** xnet notes include
***(  (("source" := ql(nettype name)),  **** the source of the requesting graph
       ("scopegraph" := gv(scopegname)),
       ("graph" := ql(xgraphname)),  
       ("history" := ql(cmdtoks)),  
       ("scopenet" := tm(modname,pntlT)),  **** current search scope
       ("kbname" := ql(kbname)),  
       ("newnet" := tm(modname,'nil.PNTransList)),  **** increment 
       ("seen" := tm(modname, soccsT) ),   *** processed 
       ("oup" := tm(modname, uoccsT) ),   *** open up only
       ("odn" := tm(modname, doccsT) ),        *** open down only
       ("oboth" := tm(modname, boccsT) ))        *** open up-dn
)

***(graph node attributes
xstatus: oboth (openu and opend)  bluegreen
         oup (openu and seend)  blue
         odn (opend and seenu)  green
         seen (seenu and seend)   gray (lavendar ifinit)
)
******************************************************************************
**** defineXGraph -- as iop graph -
**** if flag == 'false - add new stuff to existing graph
**** ow create from scratch need to know parent graph -- the scopegraph of the xnet
******************************************************************************
  eq isReq('defineXGraph) = true .
****                                     where   what   new?
  eq enabled(wait4s,req('defineXGraph,ql(g2dvname gname flag toks), 
                         reqQ)) = 
      not(waiting4(wait4s,g2dvname)) .

  crl[defineXGraph]:
   [nil,
    st(processing(req('defineXGraph, ql(g2dvname gname flag toks), 
                      reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
       (wait4s !
         wait4(g2dvname,gname,
               req('logreq,ql('defineXGraph g2dvname gname flag), 
                    reqQ'))), 
       reqQ,
       es,
       log), outQ 
     g2dvname '\n mname '\n toks' maudePrompt ]
   if gv(?graph) := getVal(es,'gval,gname,gv(mtGraph)) 
   /\ gv(?graph') := lookupd(graphNotes(?graph),"removed",gv(mtGraph))
   /\ gnotes := getNotes(es,'gval,gname)
   /\ ql(kbname) := lookupd(gnotes,"kbname",ql('unknown))
   /\ mname :=  getMaudeName(es)
   /\ ?string :=
        withAck((if (graphNodes(?graph) == nil)
                 then "(apply mtGraphAlert)"
**** 09oct10 to stop the progress bar when no graph is shown
*****            then "(apply displayMessage \"Alert\" \"Empty Graph\")"
                 else (if flag == 'true
                       then mkDefineNewGraphExp(gname,?graph,gnotes)
                       else mkupdXGraphExp(gname,?graph,?graph',gnotes)
****                       else mkdefineXGraphExp(?graph,?graph',gnotes,
****                                               ('kbname 'source), false)
                       fi)
                   fi), mname,g2dvname) 
   /\ toks' := str2toks(?string) .

**** for definition on viewer side
***(       ("gatts" := ql('kbname 'source)),  
           ("oatts" := ql('xinit 'xstatus)),       
           ("ratts" := ql('xinit 'xstatus 'pre 'post)),       
           ("colorFun" := sv("colorXNode")),  
)

******************************************************************************
**** showXGraph -- display an already defined  graph in an explorer frame
******************************************************************************
  eq isReq('showXGraph) = true .
  eq enabled(wait4s,        **** where   parent newg  fresh?
             req('showXGraph,ql(g2dvname pname gname flag toks),reqQ))
        = not(waiting4(wait4s,g2dvname)) .


  crl[showXGraph]:
   [nil,
    st(processing(req('showXGraph,
                      ql(g2dvname pname gname flag toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   (if graphNodes(?graph) == nil
    then [nil,  
          st(ready,wait4s,
             reqQ  
             req('logreq,
                ql('showXGraph 'mtgraph g2dvname pname gname flag toks),
                   reqQ'),
              es, log),
           outQ]
    else [nil,  
          st(ready,
             (wait4s 
               ! wait4(g2dvname,gname,
                req('logreq,
                    ql('showXGraph  g2dvname pname gname flag toks), 
                     reqQ'))), 
              reqQ,
              es,
              log), outQ g2dvname '\n mname '\n toks' maudePrompt ]
    fi)
   if notes := getNotes(es,'gval,gname) 
   /\ gv(?graph) := getVal(es,'gval,gname,gv(mtGraph)) 
   /\ mname :=  getMaudeName(es)
   /\ sv(title) := lookupd(notes,"title",sv(string(gname)))
   /\ sv(subtitle) := lookupd(notes,"subtitle",sv(""))
   /\ ?string := withAck(
                    (if flag == 'true
                     then mkShowNewGraphExp(gname,notes)
                     else mkshowUXGraphExp(gname)
****                     else mkshowXGraphExp(gname,pname,title,subtitle,false)
                     fi),
                    mname,g2dvname) 
   /\ toks' := str2toks(?string) .

******************************************************************************
**** base requests
******************************************************************************
**** initializing
**** sgname -- the requesting/scope graph
**** xname,gname -- names to use for new xnet and its graph
******************************************************************************
  eq isReq('xnetInit) = true .
  eq enabled(wait4s,req('xnetInit,ql(sgname xname gname toks),reqQ)) 
           = true .

  crl[xnetInit]:
   [nil,
    st(processing(req('xnetInit, ql(sgname xname gname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, es', log),
    outQ] 
  if {b,es'} := xnetInit(es,sgname,xname,gname)
**** drop contiuation if fails
  /\ reqQ0 :=
      (if b
       then reqQ'
       else  req('logreq,ql('xnetInit 'failed sgname xname gname), nil)
       fi )  .

  op xnetInit : ESet Qid Qid Qid  -> BoolESet .
  ceq xnetInit(es,sgname,xname,gname) = {b,es'}
  if ql(type sname) := 
          lookupd(getNotes(es,'gval,sgname),"source", ql('unknown 'unknown))
  /\ tm(modname,pnetT) := getVal(es,'tval, type sname,dumTv)
  /\ ql(kbname) :=  lookupd(getNotes(es,'gval, sgname),"kbname",ql('unknown))
  /\ b := not(modname == 'BOOL or sname == 'unknown or kbname == 'unknown)
  /\ pntlT := (if b
               then (if getOp(pnetT) == 'pnet 
                     then first(getArgs(pnetT)) 
                     else pnetT fi)
               else 'nil.PNTransList
               fi)
  /\ xnotes := 
     (if not(b) 
     then mt 
     else (("source" := ql(type sname)),   **** source of scopegraph
           ("scopegraph" := ql(sgname)),   
           ("graph" := ql(gname)),      
           ("history" := ql(nil)),
           ("kbname" := ql(kbname)),
           ("scopenet" := tm(modname,pntlT)),
           ("hidden" := tm(modname,'nil.PNTransList)), 
           ("newnet" := tm(modname,'nil.PNTransList)), 
           ("seen" := tm(modname,'none.Occs)),
           ("oup" := tm(modname,'none.Occs)),
           ("odn" := tm(modname,'none.Occs)),
           ("oboth" := tm(modname,'none.Occs)) )
     fi)
  /\ pnotes := getNotes(es,'tval,type sname)
  /\ gnotes :=
     (if not(b) 
     then mt 
     else (("source" := ql('xnet xname)),
           ("requestor" := ql(sgname)),
           ("requestop" := ql('explore)),
           ("requestargs" := sv("")),
           ("kbname" := ql(kbname)),  **** from graph attr of (type sname)
**** for definition on viewer side
           ("gatts" := ql('kbname 'source 
                       'requestor 'requestop 'requestargs)),  
           ("oatts" := ql('xinit 'xstatus)),       
           ("ratts" := ql('xinit 'xstatus 'pre 'post)),       
           ("colorFun" := sv("colorXnetNode")),  
**** for showing
   	     ("title" := 
            sv(mkXGraphTitle(gname, type,
             (if type == 'tkb 
              then sname 
              else getNth(1,qvalQidList(lookupd(pnotes,"dishname",ql(nil))),sname) 
              fi) )) ),
           (if type == 'tkb then mt else ("parent" := ql(sgname)) fi),
           ("subtitle" := sv("")),
           ("selections" := sv("false")),
           ("toolBarFun" := sv("toolBarFunXnet"))
          )  
     fi)                                    
**** ("title" := sv(string(gname) + ": Exploring in " + string(sgname))), 
  /\ es' :=
      (if not(b) 
     then es 
     else addEntry(addEntry(es,
            'tval,'xnet xname,xnotes, tm(modname,'nil.PNTransList)),   
            'gval,gname,gnotes,gv(graph(string(gname),mt,nil,nil)))
     fi)  .

*****************************************************************************
**** forking  -- continue exploring from a copy
**** xname name of the graph being forked
**** newxname newgname -- new names to use for copy
******************************************************************************

  eq isReq('forkX) = true .
  eq enabled(wait4s,req('forkX,ql(xname newxname newgname toks),reqQ)) 
           = true .

 crl[forkX]:
   [nil,
    st(processing(req('forkX, ql(xname newxname newgname toks), 
                      reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, es', log),
    outQ]
   if {b,es'} := forkX(es,xname,newxname,newgname)
**** can't continue of fork fails
   /\ reqQ0 :=
      (if not(b)
       then req('logreq,ql('forkX 'failed xname),nil)
       else reqQ'
       fi ) .

  op  forkX : ESet Qid Qid Qid -> BoolESet .
  ceq forkX(es,xname,newxname,newgname) =  {b,es'}
  if tm(modname,pntlT) := getVal(es,'tval,'xnet xname,dumTv)
  /\ xnotes := getNotes(es,'tval,'xnet xname) 
  /\ ql(gname) := lookupd(xnotes,"graph", ql('unknown))
  /\ gv(?graph) := getVal(es,'gval,gname,gv(mtGraph))
  /\ b := not(modname == 'BOOL or gname == 'unknown or ?graph == mtGraph)
  /\ gnotes := getNotes(es,'gval,gname) 
  /\ xnotes' := insert("graph",ql(newgname), xnotes)
  /\ gnotes' := insert("source", ql('xnet newxname),gnotes)
  /\ es' :=
     (if not(b) 
      then es
      else addEntry(addEntry(es,
            'tval,'xnet newxname, xnotes',tm(modname,pntlT)),
            'gval, newgname, gnotes', 
             gv(graph(string(newgname),graphNotes(?graph),
                graphNodes(?graph),graphEdges(?graph))) )
      fi) .


******************************************************************************
**** synching the graph after an exploration operation on the xnet
******************************************************************************

  eq isReq('xgraphSync) = true .
  eq enabled(wait4s,req('xgraphSync,ql(xname flag toks),reqQ)) = true .

 crl[xgraphSync]:
   [nil,
    st(processing(req('xgraphSync, ql(xname flag toks), reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, es',log),
    outQ]
   if {b,es'} := xgraphSync(es,xname,flag)
   /\ reqQ0 :=
      (if not(b)
       then req('logreq,ql('xgraphSync 'failed xname flag),
                  nil)
       else reqQ'
       fi ) .

**** the eset update
  op  xgraphSync : ESet Qid Qid -> BoolESet .
  ceq xgraphSync(es,xname,flag) =  {b,es'}
  if tm(modname,pntlT) := getVal(es,'tval,'xnet xname,dumTv)
  /\ xnotes := getNotes(es,'tval,'xnet xname) 
  /\ ql(gname) := lookupd(xnotes,"graph", ql('unknown))
  /\ gv(?graph) := getVal(es,'gval,gname,gv(mtGraph))
  /\ gnotes := getNotes(es,'gval,gname) 
  /\ ql(sgname) := lookupd(xnotes,"scopegraph",ql('unknown))
  /\ sndl := graphNodes(gvalGraph(getVal(es,'gval,sgname,gv(mtGraph))))
  /\ b := not(modname == 'BOOL or gname == 'unknown or ?graph == mtGraph
             or sndl == nil)
  /\ ?graph' := synchXgraph(sndl,?graph,xnotes,flag)
  /\ gnotes' := insert("requestargs", 
                        sv(removeBQs(qidl2str(qvalQidList(
                            lookupd(xnotes,"history",ql(nil)))),0,"")),
                        gnotes)
  /\ es' :=
     (if not(b) 
      then es
      else addEntry(es, 'gval, gname, gnotes', gv(?graph'))
      fi) .

**** set new attribute for old graph, 
**** extend graph, setting new attribute for new elements
**** set xstate attributes for extended graph
  op synchXgraph : NodeList Graph Notes Qid -> Graph .
  ceq synchXgraph(sndl,?graph,xnotes,flag) = 
        graph(graphId(?graph), graphNotes(?graph'),
             setNodesXStatus(graphNodes(?graph'),
                              nil,soccTL,uoccTL,doccTL,boccTL),
             graphEdges(?graph'))
  if tm(modname,pntlT) := lookupd(xnotes,"newnet",dumTv)
  /\ pntTL := (if modname == 'BOOL then empty 
                else olt2tl([modname],'PNTrans,pntlT) fi)
  /\ ndl := setNNotes(graphNodes(?graph),"new",sv("false"),nil)
  /\ edl := setENotes(graphEdges(?graph),"new",sv("false"),nil)
  /\ soccTL := 
       occsT2occTL(tvalTerm(lookupd(xnotes,"seen",tm(modname,'none.Occs))))
  /\ boccTL := 
       occsT2occTL(tvalTerm(lookupd(xnotes,"oboth",tm(modname,'none.Occs))))
  /\ uoccTL := occsT2occTL(tvalTerm(lookupd(xnotes,"oup",tm(modname,'none.Occs))))
  /\ doccTL := occsT2occTL(tvalTerm(lookupd(xnotes,"odn",tm(modname,'none.Occs))))
  /\ ?graph' := 
        (if flag == 'add 
         then extendXGraph(modname,sndl,ndl,edl,nil,nil, pntTL)                                    
         else removeRules(ndl,edl,nil,pntTL)
        fi)  .       

**** these could go into graph.maude
  op setNNotes : NodeList String Val NodeList -> NodeList .
  eq setNNotes(nil,str,val,ndl) = ndl .
  eq setNNotes(nd(nodeId,notes) ndl',str,val,ndl) = 
        setNNotes(ndl',str,val,ndl nd(nodeId,insert(str,val,notes))) .

  op setENotes : EdgeList String Val EdgeList -> EdgeList .
  eq setENotes(nil,str,val,edl) = edl .
  eq setENotes(ed(srcId,tgtId,notes) edl',str,val,edl) = 
        setENotes(edl',str,val,edl ed(srcId,tgtId,insert(str,val,notes))) .

  op extendXGraph : Qid NodeList NodeList EdgeList NodeList EdgeList TermList 
                    -> Graph .
 op extendXGraph1 : Qid  NodeList NodeList EdgeList NodeList EdgeList 
                   NodeList Nat NodeList NodeList NodeList TermList -> Graph .

  eq extendXGraph(modname,sndl,ondl,oedl,ndl,edl,empty) =
           graph("",mt,ondl ndl,oedl edl) .

  eq extendXGraph(modname,sndl,ondl,oedl,ndl,edl, 
                   ('pnTrans[ridT,ioccsT,ooccsT,boccsT],pntTL)) =
     extendXGraph1(modname,sndl,ondl,oedl,ndl,edl,
                   getNodeRidT(sndl,ridT),
                   (if getNodeRidT(sndl,ridT) :: Node 
                    then nodeId(getNodeRidT(sndl,ridT)) else 0 fi),
                   getOccNodes(sndl,occsT2occTL(ioccsT)),
                   getOccNodes(sndl,occsT2occTL(ooccsT)),
                   getOccNodes(sndl,occsT2occTL(boccsT)),
                   pntTL ) .

  eq extendXGraph1(modname,sndl,ondl,oedl,ndl,edl,
                   rnodes,n,inodes,onodes,bnodes,pntTL) = 
     (if rnodes :: Node
      then  extendXGraph(modname,sndl,ondl,oedl,
              addNodes(ndl, setNNotes(rnodes,"new",sv("true"),nil)
                  setNNotes(nodesDiff(inodes,ondl),"new",sv("true"),nil)
                  setNNotes(nodesDiff(onodes,ondl),"new",sv("true"),nil)
                  setNNotes(nodesDiff(bnodes,ondl),"new",sv("true"),nil)),
             (edl
              setENotes(mkIedges(nodes2natl(inodes),n,nil), "new",sv("true"),nil)
              setENotes(mkOedges(nodes2natl(onodes),n,nil), "new",sv("true"),nil)
              setENotes(mkBedges(nodes2natl(bnodes),n,nil), "new",sv("true"),nil)),
            pntTL)
      else  extendXGraph(modname,sndl,ondl,oedl,ndl,edl,pntTL)
      fi) .


  op addNodes : NodeList NodeList -> NodeList .
  eq addNodes(ndl,nil) = ndl .
  eq addNodes(ndl nd(nodeId,notes') ndl', nd(nodeId,notes) ondl) = 
       addNodes(ndl nd(nodeId,notes') ndl', ondl) . 
  eq addNodes(ndl, nd(nodeId,notes) ondl) = 
         addNodes(ndl nd(nodeId,notes), ondl) [owise] . 


  op getOccNodes  : NodeList TermList -> NodeList .
  eq getOccNodes(ndl,empty) = nil .
  eq getOccNodes(ndl nd(nodeId,(notes, ("occ" := tm(modname,occT)))) ndl',
                 (occT, tl)) =
     nd(nodeId,(notes, ("occ" := tm(modname,occT)))) getOccNodes(ndl ndl',tl) .
  eq getOccNodes(ndl,(occT,tl)) = getOccNodes(ndl,tl) [owise] .

  op nodesDiff : NodeList NodeList  -> NodeList .
  eq nodesDiff(nil, ndl) = nil .
  eq nodesDiff(nd(nodeId,notes) ndl', ondl) =
      (if getNode(ondl,nodeId) :: Node then nil else nd(nodeId,notes) fi)
       nodesDiff(ndl',ondl) .


  op getNodeRidT : NodeList Term -> NodeList .
  eq getNodeRidT(sndl nd(nodeId,(notes, ("rule" := tm(modname,ridT)))) sndl',
                 ridT)
     = nd(nodeId,(notes, ("rule" := tm(modname,ridT)))) .
  eq getNodeRidT(sndl,ridT) = nil [owise] .

****                seenu seend openu opend occ
  op occs2xstatus : TermList TermList  TermList  TermList  Term -> String .
  eq occs2xstatus(soccTL,uoccTL,doccTL,boccTL,occT) =
       (if eltOf(occT,soccTL)
        then "seen"
        else (if eltOf(occT,uoccTL) then "oup"
        else (if eltOf(occT,doccTL) then "odn" else "oboth" fi) fi) fi) .

  op setNodesXStatus : NodeList NodeList TermList TermList TermList TermList
                       -> NodeList .
  eq setNodesXStatus(nil,ndl,soccTL,uoccTL,doccTL,boccTL) = ndl .
  eq setNodesXStatus(nd(nodeId,notes) ndl',ndl,soccTL,uoccTL,doccTL,boccTL) =
      setNodesXStatus(ndl',ndl nd(nodeId, 
                      setNotesXStatus(notes,soccTL,uoccTL,doccTL,boccTL)),
                      soccTL,uoccTL,doccTL,boccTL) .

  op setNotesXStatus : Notes TermList TermList TermList TermList -> Notes .
  eq setNotesXStatus(notes,soccTL,uoccTL,doccTL,boccTL) =
       (if lookupd(notes,"type",sv("")) == sv("occ")
        then insert("xstatus",
                    sv(occs2xstatus(soccTL,uoccTL,doccTL,boccTL,
                       tvalTerm(lookupd(notes,"occ",dumTv)))),
                    notes)
        else notes
        fi) .


****               remain   orig     removed toremove 
  op removeRules : NodeList EdgeList NodeList TermList  -> Graph .
****               remain   remain   tock      cked     removed
  op removeEdges : NodeList EdgeList NodeList NodeList EdgeList  -> Graph .
****               tock    keep     remain   removed  removed
  op removeOccs : NodeList NodeList EdgeList NodeList EdgeList  -> Graph .


  eq removeRules(ondl,oedl,ndl,empty) = removeEdges(ondl,oedl,ndl,nil,nil) .
  eq removeRules(ondl nd(nodeId,(notes,("rule" := tm(modname,ridT)))) ondl', 
                 oedl,ndl,('pnTrans[ridT,ioccsT,ooccsT,boccsT],pntTL)) =
      removeRules(ondl ondl',oedl, 
                  ndl nd(nodeId,(notes, ("rule" := tm(modname,ridT)))),
                  pntTL) .
**** shouldn't happen ... but
  eq removeRules(ondl,oedl,ndl,('pnTrans[ridT,ioccsT,ooccsT,boccsT],pntTL)) =
       removeRules(ondl,oedl,ndl,pntTL) [owise] .

****    remaining nds,eds,tock cked removed
  eq removeEdges(ondl,oedl,nil,ndl,edl) = removeOccs(ondl,nil,oedl,ndl,edl) .

  eq removeEdges(ondl,oedl ed(nodeId,tgtId,notes') oedl',
                 nd(nodeId,notes) ndl,ndl',edl)  =
       removeEdges(ondl,oedl oedl', nd(nodeId,notes) ndl,ndl', 
                   edl ed(nodeId,tgtId,notes')) .
  eq removeEdges(ondl,oedl ed(srcId,nodeId,notes') oedl',
                 nd(nodeId,notes) ndl,ndl',edl)  =
       removeEdges(ondl,oedl oedl', nd(nodeId,notes) ndl,ndl', 
                   edl ed(srcId,nodeId,notes')) .
  eq removeEdges(ondl,oedl', nd(nodeId,notes) ndl,ndl',edl)  =
        removeEdges(ondl,oedl',ndl,ndl' nd(nodeId,notes) ,edl)  [owise] .

****         tock   keep keep rmv rmv
  eq removeOccs(nil,ondl,oedl,ndl,edl) =
      graph("", ("removed" := gv(graph("",mt,ndl,edl))),ondl,oedl) .

  eq removeOccs(nd(nodeId,notes) ondl,ondl',
                oedl ed(srcId,nodeId,notes') oedl',ndl,edl) =
       removeOccs(ondl,ondl' nd(nodeId,notes),
                  oedl ed(srcId,nodeId,notes') oedl',ndl,edl) .
  eq removeOccs(nd(nodeId,notes) ondl,ondl',
                oedl ed(nodeId,tgtId,notes') oedl',ndl,edl) =
       removeOccs(ondl,ondl' nd(nodeId,notes),
                  oedl ed(nodeId,tgtId,notes') oedl',ndl,edl) .
  eq removeOccs(nd(nodeId,notes) ondl,ondl',oedl,ndl,edl) =
       removeOccs(ondl,ondl', oedl, ndl nd(nodeId,notes),edl) [owise] .



***************************************************************************
**** manipulating xstate terms

***************************************************************************
  op mtXstateT : -> Term .
  eq mtXstateT = 'xstate['nil.PNTransList,'nil.PNTransList,
                         'nil.PNTransList,'nil.PNTransList,
                         'none.Occs,'none.Occs,'none.Occs,'none.Occs] .

  ops xstateT2scopeT xstateT2xnetT xstateT2newnetT  xstateT2hiddenT
      : Term -> Term .
  ops xstateT2soccsT xstateT2uoccsT xstateT2doccsT xstateT2boccsT
      : Term -> Term .

  eq xstateT2scopeT('xstate[scopeT,hiddenT,xnetT,newnetT,
                            soccsT,uoccsT,doccsT,boccsT]) = scopeT . 
  eq xstateT2scopeT(term) = 'nil.PNTransList [owise] .

  eq xstateT2xnetT('xstate[scopeT,hiddenT,xnetT,newnetT,
                           soccsT,uoccsT,doccsT,boccsT]) = xnetT . 
  eq xstateT2xnetT(term) = 'nil.PNTransList [owise] .

  eq xstateT2newnetT('xstate[scopeT,hiddenT,xnetT,newnetT,
                             soccsT,uoccsT,doccsT,boccsT]) = newnetT . 
  eq xstateT2newnetT(term) = 'nil.PNTransList [owise] .

  eq xstateT2hiddenT('xstate[scopeT,hiddenT,xnetT,newnetT,
                             soccsT,uoccsT,doccsT,boccsT]) = hiddenT . 
  eq xstateT2hiddenT(term) = 'nil.PNTransList [owise] .

  eq xstateT2soccsT('xstate[scopeT,hiddenT,xnetT,newnetT,
                            soccsT,uoccsT,doccsT,boccsT]) = soccsT . 
  eq xstateT2soccsT(term) = 'none.Occs [owise] .

  eq xstateT2uoccsT('xstate[scopeT,hiddenT,xnetT,newnetT,
                            soccsT,uoccsT,doccsT,boccsT]) = uoccsT . 
  eq xstateT2uoccsT(term) = 'none.Occs [owise] .

  eq xstateT2doccsT('xstate[scopeT,hiddenT,xnetT,newnetT,
                            soccsT,uoccsT,doccsT,boccsT]) = doccsT . 
  eq xstateT2doccsT(term) = 'none.Occs [owise] .

  eq xstateT2boccsT('xstate[scopeT,hiddenT,xnetT,newnetT,
                            soccsT,uoccsT,doccsT,boccsT]) = boccsT . 
  eq xstateT2boccsT(term) = 'none.Occs [owise] .


  op updateXnotes : Notes Qid Term QidList -> Notes .
  eq updateXnotes(xnotes,modname,xstateT,toks) =
          (("source" := lookupd(xnotes,"source",ql('unknown 'unknown))),
           ("scopegraph" := lookupd(xnotes,"scopegraph",ql('unknown))),
           ("graph" := lookupd(xnotes,"graph",ql('unknown))),
           ("kbname" := lookupd(xnotes,"kbname",ql('unknown))),
           ("history" :=
                 ql(qvalQidList(lookupd(xnotes,"history",ql(nil))) toks)),
           ("scopenet" := tm(modname,xstateT2scopeT(xstateT))),
           ("hidden" := tm(modname,xstateT2hiddenT(xstateT))), 
           ("newnet" := tm(modname,xstateT2newnetT(xstateT))), 
           ("seen" := tm(modname,xstateT2soccsT(xstateT))),
           ("oup" := tm(modname,xstateT2uoccsT(xstateT))),
           ("odn" := tm(modname,xstateT2doccsT(xstateT))),
           ("oboth" := tm(modname,xstateT2boccsT(xstateT))) ) .


******************************************************************************
*** adding rules
******************************************************************************

  eq isReq('xaddRules) = true .
  eq enabled(wait4s,req('xaddRules,ql(xname toks),reqQ)) 
           = true .

 crl[xaddRules]:
   [nil,
    st(processing(req('xaddRules, ql(xname toks), reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, es', log),
    outQ]
   if {b,es'} := xaddRules(es,xname,toks)
   /\ reqQ0 :=
      (if not(b)
       then req('logreq,ql('xaddRules 'failed xname toks),nil)
       else req('xgraphSync,ql(xname 'add),reqQ')
       fi ) .


  op xaddRules : ESet Qid QidList -> BoolESet .
  ceq xaddRules(es,xname,rids) = {b,es'}
  if tm(modname,pntlT) := getVal(es,'tval,'xnet xname,dumTv)
  /\ ridsT := qidl2qidlT(rids)
  /\ xnotes := getNotes(es,'tval,'xnet xname)
  /\ scopeT := tvalTerm(lookupd(xnotes,"scopenet",dumTv))
  /\ hiddenT := tvalTerm(lookupd(xnotes,"hidden",dumTv))
  /\ res?? := metaReduce([modname],'xsAddRules[scopeT,hiddenT,pntlT,ridsT])
  /\ b :=  modname =/= 'BOOL or res?? :: ResultPair
  /\ xstateT := (if b then getTerm(res??) else mtXstateT fi) 
  /\ ql(history) := lookupd(xnotes,"history",ql(nil))
  /\ xnotes' := 
      (if not(b)
       then mt
       else updateXnotes(xnotes,modname,xstateT,'`( 'addR rids '`))
       fi)
  /\ es' := 
      (if not(b)
       then es
       else addEntry(es,'tval,'xnet xname, 
                         xnotes',tm(modname,xstateT2xnetT(xstateT)))
       fi) .

******************************************************************************
*** hiding rules
******************************************************************************
  eq isReq('xhideRules) = true .
  eq enabled(wait4s,req('xhideRules,ql(xname toks),reqQ)) = true .

 crl[xhideRules]:
   [nil,
    st(processing(req('xhideRules, ql(xname toks), reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, es', log),
    outQ]
   if {b,es'} := xhideRules(es,xname,toks)
   /\ reqQ0 :=
      (if not(b)
       then req('logreq,ql('xhideRules 'failed xname toks),nil)
       else req('xgraphSync,ql(xname 'remove),reqQ')
       fi ) .

  op xhideRules : ESet Qid QidList -> BoolESet .
  ceq xhideRules(es,xname,rids) = {b,es'}
  if tm(modname,pntlT) := getVal(es,'tval,'xnet xname,dumTv)
  /\ ridsT := qidl2qidlT(rids)
  /\ xnotes := getNotes(es,'tval,'xnet xname)
  /\ scopeT := tvalTerm(lookupd(xnotes,"scopenet",dumTv))
  /\ hiddenT := tvalTerm(lookupd(xnotes,"hidden",dumTv))
  /\ res?? := metaReduce([modname],'xsHideRules[scopeT,hiddenT,pntlT,ridsT])
  /\ b :=  modname =/= 'BOOL or res?? :: ResultPair
  /\ xstateT := (if b then getTerm(res??) else mtXstateT fi) 
  /\ xnotes' := 
      (if not(b)
       then mt
       else updateXnotes(xnotes,modname,xstateT,'`( 'hideR rids '`) )
       fi)
  /\ es' := 
      (if not(b)
       then es
       else addEntry(es,'tval,'xnet xname, 
                         xnotes',tm(modname,xstateT2xnetT(xstateT)))
       fi) .

******************************************************************************
*** unhiding rules
******************************************************************************
  eq isReq('xunhideRules) = true .
  eq enabled(wait4s,req('xunhideRules,ql(xname toks),reqQ)) = true .

 crl[xhideRules]:
   [nil,
    st(processing(req('xunhideRules, ql(xname toks), reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, es', log),
    outQ]
   if {b,es'} := xunhideRules(es,xname,toks)
   /\ reqQ0 :=
      (if not(b)
       then req('logreq,ql('xunhideRules 'failed xname toks),nil)
       else req('xgraphSync,ql(xname 'add),reqQ') 
****   else reqQ'   **** the xnet hasn't changed, but graph colors might
       fi ) .

  op xunhideRules : ESet Qid QidList -> BoolESet .
  ceq xunhideRules(es,xname,rids) = {b,es'}
  if tm(modname,pntlT) := getVal(es,'tval,'xnet xname,dumTv)
  /\ ridsT := qidl2qidlT(rids)
  /\ xnotes := getNotes(es,'tval,'xnet xname)
  /\ scopeT := tvalTerm(lookupd(xnotes,"scopenet",dumTv))
  /\ hiddenT := tvalTerm(lookupd(xnotes,"hidden",dumTv))
  /\ res?? := metaReduce([modname],'xsUnHideRules[scopeT,hiddenT,pntlT,ridsT])
  /\ b :=  modname =/= 'BOOL or res?? :: ResultPair
  /\ xstateT := (if b then getTerm(res??) else mtXstateT fi) 
  /\ xnotes' := 
      (if not(b)
       then mt
       else updateXnotes(xnotes,modname,xstateT,'`( 'unhideR rids '`) )
       fi)
  /\ es' := 
      (if not(b)
       then es
       else addEntry(es,'tval,'xnet xname, 
                         xnotes',tm(modname,xstateT2xnetT(xstateT)))
       fi) .


******************************************************************************
*** explore from focus points
******************************************************************************

  eq isReq('xnetFps) = true .
  eq enabled(wait4s,req('xnetFps,ql(xname toks),reqQ)) = true .

 crl[xnetFps]:
   [nil,
    st(processing(req('xnetFps, ql(xname toks), reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil, st(ready, wait4s, reqQ reqQ0, es', log), outQ]
   if {b,es'} := xnetFps(es,xname,toks)
   /\ reqQ0 :=
      (if not(b)
       then req('logreq,ql('xnetFps 'failed xname toks),nil)
       else req('xgraphSync,ql(xname 'add),reqQ')
       fi ) .

  op xnetFps : ESet Qid QidList -> BoolESet .
  ceq xnetFps(es,xname,toks) = {b,es'}
  if tm(modname,pntlT) := getVal(es,'tval,'xnet xname,dumTv)
  /\ xnotes := getNotes(es,'tval,'xnet xname)
  /\ scopeT := tvalTerm(lookupd(xnotes,"scopenet",dumTv))
  /\ hiddenT := tvalTerm(lookupd(xnotes,"hidden",dumTv))
  /\ ql(sgname) := lookupd(xnotes,"scopegraph",ql('unknown))
  /\ gv(?graph) := getVal(es,'gval,sgname,gv(mtGraph))
  /\ (uoccsT,doccsT,boccsT) :=
            parseFpsToks(graphNodes(?graph),toks,empty,empty,empty)
  /\ res?? := metaReduce([modname],
                        'exploreFps[scopeT,hiddenT,pntlT,uoccsT,doccsT,boccsT])
  /\ b :=  modname =/= 'BOOL or res?? :: ResultPair
  /\ xstateT := (if b then getTerm(res??) else mtXstateT fi) 
  /\ xnotes' := 
      (if not(b)
       then mt
       else updateXnotes(xnotes,modname,xstateT, '`( 'fps  toks '`))
       fi)
  /\ es' := 
      (if not(b)
       then es
       else addEntry(es,'tval,'xnet xname, 
                         xnotes',tm(modname,xstateT2xnetT(xstateT)))
       fi) .

  op parseFpsToks : NodeList QidList TermList TermList TermList -> TermList .
  ceq parseFpsToks(ndl,qid dir toks,uoccTL,doccTL,boccTL) =
       (if modname == 'BOOL
        then parseFpsToks(ndl,toks,uoccTL,doccTL,boccTL)
        else (if dir == 'u
              then parseFpsToks(ndl,toks,(uoccTL,occT),doccTL,boccTL)
              else (if dir == 'd
      		  then parseFpsToks(ndl,toks,uoccTL,(doccTL,occT),boccTL)
			     else (if dir == 'b
			     then parseFpsToks(ndl,toks,uoccTL,doccTL,(boccTL,occT))
			     else parseFpsToks(ndl,toks,uoccTL,doccTL,boccTL)
			     fi) fi) fi)
       fi)
  if nodes := getNode(ndl,"chattylabel",sv(string(qid)))
  /\ tm(modname,occT) :=
       (if nodes :: Node 
        then lookupd(nodeNotes(nodes),"occ",dumTv)
        else dumTv fi) .

  eq parseFpsToks(ndl, toks,uoccTL,doccTL,boccTL) =
      (occTL2occsT(uoccTL),occTL2occsT(doccTL),occTL2occsT(boccTL))  [owise] .


******************************************************************************
*** going up/down
******************************************************************************
  eq isReq('xnetUpDn) = true .
  eq enabled(wait4s,req('xnetUpDn,ql(xname dir nq toks),reqQ)) 
           = true .

 crl[xnetUpDn]:
   [nil,
    st(processing(req('xnetUpDn, ql(xname dir nq toks), reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, es', log),
    outQ]
   if {b,es'} := xnetUpDn(es,xname,dir,nq)
   /\ reqQ0 :=
      (if not(b)
       then req('logreq,ql('xnetUpDn 'failed xname dir nq toks),nil)
       else req('xgraphSync,ql(xname 'add),reqQ')
       fi ) .


  op xnetUpDn : ESet Qid Qid Qid -> BoolESet .
  ceq xnetUpDn(es,xname,dir,nq) = {b,es'}
  if tm(modname,pntlT) := getVal(es,'tval,'xnet xname,dumTv)
  /\ nT := nat2natT(if rat(string(nq),10) :: Nat
                     then rat(string(nq),10) 
                     else 0 fi)
  /\ xnotes := getNotes(es,'tval,'xnet xname)
  /\ scopeT := tvalTerm(lookupd(xnotes,"scopenet",dumTv))
  /\ hiddenT := tvalTerm(lookupd(xnotes,"hidden",dumTv))
  /\ newnetT := tvalTerm(lookupd(xnotes,"newnet",dumTv))
  /\ soccsT := tvalTerm(lookupd(xnotes,"seen",dumTv))
  /\ uoccsT := tvalTerm(lookupd(xnotes,"oup",dumTv))
  /\ doccsT := tvalTerm(lookupd(xnotes,"odn",dumTv))
  /\ boccsT := tvalTerm(lookupd(xnotes,"oboth",dumTv))
  /\ xstateT' := 'xstate[scopeT,hiddenT,pntlT,newnetT,soccsT,uoccsT,doccsT,boccsT]
  /\ bad :=  modname == 'BOOL or 
     eltOf('true.Bool, (scopeT, newnetT, hiddenT, soccsT, uoccsT, doccsT, boccsT))
  /\ res?? := 
      (if bad then noParse(0) else
      (if dir == 'up
       then metaReduce([modname],'exploreUp[xstateT',nT])
       else (if dir == 'dn
       then metaReduce([modname],'exploreDn[xstateT',nT])
       else noParse(0) fi) fi)  fi) ****HACK 
  /\ b :=  not(bad) and res?? :: ResultPair
  /\ xstateT := (if b
                 then getTerm(res??)
                 else mtXstateT fi) 
  /\ xnotes' := 
      (if not(b)
       then mt
       else updateXnotes(xnotes,modname,xstateT,'`( dir nq '`))
     fi)
  /\ es' := 
      (if not(b)
       then es
       else addEntry(es,'tval,'xnet xname, 
                         xnotes',tm(modname,xstateT2xnetT(xstateT)))
       fi) .

******************************************************************************
**** posting explore dialogs
**** req('exploreSelect, ql(g2dvname sgname xgname new? op),
****     req(<xnetopreq>, ql(xname),reqQ2))
****  From exploreInit sgname will be the caller, xgname the new graph name
****    new?  will be true and op will be one of 'fps or 'addR
****  From explore sgname will be the scopegraph of the caller
****    xgname the graph of the net to edit, 
****    op is one of  of 'fps or 'addR or 'hideR
****    of new? is 'true the xgname the copy of the caller ow the caller
****    in the case of hideRules the scope is xgname
****  If explore string is "" and new? is not 'true then restart xname listener
****  send viewer the code to open the selection dialog
****  with continuation that bails if there is a dismiss
****  and strips the request id from toks before supplying them to the cont
************************************************************************
  eq isReq('exploreSelect) = true .
****                                     viewer   scope     rules or occs
  eq enabled(wait4s,req('exploreSelect,
                         ql(g2dvname sgname xgname  new? xop toks),reqQ)) 
           = true .
 crl[exploreSelect]:
   [nil,
    st(processing(req('exploreSelect,
                       ql(g2dvname sgname xgname  new? xop toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, 
       (if ?string == ""
        then wait4s 
        else wait4s ! wait4(replyfor, 'exploreSelect xgname xop,
                              req('exploreSelectReply,ql(nil), reqQ'))
        fi), 
       (reqQ reqQ0), incGlobalCounter(es,1), log), 
    outQ toks']
   if mname :=  getMaudeName(es)
   /\ ql(type xname) :=
          lookupd(getNotes(es,'gval,xgname),"source",ql('unknown 'unknown))
   /\ xnotes := getNotes(es,'tval,type xname)
   /\ tm(modname,pntlT) :=
      (if xop == 'hideR 
       then getVal(es,'tval,type xname,dumTv)
       else (if xop == 'addR 
             then lookupd(xnotes,"scopenet",dumTv)
             else (if xop == 'unhideR 
                   then  lookupd(xnotes,"hidden",dumTv)
                   else dumTv fi)
             fi)
       fi)
   /\ pntTL := (if modname == 'BOOL then empty 
                else olt2tl([modname],'PNTrans,pntlT) fi)
   /\ sndl := graphNodes(gvalGraph(getVal(es,'gval,sgname,gv(mtGraph))))
   /\ replyfor := qid("maudereq" + getGlobalCounter(es))
   /\ title := 
       (if xop == 'fps
        then "Select occs and direction to explore from " + string(xgname)
        else (if xop == 'addR
        then "Select rules to add to " + string(xgname)
        else (if xop == 'hideR
        then "Select rules to hide from " + string(xgname)
        else (if xop == 'unhideR
        then "Select rules to unhide from " + string(xgname)
        else "" fi) fi) fi) fi)
   /\ gname := (if new? == 'true then sgname else xgname fi)
   /\  ?string :=
        (if xname == 'unknown
         then ""
         else (if xop == 'fps
              then exploreSelectOccsString(title,gname,mname,replyfor,
                                           sndl)
              else exploreSelectRulesString(title,gname,mname,replyfor,pntTL)
              fi)
         fi)
   /\ toks' := (if ?string == "" 
                then nil 
                else g2dvname '\n mname '\n str2toks(?string) maudePrompt
                fi)
   /\ reqQ0 :=
      (if ?string == ""  *** drop the select continuation as it has no input
       then req('logreq,ql('exploreSelect 'failed g2dvname sgname xgname toks),
             req('sendAlert, 
                 ql(g2dvname 'exploreSelect sgname xgname 'failed), 
               (if new? == 'true 
                then nil
                else req('startcListener,ql(xgname 'serializingListener g2dvname),
                   nil) fi)))
       else nil
      fi) .


**** exploreInit will popup selector, send selection to replyto from replyfor
****  expects replyfor to be listening
  op exploreSelectRulesTemplate : -> String .
  eq exploreSelectRulesTemplate = 
      "(apply exploreSelectRules %title %gname %rids %replyto %replyfor)" .
  op exploreSelectOccsTemplate : -> String .
  eq exploreSelectOccsTemplate = 
      "(apply exploreSelectOccs %title %gname %occids %replyto %replyfor)" .

  op exploreSelectRulesString : String Qid Qid Qid  TermList  -> String .
  ceq exploreSelectRulesString(title,gname,mname,replyfor,pntTL) =
        fillTemplate(exploreSelectRulesTemplate,bindings)
  if bindings :=              
       (("%title" :~ squote(title)),
        ("%gname" :~ squote(string(gname))),
        ("%rids" :~ 
            "(array java.lang.String " + mkRidStr(pntTL,"") + ")" ),
        ("%replyto" :~ squote(string(mname))),
        ("%replyfor" :~ squote(string(replyfor)))) .

  ops mkRidStr : TermList String -> String .
  eq mkRidStr(('pnTrans[ridT,ioccsT,ooccsT,boccsT], tl),str) = 
        mkRidStr(tl,str + " " + squote(printRidTAll(ridT))) . 
  eq mkRidStr(empty,str) = str .

  op exploreSelectOccsString : String Qid Qid Qid NodeList -> String .
****                           title   gn  mn  for sndl

  ceq exploreSelectOccsString(title,gname,mname,replyfor,sndl) =
        fillTemplate(exploreSelectOccsTemplate,bindings)
   if bindings :=              
       (("%title" :~ squote(title)),
        ("%gname" :~ squote(string(gname))),
        ("%occids" :~ "(array java.lang.String " + ndl2occstr(sndl,"") + ")" ),
        ("%replyto" :~ squote(string(mname))),
        ("%replyfor" :~ squote(string(replyfor)))) .
  

  op ndl2occstr : NodeList String -> String .
  eq ndl2occstr(nil,str) = str .
  eq ndl2occstr(nd(nodeId,notes) sndl,str) = 
      ndl2occstr(sndl,  
                  (if lookupd(notes,"type",sv("")) == sv("occ")
                  then str + " " + 
                        squote(svalString(lookupd(notes,"chattylabel",sv("")))) 
                  else str fi)) .

************************************************************************
****  forwarding selection from dialog
****  drop req cont if toks == nil -- selector dismissed
****                                  scope viewer   rule or occ 
  eq enabled(wait4s, req('exploreSelectReply,ql(replyfor toks),reqQ)) 
           = true .
 rl[exploreSelectReply]:
   [nil,
    st(processing(req('exploreSelectReply, 
                      ql(replyfor toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, 
       (if toks == nil 
        then req('sendAlert,
                 ql(getG2dVName(es) 'exploreSelect 'empty 'selection), reqQ) 
        else reqQ supplyPars(reqQ',toks) fi),
**** reqQ (if toks == nil then nil else supplyPars(reqQ',toks) fi),
       es, log),
    outQ] .


******************************************************************************
**** Viewer Interface
**** exploreInit
**** explore
************************************************************************
  eq isReq('exploreInit) = true .
****                          from/scope viewer  rule or occ 
  eq enabled(wait4s,
             req('exploreInit,ql(gname g2dvname flag  toks),reqQ)) 
           = true .
 crl[exploreInit]:
   [nil,
    st(processing(req('exploreInit, 
                      ql(gname g2dvname flag toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, incGlobalCounter(es,2), log),
    outQ]
   if ctr := getGlobalCounter(es) 
   /\ ctr1 := stringInc(ctr) 
   /\ xname := qid("xpnet" + ctr)
   /\ newgname := qid("graph" + ctr1)
   /\ reqQ2 := 
        req('defineXGraph,ql(g2dvname newgname 'true),
           req('showXGraph,ql(g2dvname gname newgname 'true),
             req('startcListener,ql(newgname 'serializingListener g2dvname),
                reqQ')))
   /\ reqQ1 :=
        (if flag == 'rule
         then  req('exploreSelect, ql(g2dvname gname newgname 'true 'addR),
                    req('xaddRules,ql(xname toks),reqQ2))
         else (if flag == 'occ 
              then req('exploreSelect, ql(g2dvname gname newgname 'true 'fps),
                     req('xnetFps,ql(xname toks),reqQ2))
              else reqQ2 fi) fi)
   /\ reqQ0 :=
      (if  (flag =/= 'occ and flag =/= 'rule)
       then req('logreq,ql('exploreInit 'failed gname  g2dvname  flag),reqQ')
       else req('xnetInit,ql(gname xname newgname),reqQ1)
      fi) .

************************************************************************
**** 10jan30 -- hack to show maude rule as pnet -- which can be explored
************************************************************************
  eq isReq('exploreRule) = true .
****                          from/scope viewer  rule or occ 
  eq enabled(wait4s,
             req('exploreRule,ql(gname g2dvname rid  toks),reqQ)) 
           = true .
 crl[exploreRule]:
   [nil,
    st(processing(req('exploreRule, 
                      ql(gname g2dvname rid toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, incGlobalCounter(es,2), log),
    outQ]
   if ctr := getGlobalCounter(es) 
   /\ ctr1 := stringInc(ctr) 
   /\ xname := qid("xpnet" + ctr)
   /\ newgname := qid("graph" + ctr1)
   /\ reqQ2 := 
        req('defineXGraph,ql(g2dvname newgname 'true),
           req('showXGraph,ql(g2dvname gname newgname 'true),
             req('startcListener,ql(newgname 'serializingListener g2dvname),
                reqQ')))
   /\ reqQ0 := req('xnetInit,ql(gname xname newgname),
                   req('xaddRules,ql(xname rid toks),reqQ2))
  .


***************************************************************************
**** exploring
**** flag == 'true then  fork else use existing xnet/graph
****  if xname or sgname == 'unknown then fail, don't restart xgname
****  if op not understood, explore fails but restart xgname 
**** if new restart xgname after forkX ow will be restarted after showX
***************************************************************************
  eq isReq('explore) = true .
****                                from    viewer            [n]
  eq enabled(wait4s,req('explore,ql(xgname  g2dvname new? xop toks),reqQ)) 
           = true .

 crl[explore]:
   [nil,
    st(processing(req('explore, ql(xgname g2dvname new? xop toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
****       (if new? == 'true 
****        then wait4s ! 
****             wait4(xgname, nil, creq('onetimeListener,nil,ql(g2dvname),nil))
****        else wait4s fi),
       wait4s,
       reqQ reqQ0, 
       (if new? == 'true then incGlobalCounter(es,2) else es fi),
       log),
    outQ]
**** type should be 'xnet
  if ql(type xname) :=
       lookupd(getNotes(es,'gval,xgname),"source",ql('unknown 'unknown))
  /\ ql(sgname) := lookupd(getNotes(es,'tval, type xname), 
                         "scopegraph", ql('unknown) )
  /\ newxname := 
       (if new? == 'true 
        then qid("xpnet" + getGlobalCounter(es)) else xname fi)
  /\ newgname :=
       (if new? == 'true 
        then qid("graph" + stringInc(getGlobalCounter(es))) else xgname fi)
  /\ nodes := graphNodes(gvalGraph(getVal(es,'gval,xgname,gv(mtGraph))))
  /\ rtoks := getRuleToks(nodes,toks)
  /\ otoks := getOccToks(nodes,toks)
  /\ reqQ2 :=
       req('defineXGraph,ql(g2dvname newgname new?),
         req('showXGraph,ql(g2dvname sgname newgname new?),
           req('startcListener,ql(newgname 'serializingListener g2dvname),reqQ')))
  /\ reqQ1 := 
    (if (xop == 'up or xop == 'dn )
     then req('xnetUpDn, ql(newxname xop toks),reqQ2)
     else (if (xop == 'selected)
     then (if rtoks == nil
           then req('xnetFps,ql(newxname otoks),reqQ2)
           else (if otoks == nil
           then req('xhideRules,ql(newxname rtoks),reqQ2)
           else req('xhideRules,ql(newxname rtoks),
                  req('defineXGraph,ql(g2dvname newgname new?),
                    req('xnetFps,ql(newxname otoks),
                     req('defineXGraph,ql(g2dvname newgname 'false),
                      req('showXGraph,ql(g2dvname sgname newgname 'false),
                        req('startcListener,
                            ql(newgname 'serializingListener g2dvname),reqQ'))))))
               fi) fi) 
     else  (if xop == 'fps 
     then req('exploreSelect, ql(g2dvname sgname xgname new? xop),
              req('xnetFps, ql(newxname),reqQ2))
     else (if xop == 'addR 
     then  req('exploreSelect, ql(g2dvname sgname xgname new? xop),
               req('xaddRules, ql(newxname),reqQ2))
     else (if xop == 'hideR 
     then  req('exploreSelect, ql(g2dvname xgname xgname new? xop),
               req('xhideRules, ql(newxname),reqQ2))
     else (if xop == 'unhideR 
     then  req('exploreSelect, ql(g2dvname xgname xgname new? xop),
               req('xunhideRules, ql(newxname),reqQ2))
     else req('logreq,ql('explore 'failed  g2dvname xgname new? xop toks),
              req('startcListener,ql(xgname 'serializingListener g2dvname), 
                  reqQ'))
     fi) fi) fi) fi) fi) fi)
  /\ reqQ0 :=
       (if xname == 'unknown or sgname == 'unknown
        then req('logreq,ql('explore 'failed xgname g2dvname new? xop toks), 
                 reqQ')
        else (if new? == 'true
               then req('forkX, ql(xname newxname newgname toks),
**** restart the caller once it is forked
                      req('startcListener,ql(xgname 'serializingListener g2dvname), 
                          reqQ1)) 
               else reqQ1 fi)  fi) .

**** chattyocc [udb] | chattyrule t
  op getOccToks : NodeList QidList -> QidList .
  eq getOccToks(ndl,toks) = nil [owise] .
  eq getOccToks(ndl,qid dir toks) = 
      (if checkNodeType(ndl,string(qid),"occ") then qid dir else nil fi)
       getOccToks(ndl,toks) .

  op getRuleToks : NodeList QidList -> QidList .
  eq getRuleToks(ndl,toks) = nil [owise] .
  eq getRuleToks(ndl,qid dir  toks) = 
      (if checkNodeType(ndl,string(qid),"rule") then qid else nil fi) 
      getRuleToks(ndl,toks) .


  op checkNodeType : NodeList String String -> Bool .
  eq checkNodeType(ndl,str,ntype) =
      (if getNode(ndl,"chattylabel",sv(str)) :: Node
       then lookupd(nodeNotes(getNode(ndl,"chattylabel",sv(str))),"type",sv(""))
            == sv(ntype)
       else false 
       fi) .

endm
**** loadmaude loaded pla-compare.maude
******************************************************************************
*** PLA based on IMaude
***  comparing graphs 
***  based on a non-explorable xnet
***  the only ops are xnet2tkb and compare?

******************************************************************************
mod PLA-COMPARE is

  inc RFE .
  inc PLA-AUX .
  inc STATUS-AUX .

****  inc META-PETRI .
****  inc PNTL2GRAPH .
  inc NEW-GRAPH2G2D .
  inc PLA-EXPLORE .


******************************************************************************
*** Variables
******************************************************************************
var ctl : Control .
var wait4s : Wait4Set .
var reqQ reqQ' reqQ0 reqQ1 reqQ2 : RequestQ .
vars es es' : ESet .
var ee : Entry .
var ee? : Entry? .
var log : Log .


vars outQ toks toks' anc0 anc1 : QidList .
vars mname pname gname newgname newpname kbname ukbname type g2dvname : Qid .
vars modname modname0 modname1 name0 gname0 name1 gname1 pgname cgname : Qid .
vars b b0 fail : Bool .
vars ctr ctr1 title subtitle ?string choices : String .
vars notes notes' gnotes pnotes xnotes opnotes : Notes .
vars graph0 graph1 graph01 ?graph ?graph' : Graph .
var res?? : [ResultPair?] .
vars t0 t1 pntlT pntlT0 pntlT1 xstateT : Term .
vars ndl ndl' ndl'' ndl0 ndl1 : NodeList .
vars edl edl' edl0 edl1 : EdgeList .
vars nid src tgt : Nat .

******************************************************************************
*** compare selection dialog
******************************************************************************
  op compareSelectTemplate : -> String .
  eq compareSelectTemplate = "(apply compareSelect %gname %choices)" .

  op mkCompareSelectExp : ESet Qid String -> String .
  eq mkCompareSelectExp(es,gname,choices) = 
        fillTemplate(compareSelectTemplate, 
             (("%gname" :~ squote(string(gname))),
             ("%choices" :~ "(array java.lang.Object " + choices + ")"))
           )
      [owise] .

  eq mkCompareSelectExp(e('gval,cgname,gnotes,gv(?graph)) ! es,gname,choices) = 
      mkCompareSelectExp(es, gname,
         (if gname == cgname or isKB(e('gval,cgname,gnotes,gv(?graph)),cgname)
             or graphNodes(?graph) == nil
          then choices
          else choices + " " +
           fillTemplate(stringArrayTemplate,
               ("%strings" :~  squote(string(cgname)) + " " +
         squote(svalString(lookupd(gnotes,"title",sv(string(cgname))))) + " " +
         squote(svalString(lookupd(gnotes,"subtitle",sv(""))))
         ) ) fi)  ) .
  


******************************************************************************

***(
(compareGraphs gname g2dvname cgname toks)

form the join of the graphs
set compare attribute of the nodes -- left,right,both

form the underlying pnet -- 
  an xnet -- its scope and graph are the joined graph
          -- its source is itself

Define graph -- needs to set the compare attributes ala DefineXGraph
Need to define colorCompareGraph
)

*******************************************************************************
**** The viewer request
**** Pop up dialog with compareGraphsCont continuation
*******************************************************************************

  eq isReq('compareGraphsChoose) = true .
****                          from gname (left graph)
  eq enabled(wait4s,
             req('compareGraphsChoose,ql(gname g2dvname toks),reqQ)) 
        = not(waiting4(wait4s,g2dvname)) .


 crl[compareGraphsChoose]:
   [nil,
    st(processing(req('compareGraphsChoose, 
                      ql(gname g2dvname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, 
       wait4s, 
       reqQ reqQ0, es, log),
    outQ
    g2dvname '\n mname '\n toks' maudePrompt ]
  if mname :=  getMaudeName(es)
  /\ ?string := withAck(mkCompareSelectExp(es,gname,""), mname,g2dvname) 
  /\ toks' := str2toks(?string)
  /\ reqQ0 :=
       (if isXnetG(es,gname) 
       then req('startcListener,ql(gname 'serializingListener g2dvname), reqQ')
       else reqQ' fi) .




*******************************************************************************
  eq isReq('compareGraphs) = true .
****                          from gname (left graph)
  eq enabled(wait4s,
             req('compareGraphs,ql(gname g2dvname cgname  toks),reqQ)) 
           = true .
 crl[compareGraphs]:
   [nil,
    st(processing(req('compareGraphs, 
                      ql(gname g2dvname cgname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ reqQ0, (if b then incGlobalCounter(es',2) else es' fi), 
       log),
    outQ]
   if ctr := getGlobalCounter(es) 
   /\ ctr1 := stringInc(ctr) 
   /\ newpname := qid("xpnet" + ctr)
   /\ newgname := qid("graph" + ctr1)
   /\ {b,es'} := compareGraphs(es,gname,cgname,newgname,newpname)
   /\ reqQ1 := 
       (if not(b)
        then req('logreq,
                  ql('compareGraphs 'failed gname  g2dvname cgname),reqQ')
        else req('defineGraph,ql(g2dvname newgname),
                req('showGraph,ql(g2dvname newgname),
                   req('startcListener,ql(newgname 'serializingListener g2dvname),
                       reqQ')))
            fi)
   /\ reqQ0 :=
       (if isXnetG(es,gname)
        then req('startcListener,ql(gname 'serializingListener g2dvname),reqQ1)
        else reqQ1 fi) .


  op parentG : ESet Qid -> Qid .
  ceq parentG(es,gname) = 
     (if pname == 'unknown
      then parentKG(es,qvalQidList(lookupd(getNotes(es,'gval,gname),   
                               "kbname",ql('unknown))))
      else pname fi) 
  if ql(pname) := 
       lookupd(getNotes(es,'gval,gname), "parent", ql('unknown)) .

**** if not a top-level (rules) kb, find its parent graph
**** pnet source -- graph of source
**** xnet source -- parentG( graph of source )
  op parentKG : ESet Qid -> Qid .
  ceq parentKG(es,kbname) =
       (if type == 'rules or type == 'pnet then gname else parentG(es,gname) fi)
  if ql(type pname) :=
       lookupd(getNotes(es,'tval, 'tkb kbname),"source",ql('unknown 'unknown))
  /\ ql(gname) := 
        (if type == 'rules 
         then ql(kbname)
         else lookupd(getNotes(es,'tval,type pname), "graph", ql('unknown))
         fi)  .
    

**** finds least common ancestor (name) of gname0 gname1
**** anc0 anc1 are the ancestors of gname0 gname1 found so far
****  top0, top1 indicate if the top (right) ancesctor is a kb
**** assumes last(anc0) is not in anc1 and vv
**** initial call is findLub(es,gname0,gname1, false,false)

  op findLub : ESet QidList QidList Bool Bool -> Qid .
  eq findLub(es, anc0, anc1, true,true) = 'unknown .
  ceq findLub(es, anc0, anc1 name1, true,false) = 
       (if gname == 'unknown
        then 'unknown
        else (if occurs(gname,anc0)
               then gname
               else findLub(es, anc0, anc1 name1 gname, true, isKB(es,gname)) 
               fi) fi)
  if gname := parentG(es,name1) .
     
  ceq findLub(es, anc0 name0, anc1, false, true) = 
       (if gname == 'unknown
        then 'unknown
        else (if occurs(gname,anc1)
               then gname
               else findLub(es, anc0 name0 gname, anc1, isKB(es,gname), true) 
               fi) fi) 
  if gname := parentG(es,name0) .

  ceq findLub(es, anc0 name0, anc1 name1, false,false) =
       (if gname0 == 'unknown or  gname1 == 'unknown
        then 'unknown
        else (if occurs(gname0,anc1 name1)
               then gname0
               else (if occurs(gname1, anc0 name0 gname0)
                     then gname1
                     else findLub(es, anc0 name0 gname0, anc1 name1 gname1, 
                                 isKB(es,gname0), isKB(es,gname1))
                     fi) fi) fi) 
  if gname0 := parentG(es,name0) 
  /\ gname1 := parentG(es,name1) .



****                  gname cgname new gname/pname
  op compareGraphs : ESet Qid Qid  Qid Qid -> BoolESet .
  op compareGraphs1 : ESet Qid Qid  Qid Qid Qid Graph Graph -> BoolESet .


  ceq compareGraphs(es,gname,cgname,newgname,newpname) =
    (if (graph0 == mtGraph or graph1 == mtGraph or pgname == 'unknown)
     then {false,es}
     else compareGraphs1(es,gname,cgname,newgname,newpname,pgname,graph0,graph1)
     fi)
  if gv(graph0) := getVal(es,'gval,gname,gv(mtGraph))
  /\ gv(graph1) := getVal(es,'gval,cgname,gv(mtGraph))
  /\ pgname := findLub(es,gname,cgname, false, false) .

**** stop if pgname is unknown or one of the graphs is empty

  ceq compareGraphs1(es,gname,cgname,newgname,newpname,pgname,graph0,graph1) =
    {res?? :: ResultPair,es'}
  if graph01 := joinGraphs(string(newgname),graph0,graph1)
  /\ title := "Comparing " +
         svalString(lookupd(getNotes(es,'gval,gname),"title", sv(string(gname))))
             + " and " +
         svalString(lookupd(getNotes(es,'gval,cgname),"title", sv(string(cgname))))
  /\ ql(kbname) := lookupd(getNotes(es,'gval,pgname),"kbname",ql('unknown))
   /\ gnotes :=
         (("source" := ql('xnet newpname)),
           ("gtype" := ql('cnet)),  
		       ("kbname" := ql(kbname)),
           ("requestor" := ql(gname)),
           ("requestop" := ql('compare)), 
           ("requestargs" := sv(string(cgname))), 
           (if isKB(es,pgname) then mt else ("parent" := ql(pgname)) fi),
           ("title" := sv(title)),
           ("subtitle" := sv("")),
           ("gatts" := ql('kbname 'source 
                          'requestor 'requestop 'requestargs)),
           ("oatts" := ql('compare)),
           ("ratts" := ql('compare 'pre 'post)),
           ("selections" := sv("false")),
****COLOR  ("colorFun" := sv("colorCNode")),
           ("colorFun" := sv("colorCnetNode")),
           ("toolBarFun" := sv("toolBarFunCnet"))
		     )
****  /\ tm(modname,pntlT) := getVal(es,'tval,'tkb kbname,dumTv)
  /\ tm(modname0,t0) :=            **** the pnet for gname
        getVal(es,'tval, 
               qvalQidList(lookupd(getNotes(es,'gval,gname),
                           "source",ql('unknown 'unknown))),
               dumTv)
  /\ pntlT0 := (if getOp(t0) == 'pnet 
                then first(getArgs(t0)) 
                else t0 fi)
  /\ tm(modname1,t1) :=            **** the pnet for cgname
        getVal(es,'tval, 
               qvalQidList(lookupd(getNotes(es,'gval,cgname),
                           "source",ql('unknown 'unknown))),
               dumTv)
  /\ pntlT1 := (if getOp(t1) == 'pnet 
                then first(getArgs(t1)) 
                else t1 fi)
  /\ fail := modname0 == 'BOOL or modname1 == 'BOOL  or modname1 =/= modname0 
  /\ res?? := (if fail 
               then noParse(0)
               else metaReduce([modname0],'compareXnet[pntlT0,pntlT1]) fi)
  /\ xstateT := (if res?? :: ResultPair
                 then getTerm(res??)
                 else mtXstateT
                 fi)
  /\ xnotes := 
          (("source" :=
             lookupd(getNotes(es,'gval,pgname),"source",ql('unknown 'unknown))),    
           ("scopegraph" := ql(pgname)),   
           ("graph" := ql(newgname)),
           ("kbname" := ql(kbname)),
           ("history" := ql('`( 'compare gname cgname '`))),
           ("scopenet" := tm(modname0,xstateT2scopeT(xstateT))),
           ("hidden" := tm(modname0,xstateT2hiddenT(xstateT))), 
           ("newnet" := tm(modname0,xstateT2newnetT(xstateT))), 
           ("seen" := tm(modname0,xstateT2soccsT(xstateT))),
           ("oup" := tm(modname0,xstateT2uoccsT(xstateT))),
           ("odn" := tm(modname0,xstateT2doccsT(xstateT))),
           ("oboth" := tm(modname0,xstateT2boccsT(xstateT))) )
  /\ es' :=
     (if res?? :: ResultPair
      then addEntry(addEntry(es,
            'tval,'xnet newpname,xnotes,tm(modname0,xstateT2xnetT(xstateT))),
            'gval, newgname,gnotes,gv(graph01))
      else es 
      fi) .

**** the generic resets could go into pntl2graph

  ops resetNodeNotes resetONotes resetRNotes : Notes -> Notes .

  eq resetNodeNotes(notes) = 
       (if svalString(lookupd(notes,"type",sv(""))) == "occ"
        then resetONotes(notes)
        else resetRNotes(notes)
         fi) .

   eq resetONotes(notes) = 
        (("type" := sv("occ")),
         ("occ" := lookupd(notes,"occ", tm('BOOL,'true.Bool))),
         ("label" := lookupd(notes,"label", sv("???"))),
         ("loc" := lookupd(notes,"loc", sv("???"))),
         ("chattylabel" := lookupd(notes,"chattylabel", sv("???"))) ) .

   eq resetRNotes(notes) = 
        (("type" := sv("rule")),
         ("label" := lookupd(notes,"label", sv("???"))),
         ("chattylabel" := lookupd(notes,"chattylabel", sv("???"))),
         ("rule" := lookupd(notes,"rule", tm('BOOL,'true.Bool))),
         ("pre" := lookupd(notes,"pre", sv(""))),
         ("post" := lookupd(notes,"post", sv(""))) ) . 

  op resetNodeLNotes : NodeList NodeList -> NodeList .
  eq resetNodeLNotes(nil,ndl)  = ndl .
  eq resetNodeLNotes(nd(nid,notes) ndl, ndl') = 
         resetNodeLNotes(ndl,ndl' nd(nid,resetNodeNotes(notes))) .




****             left      right    joined
  op joinNodes : NodeList NodeList NodeList -> NodeList .
  op joinEdges : EdgeList EdgeList EdgeList  -> EdgeList .

  eq joinNodes(ndl,nil,ndl') = 
       setNNotes(resetNodeLNotes(ndl,nil),"compare",sv("left"),nil) ndl' .
  eq joinNodes(ndl0 nd(nid,notes) ndl1, nd(nid,notes') ndl', ndl'') = 
      joinNodes(ndl0 ndl1, ndl',
             ndl'' nd(nid,insert("compare",sv("both"),resetNodeNotes(notes)))) .
  eq joinNodes(ndl,nd(nid,notes) ndl',ndl'') = 
      joinNodes(ndl,ndl',
            ndl'' nd(nid,insert("compare",sv("right"),resetNodeNotes(notes))))
     [owise] .

  eq joinEdges(edl', nil,edl) =  edl' edl .
  eq joinEdges(edl0 ed(src,tgt,notes) edl1, ed(src,tgt,notes) edl', edl) = 
      joinEdges(edl0 edl1,edl', edl ed(src,tgt,notes) ) .
  eq joinEdges(edl0, ed(src,tgt,notes) edl', edl) = 
      joinEdges(edl0, edl', edl ed(src,tgt,notes) ) [owise] .

  op joinGraphs : String Graph Graph -> Graph .
  eq joinGraphs(?string,graph0,graph1) = 
       graph(?string,mt,
             joinNodes(graphNodes(graph0), graphNodes(graph1),nil),
             joinEdges(graphEdges(graph0), graphEdges(graph1),nil) ) .


***************************************************************************
**** saving net as tkb
***************************************************************************
  eq isReq('net2KB) = true .
****                               from    viewer   user kbname       
  eq enabled(wait4s,req('net2KB,ql(gname  g2dvname ukbname toks),reqQ)) 
           = true .

 crl[net2KB]:
   [nil,
    st(processing(req('net2KB, ql(gname g2dvname ukbname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
    =>
   [nil,
    st(ready,wait4s,reqQ reqQ0,es,log),
    outQ]
  if reqQ2 := req('startListener, ql(ukbname 'graphreq g2dvname), 
                   req('defineKBGraph,ql(ukbname g2dvname),
                       reqQ'))
  /\ reqQ1 := 
       (if isXnetG(es,gname)
        then req('startcListener,ql(gname 'serializingListener g2dvname),reqQ2)
        else reqQ2 fi)
  /\ reqQ0 := req('net2tkb,ql(gname g2dvname ukbname),reqQ1)  .

***************************************************************************
  eq isReq('net2tkb) = true .
****                                 from          username          
  eq enabled(wait4s,req('net2tkb,ql(gname g2dvname  ukbname toks),reqQ)) 
           = true .

 crl[net2tkb]:
   [nil,
    st(processing(req('net2tkb, ql(gname g2dvname ukbname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,  wait4s, reqQ reqQ0, es',  log),
      outQ]
   if b0 := getVal(es,'tval,'tkb ukbname,dumTv) == dumTv **** check for existing kb
   /\ {b,es'} := (if b0
                  then net2tkb(es,gname,ukbname)
                  else {false,es}
                  fi)
   /\ reqQ0 := 
        (if b0 and b
         then reqQ'
         else (if not(b0)
               then req('sendAlert,
                         ql(g2dvname 'net2KB 'Failure 
                                    gname ukbname 'exists), nil)
               else req('logreq,ql('net2KB gname ukbname 'failed), nil)
               fi) fi)  .

  op net2tkb : ESet Qid Qid -> BoolESet .
  ceq net2tkb(es,gname,ukbname) = {b,es'}
  if ql(type pname) := **** type should be 'xnet or 'pnet
       lookupd(getNotes(es,'gval,gname),"source",ql('unknown 'unknown))
  /\ tm(modname,t1) := getVal(es,'tval,type pname,dumTv)
  /\ pntlT := (if getOp(t1) == 'pnet 
                then first(getArgs(t1)) 
                else t1 fi)
  /\ gv(?graph) := getVal(es,'gval, gname,gv(mtGraph))
  /\ opnotes := getNotes(es,'tval,type pname)
  /\ pnotes :=  (("source" := ql(type pname)), 
                 ("graph" := ql(ukbname)),
    ****         ("parent" := lookupd(opnotes,"source",ql('unknown 'unknown))),
                 (if isXnetG(es,gname) 
                  then ("history" := lookupd(opnotes,"history",ql(nil)))
                  else mt fi)
                 )
  /\ gnotes :=  (("source" := ql('tkb ukbname)),("kbname" := ql(ukbname)))
  /\ ?graph' := graph(string(ukbname),mt,graphNodes(?graph),graphEdges(?graph))
  /\ b := (type == 'xnet or type == 'pnet)
            and ?graph =/= mtGraph and modname =/= 'BOOL
  /\ es' := 
      (if b
       then addEntry(addEntry(es,
              'tval,'tkb ukbname, pnotes, tm(modname,pntlT)),
              'gval,ukbname, gnotes, gv(?graph'))
       else es fi) .


endm 


**** loadmaude loaded export-pn.maude
fmod PRINT-PN is
  inc PL-PRINT .
  inc META-PETRI .
 
  vars pntlT occsT ridT t occT preOccsT postOccsT iOccsT oOccsT bOccsT : Term .
  vars  ptl otl pntl : TermList .
  var mod : Module .
  var str : String .

**** Assume occsT reflects used initial marking

  op exportPNet2pn : Module Term -> String .
  eq exportPNet2pn(mod, 'pnet[pntlT,occsT]) =
        printOPlaces(mod, "initial=",occsT2occTL(occsT)) +
        printPNTransTL(mod,pntlT2pntTL(pntlT)) .

**** an xnet or tkb
  eq exportPNet2pn(mod,pntlT) = printPNTransTL(mod,pntlT2pntTL(pntlT)) [ owise ] .   

****  eq exportPNet2pn(mod,t) = "" [ owise ] .   **** not a pnet


  op printOPlaces : Module String TermList  -> String .
  eq printOPlaces(mod, str, empty) = "" .
  eq printOPlaces(mod, str, (occT, otl)) =
       str + occ2label(mod,occT) + "\n" + printOPlaces(mod, str, otl) .

  op printPNTransTL :  Module TermList -> String .
  op printPNTrans : Module Term -> String .

  eq printPNTransTL(mod,empty) = "" .
  eq printPNTransTL(mod,(t, pntl)) =
      printPNTrans(mod,t) + printPNTransTL(mod,pntl) .

  eq printPNTrans(mod,'pnTrans[ridT, iOccsT, oOccsT, bOccsT]) =
   "\n-------------------------\n" +
   "transition=" + printRidTAll(ridT) + "\n\n" +
    printOPlaces(mod,"input=",(occsT2occTL(iOccsT), occsT2occTL(bOccsT)))
         + "\n\n" +
    printOPlaces(mod,"output=",(occsT2occTL(oOccsT), occsT2occTL(bOccsT)))
         + "\n\n"  .

  eq printPNTrans(mod,t) = "" [owise] .  **** not a pntrans


endfm
**** loadmaude loaded export-sbml.maude
fmod PNET2SBML-TEMPLATES is
  inc TEMPLATES .

**** id's can contain only letters, underscore, digits 
**** id's and must begin with letter or underscore 
**** names are xml strings, ampersand, dquote and sqoute must be xescapted 

op speciesSBMLTemplate : -> String .
eq speciesSBMLTemplate =
"<species id=%id name=%name compartment=%loc initialConcentration=%init/>" .

  ops reactionSBMLTemplate mreactionSBMLTemplate : -> String .
  eq reactionSBMLTemplate =
"<reaction id=%id name=%name>\n\
  <listOfReactants>\n\
    %reactants\n\
  </listOfReactants>\n\
  <listOfProducts>\n\
    %products\n\
  </listOfProducts>\n\
</reaction>" .


eq mreactionSBMLTemplate =
"<reaction id=%id name=%name>\n\
  <listOfReactants>\n\
    %reactants\n\
  </listOfReactants>\n\
  <listOfProducts>\n\
    %products\n\
  </listOfProducts>\n\
  <listOfModifiers>\n\
    %modifiers\n\
  </listOfModifiers>\n\
</reaction>" .


op pnetSBMLTemplate : -> String .
eq pnetSBMLTemplate =
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\
<sbml level=\"2\" version=\"1\" xmlns=\"http://www.sbml.org/sbml/level2\">\n\
<model id=%modelid name=%modelname >\n\
  <listOfCompartments>\n\
    <compartment id=\"unknown\" name=\"unrecognized locate\"/>\n\
    <compartment id=\"out\" name=\"outside the cell\"/>\n\
    <compartment id=\"cytosol\" size=\"2.5\"/>\n\
    <compartment id=\"mitochondria\" size=\"0.3\"/>\n\
    <compartment id=\"CLo\" name=\"Cell out\" />\n\
    <compartment id=\"CLm\" name=\"Cell membrane\" />\n\
    <compartment id=\"CLi\" name=\"Cell in\" />\n\
    <compartment id=\"CLc\" name=\"Cell cytosol\" />\n\
    <compartment id=\"NUo\" name=\"Nucleus out\" />\n\
    <compartment id=\"NUm\" name=\"Nucleus membrane\" />\n\
    <compartment id=\"NUi\" name=\"Nucleus in\" />\n\
    <compartment id=\"NUc\" name=\"Nucleus cytosol\" />\n\
    <compartment id=\"MOo\" name=\"Mitochondria Outer out\" />\n\
    <compartment id=\"MOm\" name=\"Mitochondria Outer membrane\" />\n\
    <compartment id=\"MOi\" name=\"Mitochondria Outer in\" />\n\
    <compartment id=\"MOc\" name=\"Mitochondria Outer cytosol\" />\n\
    <compartment id=\"MIo\" name=\"Mitochondria Inner out\" />\n\
    <compartment id=\"MIm\" name=\"Mitochondria Inner membrane\" />\n\
    <compartment id=\"MIi\" name=\"Mitochondria Inner in\" />\n\
    <compartment id=\"MIc\" name=\"Mitochondria Inner cytosol\" />\n\
    <compartment id=\"ERo\" name=\"EndoplasmicReticulum out\" />\n\
    <compartment id=\"ERm\" name=\"EndoplasmicReticulum membrane\" />\n\
    <compartment id=\"ERi\" name=\"EndoplasmicReticulum in\" />\n\
    <compartment id=\"ERc\" name=\"EndoplasmicReticulum cytosol\" />\n\
    <compartment id=\"PXo\" name=\"PeroXisome out\" />\n\
    <compartment id=\"PXm\" name=\"PeroXisome membrane\" />\n\
    <compartment id=\"PXi\" name=\"PeroXisome in\" />\n\
    <compartment id=\"PXc\" name=\"PeroXisome cytosol\" />\n\
    <compartment id=\"GAo\" name=\"Golgi Apparatus out\" />\n\
    <compartment id=\"GAm\" name=\"Golgi Apparatus membrane\" />\n\
    <compartment id=\"GAi\" name=\"Golgi Apparatus in\" />\n\
    <compartment id=\"GAc\" name=\"Golgi Apparatus cytosol\" />\n\
    <compartment id=\"LEo\" name=\"Late Endosome out\" />\n\
    <compartment id=\"LEm\" name=\"Late Endosome membrane\" />\n\
    <compartment id=\"LEi\" name=\"Late Endosome in\" />\n\
    <compartment id=\"LEc\" name=\"Late Endosome cytosol\" />\n\
    <compartment id=\"EEo\" name=\"Early Endosome out\" />\n\
    <compartment id=\"EEm\" name=\"Early Endosome membrane\" />\n\
    <compartment id=\"EEi\" name=\"Early Endosome in\" />\n\
    <compartment id=\"EEc\" name=\"Early Endosome cytosol\" />\n\
    <compartment id=\"LYo\" name=\"Lysosome out\" />\n\
    <compartment id=\"LYm\" name=\"Lysosome membrane\" />\n\
    <compartment id=\"LYi\" name=\"Lysosome in\" />\n\
    <compartment id=\"LYc\" name=\"Lysosome cytosol\" />\n\
    <compartment id=\"CPo\" name=\"Clathrin Coated Pits out\" />\n\
    <compartment id=\"CPm\" name=\"Clathrin Coated Pits membrane\" />\n\
    <compartment id=\"CPi\" name=\"Clathrin Coated Pits in\" />\n\
    <compartment id=\"CPc\" name=\"Clathrin Coated Pits cytosol\"/>\n\
    <compartment id=\"Sig\" name=\"a place for signatures\"/>\n\
  </listOfCompartments>\n\
  <listOfSpecies>\n\
    %specieslist\n\
  </listOfSpecies>\n\
  <listOfReactions>\n\
    %reactionlist\n\
  </listOfReactions>\n\
</model>\n\
</sbml>\n\
</xml>"
.
endfm



fmod GRAPH-SBML is
  inc PNET2SBML-TEMPLATES .
  inc GRAPH .
  inc SVAL .
  inc NAT-QID .

  vars  ?string : String .
  vars id name init loc : String .
  vars  reactions species reaction reactants products modifiers : String .
  vars specieslist reactionlist : String .
  var n : Nat .
  var notes : Notes .
  vars nodes occNodes ruleNodes : NodeList .
  var edges : EdgeList .
  var ns preNats postNats inats onats bnats : NatList .

**** op decls
***(
  op mkSBMLNetStr     : Graph  -> String .

  op mkSBMLSpeciesStr  : NodeList String -> String .
  op mkSpecies : String String String String -> String .

  op mkSBMLReactionsStr : NodeList String -> String .
  op mkReaction : String String String String -> String .
  op mkmReaction : String String String String String -> String .
  op mkSpeciesRef : String -> String .
  op mkmSpeciesRef : String -> String .

  op mkPnetSBML : String String String String -> String  .
  ops mkSBMLSpeciesRefStr mkmSBMLSpeciesRefStr : NatList -> String .
)

  op mkReaction : String String String String -> String .
  eq mkReaction(id,name,reactants,products) =
      fillTemplate(reactionSBMLTemplate,
                   (("%id" :~ squote(id)),
                    ("%name" :~ squote(name)),
                    ("%reactants" :~ reactants),
                    ("%products" :~ products)) ) .

  op mkmReaction : String String String String String -> String .
  eq mkmReaction(id,name,reactants,products,modifiers) =
      fillTemplate(mreactionSBMLTemplate,
		   (("%id" :~ squote(id)),
		    ("%name" :~ squote(name)),
		    ("%reactants" :~ reactants),
		    ("%products" :~ products),
		    ("%modifiers" :~ modifiers)) ) .

  op mkSBMLReactionsStr : NodeList String -> String .
  eq mkSBMLReactionsStr(nil,reactions) = reactions + "\n"  .
  ceq mkSBMLReactionsStr(nd(n,notes) nodes,reactions) =
       mkSBMLReactionsStr(nodes, reactions  + "\n    " + reaction)
  if id := "t" + string(n,10)
  /\ sv(name) := lookupd(notes,"chattylabel",sv(id))
  /\ preNats := str2natl(svalString(lookupd(notes,"pre",sv(""))))
  /\ postNats := str2natl(svalString(lookupd(notes,"post",sv(""))))
  /\ inats := lDiff(preNats,postNats)
  /\ onats := lDiff(postNats,preNats)
  /\ bnats := lDiff(preNats,inats)
  /\ reactants := mkSBMLSpeciesRefStr(inats)
  /\ products := mkSBMLSpeciesRefStr(onats)
  /\ modifiers := mkmSBMLSpeciesRefStr(bnats)
  /\ reaction := (if bnats == nil
                   then mkReaction(id,name,reactants,products)
                   else mkmReaction(id,name,reactants,products,modifiers)
                   fi) .

  op mkSpeciesRef : String -> String .
  eq mkSpeciesRef(id) = "<speciesReference species=" + squote(id) + "/>" .

  op mkmSpeciesRef : String -> String .
  eq mkmSpeciesRef(id) = 
    "<modifierSpeciesReference species=" + squote(id) + "/>" .

  ops mkSBMLSpeciesRefStr mkmSBMLSpeciesRefStr : NatList -> String .
  eq mkSBMLSpeciesRefStr(nil) = "" .
  eq mkSBMLSpeciesRefStr(n ns) = 
        mkSpeciesRef("o" + string(n,10)) + "\n    " +  mkSBMLSpeciesRefStr(ns) .
  eq mkmSBMLSpeciesRefStr(nil) = "" .
  eq mkmSBMLSpeciesRefStr(n ns) =
      mkmSpeciesRef("o" + string(n,10)) + "\n    " +  mkmSBMLSpeciesRefStr(ns) .


  op mkSpecies : String String String String -> String .
  eq mkSpecies(id,name,init,loc) =
      fillTemplate(speciesSBMLTemplate,
                   (("%id" :~ squote(id)),
                    ("%name" :~ squote(name)),
                    ("%init" :~ squote(init)),     **** 0 or 1
                    ("%loc" :~ squote(loc))) ) .

  op mkSBMLSpeciesStr  : NodeList String -> String .
  eq mkSBMLSpeciesStr(nil,species) = species .
  ceq mkSBMLSpeciesStr(nd(n,notes) nodes,species) =
       mkSBMLSpeciesStr(nodes,
           species + "\n    " + mkSpecies(id,name,init,loc)) 
  if id := "o" + string(n,10)
  /\ sv(name) := lookupd(notes,"chattylabel", lookupd(notes,"label",sv(id)))
  /\  init := (if lookupd(notes,"init",sv("false")) == sv("true")
               then "1"
               else "0"
               fi)
  /\ sv(loc) :=  lookupd(notes,"loc",sv("")) .

  op mkPnetSBML : String String String String -> String  .
  eq mkPnetSBML(id,name,specieslist,reactionlist) =
      fillTemplate(pnetSBMLTemplate,
		   (("%modelid" :~ squote(id)),
		    ("%modelname" :~ squote(name)),
		    ("%specieslist" :~ specieslist),
		    ("%reactionlist" :~ reactionlist)) ) .

  op mkSBMLNetStr     : Graph  -> String .
  ceq mkSBMLNetStr(graph(?string,notes,nodes,edges)) =
         mkPnetSBML(?string,?string,species,reactions)
   if occNodes := getNodes(nodes,"type",sv("occ"))
   /\ ruleNodes := getNodes(nodes,"type",sv("rule"))
   /\ species := mkSBMLSpeciesStr(occNodes,"") 
   /\ reactions := mkSBMLReactionsStr(ruleNodes, "")
  .

endfm

fmod TEST-GRAPH-SBML is
  inc GRAPH-SBML .



op tinySbml : -> String .
eq tinySbml = mkPnetSBML("tinySbml","tinySbml",
       mkSpecies("n0","EGF-out","1","out") + "\n    " +
       mkSpecies("n1","EgfR-CLm","1","CLm") + "\n    " +
       mkSpecies("n2","EGF-CLo","0","CLo") + "\n    " +
       mkSpecies("n3","EgfR-act-CLm","0","CLm") + "\n    " +
       mkSpecies("n4","Grb2-CLc","1","CLc") + "\n    " +
       mkSpecies("n5","Grb2-CLi","0","CLc"), 
       mkReaction("t0","1.EgfR.on",
                  mkSpeciesRef("n0") +  "\n    " + mkSpeciesRef("n1"),
                  mkSpeciesRef("n2") +  "\n    " + mkSpeciesRef("n3")) + "\n"
       +
       mkmReaction("t1","761.Grb2.by.EgfR",
                  mkSpeciesRef("n4"),
                  mkSpeciesRef("n5"),
                  mkmSpeciesRef("n3"))  
       )  .

endfm


***(

)
**** loadmaude loaded pla-export.maude
******************************************************************************
*** PLA based on IMaude
******************************************************************************
mod PLA-EXPORT is
  inc RFE .
  inc PLA-AUX .
  inc STATUS-AUX .

  inc PNTL2GRAPH .
****  inc GRAPH2G2D .
  inc NEW-GRAPH2G2D .
  inc PRINT-PN .
  inc GRAPH-SBML .


******************************************************************************
*** Variables
******************************************************************************
var ctl : Control .
var wait4s : Wait4Set .
var reqQ reqQ' reqQ0 reqQ1 reqQ2 : RequestQ .
vars es es' : ESet .
var ee : Entry .
var ee? : Entry? .
var log : Log .

var b : Bool .
var n nodeId : Nat .
vars maudename mname g2dname g2dvname kbname modname modname' : Qid .
vars type tkbFname occsFname graphFname nid flag qid : Qid .
vars fname gname pname newgname newpname pathpname dname format : Qid .
vars outQ toks toks' rids srctoks : QidList .
var ?graph : Graph .
vars pntlT pntlT' pnetT occsT ioccsT ioccsT' uoccsT roccsT nT occT : Term .
vars goccsT aoccsT ridsT ugoccsT : Term .
var tl occsTL : TermList .
vars dnotes gnotes pnotes notes : Notes .
vars res0?? res1?? res?? res2?? res3?? : [ResultPair?] .
vars id ?string status str gstr astr rstr title subtitle : String .
vars ctr  ctr1 ctr2 netStr taskStr : String .
vars ndl ndl' nds nodes pndl : NodeList .
var edl : EdgeList .
 
******************************************************************************
*** Graph as lsp
**** writes graph to file (in g2d format)
******************************************************************************

  eq isReq('graph2file) = true .
  eq enabled(wait4s,req('graph2file,ql(gname g2dvname fname toks),reqQ)) = true .

**** assumes dgraph has been made and stored as petri-graph under gname
  rl[graph2file]:
   [nil,
    st(processing(req('graph2file,ql(gname g2dvname fname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s,
       (reqQ 
        req('filewrite, 
             ql(fname 'C graph2fileToks(es,gname,g2dvname)), reqQ')), 
       es,
       log),
       outQ ] .

  op graph2fileToks : ESet Qid Qid -> QidList .
  ceq graph2fileToks(es,gname,g2dvname) = str2toks(?string) 
    if gv(?graph) := getVal(es,'gval,gname,gv(mtGraph)) 
    /\ gnotes := getNotes(es,'gval,gname)
    /\ sv(title) := lookupd(gnotes,"title", sv(string(gname)))
    /\ sv(subtitle) := lookupd(gnotes,"subtitle", sv(""))
    /\ ql(kbname) := lookupd(gnotes,"kbname", ql(gname))
****    /\  ?string :=  mkSavedGraphExp(kbname,?graph,title,subtitle,loadprefix)
     /\  ?string :=  mkSavedNewGraphExp(gname,?graph,gnotes)   
   . 

******************************************************************************
 
******************************************************************************
*** Graph as lsp NEW VERSION
**** writes graph to file (in g2d format)
******************************************************************************

  eq isReq('graph2filex) = true .
  eq enabled(wait4s,req('graph2filex,ql(gname g2dvname fname toks),reqQ)) = true .

**** assumes dgraph has been made and stored as petri-graph under gname
  rl[graph2filex]:
   [nil,
    st(processing(req('graph2filex,ql(gname g2dvname fname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s,
       (reqQ 
        req('filewrite, 
             ql(fname 'C graph2filexToks(es,gname,g2dvname)), reqQ')), 
       es,
       log),
       outQ ] .

  op graph2filexToks : ESet Qid Qid -> QidList .
  ceq graph2filexToks(es,gname,g2dvname) = str2toks(?string) 
    if gv(?graph) := getVal(es,'gval,gname,gv(mtGraph)) 
    /\ gnotes := getNotes(es,'gval,gname)
    /\  ?string :=  mkSavedNewGraphExp(gname,?graph,gnotes)  . 

******************************************************************************
  eq isReq('exportGraph) = true .
  eq enabled(wait4s,req('exportGraph,ql(gname g2dvname fname format toks),reqQ)) 
          = true .

  crl[exportgraph]:
   [nil,
    st(processing(req('exportGraph, ql(gname g2dvname fname format toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   (if ?graph == mtGraph
    then [ nil, 
           st(ready, 
              wait4s,
              (reqQ req('msgForUser,
                        ql('exportGraph 'no 'graph gname fname format),reqQ')),
              es,log), 
           outQ ]
     else
      [ nil, 
        st(ready, 
           wait4s,
           (reqQ
            req('filewrite,
                 ql(qid(string(fname) + "." + string(format))
                   'C 
                    str2toks(?string)),
                  reqQ')),
              es,log), 
           outQ ]
     fi)
   if ?graph := gvalGraph(getVal(es,'gval,gname,gv(mtGraph)))
   /\ gnotes := getNotes(es,'gval,gname)
   /\  ql(srctoks) := lookupd(getNotes(es,'gval,gname),"source",ql(nil))
   /\  tm(modname,pnetT)  := getVal(es,'tval, srctoks, tm('BOOL,'true.Bool))
   /\  ?string :=
         (if format == 'sbml
          then mkSBMLNetStr(?graph)
          else (if format == 'pn
                then exportPNet2pn([modname],pnetT)
                else (if format == 'lsp
                      then mkSavedNewGraphExp(gname,?graph,gnotes)  
                      else ""
                      fi) fi)  fi) .

  eq isReq('checkFileWrite) = true .
  eq enabled(wait4s,req('checkFileWrite,ql(qid toks),reqQ)) = true .

crl[checkFileWrite]:
   [nil,
    st(processing(req('checkFileWrite, ql(qid toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil, st(ready,  wait4s, (reqQ reqQ0), es, log), outQ ]
   if reqQ0 :=  
         (if getNth(0,toks,'FAILED) == 'writeOK
          then req('logreq, ql(qid toks),reqQ')
          else req('logreq, ql(qid toks),nil) fi) .


endm
**** loadmaude loaded parse-panther.maude
fmod SEXPSTR2QIDS is
  inc QID-LIST .
  inc NAT-LIST .

   var str : String .
   vars max len cur beg end : Nat .
   var toks : QidList .

**** tokens are separated by parens or by whitespace

  op isSep : Char -> Bool .
  eq isSep("(") = true .
  eq isSep(")") = true .
  eq isSep(" ") = true .
  eq isSep("\n") = true .
  eq isSep("\t") = true .
  eq isSep(str) = false [owise] .

  op isTok : Char -> Bool .
  eq isTok("(") = true .
  eq isTok(")") = true .
  eq isTok(str) = false [owise] .

****                  max cur
  op nextTok : String Nat Nat -> NatList .     **** len 2
  eq nextTok(str,max,cur) =
**** find first non-sep then the next sep
     (if cur >= max then (max max)
     else  (if isSep(substr(str,cur,1))
            then (if isTok(substr(str,cur,1))
                  then (cur (s cur))
                  else nextTok(str, max, s cur)
                  fi)
            else nextTok1(str,max,cur,s cur)
            fi ) fi) .

****                  max  beg next
  op nextTok1 : String Nat Nat Nat -> NatList .
  eq nextTok1(str,max,beg,cur) =
   (if cur >= max then (beg max)
     else  (if isSep(substr(str,cur,1))
            then (beg cur)
            else nextTok1(str,max,beg,s cur)
            fi ) fi) .


**********************
  op sexpstr2ql : String -> QidList .
  op sexpstr2ql1 : String Nat Nat QidList -> QidList .
  eq sexpstr2ql(str) = 
    (if str == "" then nil else sexpstr2ql1(str,length(str),0,nil) fi) .
  ceq sexpstr2ql1(str,len,cur,toks) = 
      (if beg >= end or beg >= len
       then toks
       else sexpstr2ql1(str,len,end, toks qid(substr(str,beg,sd(end,beg))) )  
       fi) 
   if (beg end) := nextTok(str,len,cur) .

endfm

fmod TEST-SEXPRSTR2QIDS is
  inc SEXPSTR2QIDS .

  ops sexpstr1 sexpstr2 : -> String .
  eq sexpstr1 =  "(Occurrence M2s211 (name Nck1)(class PROTEIN))" .
  eq sexpstr2 =   "(OList " + sexpstr1 + " " + sexpstr1 + ")" .

  ops ql1 ql2 : -> QidList .
  eq ql1 = sexpstr2ql(sexpstr1) .
  eq ql2 = sexpstr2ql(sexpstr2) .

endfm


fmod PARSE-PANTHER is
  inc SPLIT-PAREN .
***   inc META-LEVEL .
  inc QSTNOTES .
  inc META-PETRI .

***(
Need new declarations in theops and extensions of occT manipulations
  op newC : String  -> Thing .
  op newL : String  -> LocName .
)
*****************  Summary of opdecls
***(
****                     spacer accum
  op qidl2strx : QidList String String -> String .

****             modname toks      tkb
****       (Pathway id occlist rxlist)
  op parsePathway : Qid QidList -> TVal .  **** tm(modname,pntlT )
****         modname toks       onotes
****        (OccurrenceList toks)
  op parseOccs : Qid QidList -> Notes .    **** "occid" := tm(modname,occT)

****               modname toks   cnotes onotes
****  cnotes are partially parsed complexes 
****        "occid" := ql(compartment,position,components)
****  ...   (Occurrence id toks) ...
  op parseSimpleOccs : Qid QidList Notes Notes -> Notes .


****  makes complex occ when all components are defined in onotes
****                       onotes filling pend new?
****  iterate because some components may be complexes.  stop when nothing new
   op parseComplexOccs : Qid Notes Notes Notes Bool -> Notes .

****         modname toks   onotes   pntlT
****        (ReactionList rtoks)
   op parseRx : Qid QidList Notes -> Term .
**** (Reaction tok id (Reactants rtoks)(Products ptoks)(Modifiers mtoks)) 
**** splits off reaction items 
  op parseRx1 : Qid QidList Notes TermList -> Term .
**** parses one reaction item 
  op parseRx2 : Qid QidList Notes -> TermList .          **** 0 or 1   


)

   vars tok tag id modname class name activity : Qid .
   vars position compartment modification : Qid .
   vars toks otoks rtoks ptoks mtoks toks0 toks1 toks2 components : QidList .
   vars notes onotes anotes cnotes notes' : Notes .   
   vars occT occsT locT thingT pntT pntlT : Term .
   vars tl otl pntTL : TermList .
   vars spacer str idstr : String .
   vars b b0 : Bool .
   vars res0?? res1?? : [ResultPair?] .

**** string without white space  
****                  spacer    accum
  op qidl2strx : QidList String String -> String .
  eq qidl2strx(nil,spacer,str) = str .
  eq qidl2strx(tok toks,spacer,str) = 
       qidl2strx(toks,spacer,str + spacer + string(tok)) . 

  
   op parsePathway : Qid QidList -> TVal .
   ceq parsePathway(modname, '`( 'Pathway id toks '`)) = tm(modname, pntlT) 
   if {b,otoks,toks1} := splitParen(toks)       **** the occurrence list
   /\ {b0,rtoks,toks2} := splitParen(toks1)     **** the reaction list
   /\ onotes := (if b then parseOccs(modname,otoks) else mt fi)
   /\ pntlT := (if b0 and b 
                 then parseRx(modname,rtoks,onotes)  
                 else 'nil.PNTransList fi) .

   eq parsePathway(modname, toks) = tm(modname, 'nil.PNTransList) [owise]  .

   op parseOccs : Qid QidList -> Notes .    *** "occid" := tm(modname,occT)
   op parseSimpleOccs : Qid QidList Notes Notes -> Notes .

****                       occs   tofill pend  new?
   op parseComplexOccs : Qid Notes Notes Notes Bool -> Notes .
 
   eq parseOccs(modname,'`( 'OccurrenceList toks '`)) = 
        parseSimpleOccs(modname,toks,mt,mt) .
   eq parseOccs(modname,toks) = mt [owise] .

  ceq  parseSimpleOccs(modname,toks,cnotes,onotes) =
      (if b 
       then (if class == 'COMPLEX 
             then parseSimpleOccs(modname,toks1,(cnotes, notes), onotes)
             else parseSimpleOccs(modname,toks1,cnotes, (onotes, notes))
             fi)
       else parseComplexOccs(modname,onotes,cnotes,mt,false) 
       fi)
**** splits off first atom or balanced paren group from toks
     if {b,otoks,toks1} := splitParen(toks) 
     /\ anotes := occtoks2notes(otoks)
     /\ ql(class) := lookupd(anotes,"class",ql('unknown))
     /\ notes := (if class == 'COMPLEX
                  then parseComplex(modname,anotes) 
                  else parseOcc(modname,anotes) 
                  fi) .


****                      occs  tofill pend  new?
****                  Qid Notes Notes Notes Bool -> Notes .
   eq parseComplexOccs(modname,onotes,mt,notes,b) =
        (if b
         then parseComplexOccs(modname,onotes,notes,mt,false) 
         else onotes fi) .
           
   ceq parseComplexOccs(modname,onotes,
                       ((idstr := ql(compartment position components)), cnotes),
                       notes,b) =
       (if b0 
        then parseComplexOccs(modname,(onotes,anotes),cnotes,notes,true)
        else parseComplexOccs(modname,onotes,cnotes,
                         (notes,(idstr := ql(compartment position components))),b)
        fi)
   if b0 := defined(onotes,components)
   /\ anotes :=
      (if b0
       then  (idstr := tm(modname,'<_`,_>[mkComplexT(onotes,components,empty), 
                                      mkLocT(modname,compartment,position)]))
      else mt
      fi) .

  op defined : Notes QidList -> Bool .
  eq defined(notes,nil) = true .
  eq defined(notes,tok components) =
      (if lookupd(notes,string(tok),dumTv) == dumTv
       then false 
       else defined(notes,components) fi) .


**** use new complex for now
  op mkComplexT : Notes QidList TermList -> Term .
  eq mkComplexT(notes,nil,tl) = 
        '<_>[(if tl == empty then 'empty.Soup else
             (if tl :: Term then tl else '__[tl] fi) fi)] .
  ceq mkComplexT(notes,tok components,tl) =
     (if otl :: Term
      then mkComplexT(notes,components,(tl,otl))
      else mkComplexT(notes,components,tl)
      fi)
  if tm(modname,occT) := lookupd(notes,string(tok),dumTv)
  /\ otl := (if modname == 'BOOL then empty else occT2thT(occT) fi) .
  

**** Helper 
**** assumes toks have form (tag val)*  
**** val is tok or (modification modAlist) or (components toks)

  op occtoks2notes : QidList -> Notes .
  op atoks2notes : QidList Notes -> Notes .
  op atoks2note : QidList -> Notes .
  op modtoks2note : QidList -> Notes .

  eq occtoks2notes('`( 'Occurrence id toks '`)) = 
         atoks2notes(toks,("occid" := ql(id))) .
  eq occtoks2notes(toks) = mt [owise] .

  ceq atoks2notes(toks,anotes) =
      (if b 
       then atoks2notes(toks1, (anotes, atoks2note(toks0)))
       else anotes
       fi)
  if {b,toks0,toks1} := splitParen(toks) .
  
  eq atoks2note('`( tag toks '`)) = 
       (if tag == 'modification 
        then modtoks2note(toks) 
        else (string(tag) := ql(toks)) fi) .
  eq atoks2note(toks) = mt [owise] .

  eq modtoks2note('`( 'modifier tok '`)) = (string('mod) := ql(tok)) .
  eq modtoks2note(toks) = mt [owise] .

  op parseComplex : Qid Notes -> Notes .
  ceq parseComplex(modname,onotes) = 
        (string(id) := ql(compartment position components))
  if ql(id) :=  lookupd(onotes,"occid",ql('unknown))
  /\ ql(class)  := lookupd(onotes,"class",ql('unknown))
  /\ ql(components) := lookupd(onotes,"components",ql('unknown))
  /\ ql(compartment) := lookupd(onotes,"compartment",ql('unknown))
  /\ ql(position) := lookupd(onotes,"position",ql('unknown)) .

  op parseOcc : Qid Notes -> Notes .
  ceq parseOcc(modname,onotes) =
         ( string(id) := tm(modname,'<_`,_>[thingT,locT]) )
  if ql(id) :=  lookupd(onotes,"occid",ql('unknown))
  /\ ql(class)  := lookupd(onotes,"class",ql('unknown))
  /\ locT := mkLocT(modname,
                   qvalQidList(lookupd(onotes,"compartment",ql('unknown))),
                   qvalQidList(lookupd(onotes,"position",ql('unknown))))
  /\ thingT := mkThingT(modname, id,
                      class,
                      qvalQidList(lookupd(onotes,"name",ql('unknown))),
                      qvalQidList(lookupd(onotes,"mod",ql('none))),
                      qvalQidList(lookupd(onotes,"activity",ql('unknown)))) .

  op modToks : Qid Qid -> QidList .
  eq modToks('none,'inactive) = 'none .
  eq modToks('none,'active) = 'act .
  eq modToks('phosphorylated,activity) = 'phos .
  eq modToks(modification,activity) = '??? [owise] .  **** should not parse

****        modname,id,class,name,mod,activity
  op mkThingT : Qid Qid Qid Qid Qid Qid -> Term .
  op mkLocT : Qid Qid Qid -> Term .

  ceq mkThingT(modname,id,class,name,modification,activity) =
     (if res0?? :: ResultPair and res1?? :: ResultPair
      then (if getTerm(res1??) == 'none.ModSet
            then getTerm(res0??)
            else '`[_-_`][getTerm(res0??),getTerm(res1??)]
            fi)
      else 'newC[upTerm(qidl2strx('id: id 'class: class 'name: name
                                   'mod: modification
                                    'activity: activity,"~",""))]
      fi )
  if res0?? := (if class == 'PROTEIN
                then metaParse([modname],name,'Protein)
                else (if class == 'SIMPLE_MOLECULE
                then metaParse([modname],name,'Chemical)
                else (if class == 'RNA  **** Is this right??
                then metaParse([modname],name,'DNA)
                else (if (class == 'PHENOTYPE and name == 'Translation)
                then metaParse([modname],'PROTEIN-SYNTHESIS-ON, 'Signature)
                else noParse(0) fi) fi) fi) fi)
  /\ toks := modToks(modification,activity)
  /\ res1?? := metaParse([modname],toks,'ModSet) .

  eq  mkLocT(modname,'default,position) = 'Out.LocName .
  eq  mkLocT(modname,'CLc,'inside)  = 'CLc.LocName . 
  eq  mkLocT(modname,'CLc,'innerSurface) = 'CLi.LocName .
  eq  mkLocT(modname,'CLc,'transmembrane) = 'CLm.LocName .
  eq  mkLocT(modname,compartment,position) =
       'newL[upTerm(qidl2strx(compartment position,"~",""))] .

****   /\ pntlT := parseRx(modname,rtoks,onotes) .
  op parseRx : Qid QidList Notes -> Term .
  op parseRx1 : Qid QidList Notes TermList -> Term .
  op parseRx2 : Qid QidList Notes -> TermList .          **** 0 or 1   


  eq parseRx(modname,'`( 'ReactionList toks '`),onotes) =
       parseRx1(modname,toks,onotes,empty) .
  eq parseRx(modname,toks,onotes) = 'nil.PNTransList [owise] .

  ceq parseRx1(modname,toks,onotes,tl) =
      (if b 
       then parseRx1(modname,toks1,onotes, (tl,pntTL))
       else pntTL2pntlT(tl)
       fi)
  if {b,toks0,toks1} := splitParen(toks)
  /\ pntTL := parseRx2(modname,toks0,onotes) .

  eq parseRx2(modname,'`( 'Reaction tok id 
                         '`( 'Reactants rtoks '`)
                         '`( 'Products ptoks '`)
                         '`( 'Modifiers mtoks '`)  '`),  onotes) =
      'pnTrans[mkQidConst(id),toks2occsT(rtoks,onotes,empty),
                  toks2occsT(ptoks,onotes,empty),
                  toks2occsT(mtoks,onotes,empty)] .

  eq parseRx2(modname,toks,onotes) = empty [owise] .

  op toks2occsT :  QidList Notes TermList -> Term .
  eq toks2occsT(nil,notes,tl)  = occTL2occsT(tl) .
  ceq toks2occsT(tok toks, notes,tl) =
       toks2occsT(toks,notes,
                  (if occT == tvalTerm(dumTv)
                   then tl
                   else (tl, occT) fi))
  if occT := tvalTerm(lookupd(notes,string(tok),dumTv)) .
   
endfm


**** loadmaude loaded pla-import.maude
******************************************************************************
*** PLA based on IMaude
******************************************************************************
mod PLA-IMPORT is
  inc RFE .
  inc PLA-AUX .
  inc STATUS-AUX .
  
  inc PARSE-PANTHER .


******************************************************************************
*** Variables
******************************************************************************
var ctl : Control .
var wait4s : Wait4Set .
var reqQ reqQ' reqQ0 reqQ1 reqQ2 : RequestQ .
vars es es' : ESet .
var ee : Entry .
var ee? : Entry? .
var log : Log .

var b : Bool .
var n nodeId : Nat .
vars  mname g2dname g2dvname kbname modname modname' : Qid .
vars type tkbFname occsFname graphFname nid flag qid tmp : Qid .
vars fname gname pname newgname newpname pathpname dname format : Qid .
vars outQ toks toks' rids srctoks : QidList .
var ?graph : Graph .
vars pntlT pntlT' pnetT occsT ioccsT ioccsT' uoccsT roccsT nT occT : Term .
vars goccsT aoccsT ridsT ugoccsT : Term .
var tl occsTL : TermList .
vars dnotes gnotes pnotes notes : Notes .
vars res0?? res1?? res?? res2?? res3?? : [ResultPair?] .
vars id ?string status str gstr astr rstr title subtitle : String .
vars ctr  ctr1 ctr2 netStr taskStr : String .
vars ndl ndl' nds nodes pndl : NodeList .
var edl : EdgeList .
 
******************************************************************************
*** Import CD pathway
**** 
******************************************************************************

  eq isReq('cd2plkb) = true .
  eq enabled(wait4s,req('cd2plkb,ql(tmp  modname kbname toks),reqQ)) = true .

**** assumes dgraph has been made and stored as petri-graph under gname
  crl[cd2plkb]:
   [nil,
    st(processing(req('cd2plkb,ql(tmp  modname kbname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, (reqQ reqQ0), es', log),
   outQ ] 
  if {b,es'} :=  cd2plkb(es,tmp,modname,kbname) 
  /\ reqQ0 := (if b then reqQ' else req('logreq,ql('cd2plkb 'failed),nil) fi) .

****
  op cd2plkb : ESet Qid Qid Qid -> BoolESet .
  ceq cd2plkb(es,tmp,modname,kbname) = {b,es'}
  if ql(toks') := getVal(es,'qval,tmp,ql(nil))
**** toks' ~ 'content fname toks
  /\ toks := getPost(2,toks')
  /\ tm(modname',pntlT) := parsePathway(modname,toks) 
  /\ pnotes := (("source" := ql('CD modname)))
  /\ b := toks =/= nil 
  /\ es' := (if b  
             then addEntry(es, 'tval,'tkb kbname,pnotes,tm(modname',pntlT))
             else es fi) .

***(seq (fileread fname tmp) 
        (cd2plkb tmp modname kbname)
        (initKBgraph kbname)
        (graph2file gfname )
    )




endm


**** loadmaude loaded pla.maude
******************************************************************************
*** PLA based on IMaude 
*** defines initialization requests 
*** assembles remaining request modules
******************************************************************************
mod INTERACTIVE-PLA is

  inc PLA-KB .
  inc PLA-DISH .
  inc PLA-GRAPH .

****  inc PLA-EXPLORE .
  inc PLA-COMPARE .
****  inc PLA-INFO .
  inc PLA-INFOX .
  inc PLA-EXPORT .
  inc PLA-IMPORT .








******************************************************************************
*** Variables
******************************************************************************
var ctl : Control .
var wait4s : Wait4Set .
var reqQ reqQ' reqQ0 reqQ1 reqQ2 : RequestQ .
vars es es' : ESet .
var ee : Entry .
var ee? : Entry? .
var log : Log .

var n : Nat .
vars maudename g2dname g2dvname kbname modname restore? save? : Qid .
vars name reqid type tok mname gname dname  : Qid .
vars outQ toks toks' dnames : QidList .
var ?graph : Graph .
vars pntlT occsT : Term .
vars res0?? res1?? res?? : [ResultPair?] .
vars title msg ?string : String .


******************************************************************************
**** initializing the PLA environment
***** initPLAeset
****   initializes maudeName, g2dName, g2dVname globalCounter
******************************************************************************
 
op initPLAeset : ESet Qid Qid Qid -> ESet .
eq initPLAeset(es,maudename,g2dname,g2dvname) =
    addEntry(
     addEntry(
      addEntry(
       addEntry(
        addEntry(
         addEntry(es, 
                'qval, 'maudeName, ql(maudename)), 
                'qval, 'g2dName, ql(g2dname)), 
                'qval, 'g2dVName, ql(g2dvname)),
                'sval, 'globalCounter, sv("0")),
                'qval, 'knownDishes, ql(nil)),
                'qval, 'knownKBs, ql(nil)) .

eq isReq('initPLAeset) = true .
eq enabled(wait4s,
          req('initPLAeset, ql(maudename g2dname g2dvname toks),reqQ)) = true .

rl[initPLAeset]:
   [nil, 
    st(processing(req('initPLAeset, ql(maudename g2dname g2dvname toks),
                      reqQ')),
     wait4s,reqQ,es,log),
     outQ]
   =>
   [nil, 
    st(ready, wait4s, (reqQ reqQ'),
       initPLAeset(es,maudename,g2dname,g2dvname),log), 
    outQ] .

******************************************************************************
**** initialize KBmanager
**** invoke initKBmanager in viewer
******************************************************************************
  eq isReq('initKBManager) = true .
  eq enabled(wait4s,req('initKBManager,ql(g2dvname toks),reqQ)) = 
      not(waiting4(wait4s,g2dvname)) .

  crl[initKBManager]:
   [nil,
    st(processing(req('initKBManager, ql(g2dvname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
       (wait4s !
        wait4(g2dvname,nil,
              req('logreq, 
                   ql('initKBManager g2dvname toks),reqQ'))), 
       reqQ,
       es,
       log), outQ 
     g2dvname '\n mname '\n toks' maudePrompt ]
   if mname :=  getMaudeName(es)
   /\ ?string := withAck("(apply defKBManager)", mname,g2dvname) 
   /\ toks' := str2toks(?string) .

******************************************************************************
**** initialize KBmanager with predef dishes
**** invoke initKBmanager in viewer
******************************************************************************
  eq isReq('initKBManagerD) = true .
  eq enabled(wait4s,req('initKBManagerD,ql(g2dvname modname toks),reqQ)) = 
      not(waiting4(wait4s,g2dvname)) .

  crl[initKBManagerD]:
   [nil,
    st(processing(req('initKBManagerD, ql(g2dvname modname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
       (wait4s !
        wait4(g2dvname,nil,
              req('logreq, 
                   ql('initKBManagerD g2dvname modname toks),reqQ'))), 
       reqQ,
       es,
       log), outQ 
     g2dvname '\n mname '\n toks' maudePrompt ]
   if mname :=  getMaudeName(es)
   /\ dnames :=   constListBySortX(upOpDecls(modname,true),
                                   (lesserSorts([modname],'Dish) ; 'Dish )) 
   /\ ?string :=
        withAck("(apply defKBManagerD " 
       + fillTemplate(stringArrayTemplate, ("%strings" :~ qidl2squotes(dnames)))
       + ")", mname,g2dvname) 
   /\ toks' := str2toks(?string) .



***(
******************************************************************************
*** initPLAReq 
***   initializes eset 
***   initializes kb -- net and graph
***     if restore? == 'true get from file   ow construct from modname     
***     if save? == 'true save the initialized net and kbgraph
****       (toks is optional filename prefix override)
****    tells g2dvname about graph nodes 
****    initializes g2dvname dishmanager
****    starts KB listener

*** if restore specified and fails should it try from scratch?
*** toks could specify non-default names for file prefixes
******************************************************************************
  eq isReq('initPLAreq) = true .
  eq enabled(wait4s,req('initPLAreq,
            ql(maudename g2dname g2dvname kbname modname restore? save? toks),
            reqQ)) = true .

crl[initPLAreq]:
   [nil, 
    st(processing(req('initPLAreq, 
         ql(maudename g2dname g2dvname kbname modname restore? save? toks),
         reqQ')),
     wait4s,reqQ,es,log),
     outQ]
   =>
   [nil, 
    st(processing(reqQ0), wait4s,reqQ,es,log), 
    outQ]
  if reqQ2 := (if save? == 'true 
               then req('saveKB, ql(kbname toks),reqQ') 
               else reqQ' fi)
    /\ reqQ1 :=  req('defineKBGraph, ql(kbname  g2dvname),
                   req('initDishes,ql(kbname g2dvname modname), 
                     req('startcListener,
                         ql(kbname 'restartingListener g2dvname), reqQ2)))
    /\ reqQ0 :=
         req('initPLAeset, ql(maudename g2dname g2dvname),
              (if restore? == 'true
               then req('restoreKB, ql(kbname toks), reqQ1)
               else req('initKB, ql(kbname modname),reqQ1)
               fi) ) . 
)
******************************************************************************
**** (initDishes kbname  g2dvname modname)
**** tell viewer the names of predefined dishes
******************************************************************************
  eq isReq('initDishes) = true .
  eq enabled(wait4s,req('initDishes,ql(modname toks),reqQ)) = true .

  rl[initDishes]:
   [nil,
    st(processing(req('initDishes, ql(modname toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil, st(ready, wait4s, reqQ reqQ', initDishes(es,modname), log), outQ ] .

  op initDishes : ESet Qid -> ESet  .
  ceq initDishes(es,modname) = es'
   if dnames :=   constListBySortX(upOpDecls(modname,true),
                                   (lesserSorts([modname],'Dish) ; 'Dish )) 
   /\ es' := addPreDefDishes(es,
                      qvalQidList(getVal(es,'qval,'knownDishes,ql(nil))), 
                      dnames) .

  op addPreDefDishes : ESet QidList QidList -> ESet .
  eq addPreDefDishes(es,toks',nil) = 
       addEntry(es,'qval,'knownDishes,ql(toks')) .
  eq addPreDefDishes(es,toks', dname toks) = 
        addPreDefDishes(es,toks' dname dname, toks) . 


******************************************************************************
***** sendAlert
******************************************************************************
  eq isReq('sendAlert) = true .
  eq enabled(wait4s,req('sendAlert,ql(g2dvname type toks),reqQ)) = 
      not(waiting4(wait4s,g2dvname)) .

  crl[sendAlert]:
   [nil,
    st(processing(req('sendAlert, ql(g2dvname type toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready,
       (wait4s ! wait4(g2dvname,nil,nil)),
       (reqQ reqQ'),
       es,
       log), outQ 
     g2dvname '\n mname '\n toks' maudePrompt ]
   if mname :=  getMaudeName(es)
   /\ ?string :=
        withAck(mksendAlertExp(string(type),qidl2str(toks)), mname,g2dvname) 
   /\ toks' := str2toks(?string) .


  op sendAlertTemplate : -> String .
**** 09Oct10 stop progressd dialog if running
  eq sendAlertTemplate =
   "(seq  (apply closeProgressd) (apply displayMessage %title %msg))" .
  op mksendAlertExp : String String -> String .
  eq mksendAlertExp(title,msg) =
      fillTemplate(sendAlertTemplate, 
                   (("%title" :~ squote(title)),("%msg" :~ squote(msg)))) .

******************************************************************************
****  Debugging
******************************************************************************
***(  
var n : Nat .
vars maudename g2dname g2dvname kbname modname restore? save? : Qid .
vars name reqid type tok mname gname dname  : Qid .
vars outQ toks toks' dnames : QidList .
var ?graph : Graph .
vars pntlT occsT : Term .
vars res0?? res1?? res?? : [ResultPair?] .
vars title msg ?string : String .
)

   var t : Term .
   var val : Val .
   vars pname rid iob ix tag etype : Qid .
   vars pntTL tl occTL : TermList .
   var notes : Notes .
   var nodes : NodeList .

	op term2str : Term -> String .
	op termlist2str : NeTermList -> String .
	eq term2str(v:Variable) = string(v:Variable) .
	eq term2str(c:Constant) = string(c:Constant) .
	eq term2str(op:Qid[tl:NeTermList]) = 
	               string(op:Qid) + "[" + termlist2str(tl:NeTermList) + "]"  .
	eq termlist2str(t) = term2str(t) .
	eq termlist2str((t,tl:NeTermList)) =
	         term2str(t) + "," + termlist2str(tl:NeTermList)  .

	op val2str : Val -> String .
	eq val2str(dummy) = "dummy" .
	eq val2str(ql(toks)) = "QVal: " + qidl2str(toks) .
	eq val2str(sv(?string)) = "SVal: " + ?string .
	eq val2str(tm(modname,t)) = "TVal[" + string(modname) + "]: " + term2str(t) .
	eq val2str(val) = "???" [owise] .


	op pocc2str : ESet Qid Qid Qid Qid Qid -> String .
	ceq pocc2str(es,type,pname,rid,iob,ix) =
	   (if occTL :: Term then term2str(occTL) else "none.Occs" fi)
	if tm(modname,t) := getVal(es,'tval, type pname, dumTv)
	/\ pntTL := 
	      pntlT2pntTL(if modname == 'BOOL
	                  then 'nil.PNTransList
	                  else (if type == 'tkb or type == 'xnet
	                        then t
	                        else pnT2pntlT(t) fi)
	                   fi)
	/\ tl :=  metaGetTrans(pntTL,mkQidConst(rid))
	/\ n := (if rat(string(ix),10) :: Nat
	         then rat(string(ix),10) 
	         else 0
	         fi)
	/\ occTL := (if tl :: Term
	             then  (if iob == 'i
	                    then occsT2occTL(pntT2ioccsT(tl))
	                    else (if iob == 'o
	                    then occsT2occTL(pntT2ooccsT(tl))
	                    else occsT2occTL(pntT2boccsT(tl)) fi) fi)
	             else empty fi)  .


	op note2str : ESet Qid Qid QidList -> String .
	eq note2str(es,etype,tag,toks) =
        (if etype == 'tval
         then val2str(lookupd(getNotes(es,etype,toks),string(tag),dummy)) 
         else (if etype == 'gval 
               then gnote2str(es,etype,tag,toks)
               else "???"
               fi)
         fi)  .

	op gnote2str : ESet Qid Qid QidList -> String .
	ceq gnote2str(es,etype,tag,gname ix toks) =
         val2str(lookupd(notes,string(tag),dummy))
   if gv(?graph) := getVal(es,'gval,gname,gv(mtGraph))
	/\ n := (if rat(string(ix),10) :: Nat
	         then rat(string(ix),10) 
	         else 0
	         fi)
   /\ nodes := getNode(?graph,n) 
   /\ notes := (if nodes :: Node
                then nodeNotes(nodes)
                else mt fi)  .

	eq gnote2str(es,etype,tag,toks) = "???" [owise] .

**** (pocc2str type pname rid iob ix)

  eq isReq('pocc2str) = true .
  eq enabled(wait4s,req('pocc2str,ql(type pname rid iob ix toks),reqQ)) = true .

 
  rl[pocc2str]:
   [nil,
    st(processing(req('pocc2str, ql(type pname rid iob ix toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ, es,
       log), outQ 
     'user '\n getMaudeName(es) '\n 
          qid(pocc2str(es,type,pname,rid,iob,ix)) maudePrompt ]  .

**** (note2str etype tag ids)

  eq isReq('note2str) = true .
  eq enabled(wait4s,req('note2str,ql(etype tag toks),reqQ)) = true .

  rl[note2str]:
   [nil,
    st(processing(req('note2str, ql(etype tag toks),reqQ')), 
       wait4s,reqQ,es,log), 
    outQ]
     =>
   [nil,  
    st(ready, wait4s, reqQ, es,
       log), outQ 
     'user '\n getMaudeName(es) '\n 
          qid(note2str(es,etype,tag,toks)) maudePrompt ]  .

endm

loop init .

